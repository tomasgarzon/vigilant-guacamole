/*
Nucoro API

No description

API version: 4.175.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// ApiApiService ApiApi service
type ApiApiService service

type ApiApiSchemaRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	format *string
	lang *string
}

func (r ApiApiSchemaRetrieveRequest) Format(format string) ApiApiSchemaRetrieveRequest {
	r.format = &format
	return r
}
func (r ApiApiSchemaRetrieveRequest) Lang(lang string) ApiApiSchemaRetrieveRequest {
	r.lang = &lang
	return r
}

func (r ApiApiSchemaRetrieveRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ApiSchemaRetrieveExecute(r)
}

/*
ApiSchemaRetrieve Method for ApiSchemaRetrieve

OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiSchemaRetrieveRequest
*/
func (a *ApiApiService) ApiSchemaRetrieve(ctx _context.Context) ApiApiSchemaRetrieveRequest {
	return ApiApiSchemaRetrieveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApiApiService) ApiSchemaRetrieveExecute(r ApiApiSchemaRetrieveRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiSchemaRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/schema/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.oai.openapi", "application/yaml", "application/vnd.oai.openapi+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesEtsCategoriesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2AdviceEnginesEtsCategoriesListRequest) Limit(limit int32) ApiApiV2AdviceEnginesEtsCategoriesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AdviceEnginesEtsCategoriesListRequest) Offset(offset int32) ApiApiV2AdviceEnginesEtsCategoriesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2AdviceEnginesEtsCategoriesListRequest) Execute() (PaginatedCategoryList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesEtsCategoriesListExecute(r)
}

/*
ApiV2AdviceEnginesEtsCategoriesList Method for ApiV2AdviceEnginesEtsCategoriesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AdviceEnginesEtsCategoriesListRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesEtsCategoriesList(ctx _context.Context) ApiApiV2AdviceEnginesEtsCategoriesListRequest {
	return ApiApiV2AdviceEnginesEtsCategoriesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCategoryList
func (a *ApiApiService) ApiV2AdviceEnginesEtsCategoriesListExecute(r ApiApiV2AdviceEnginesEtsCategoriesListRequest) (PaginatedCategoryList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedCategoryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesEtsCategoriesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/ets/categories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest) Limit(limit int32) ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest) Offset(offset int32) ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest) Execute() (PaginatedCoreCategoryGroupList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesEtsCoreCategoryGroupsListExecute(r)
}

/*
ApiV2AdviceEnginesEtsCoreCategoryGroupsList Method for ApiV2AdviceEnginesEtsCoreCategoryGroupsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesEtsCoreCategoryGroupsList(ctx _context.Context) ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest {
	return ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCoreCategoryGroupList
func (a *ApiApiService) ApiV2AdviceEnginesEtsCoreCategoryGroupsListExecute(r ApiApiV2AdviceEnginesEtsCoreCategoryGroupsListRequest) (PaginatedCoreCategoryGroupList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedCoreCategoryGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesEtsCoreCategoryGroupsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/ets/core-category-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesEtsForecastCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	eTSForecastRequest *ETSForecastRequest
}

func (r ApiApiV2AdviceEnginesEtsForecastCreateRequest) ETSForecastRequest(eTSForecastRequest ETSForecastRequest) ApiApiV2AdviceEnginesEtsForecastCreateRequest {
	r.eTSForecastRequest = &eTSForecastRequest
	return r
}

func (r ApiApiV2AdviceEnginesEtsForecastCreateRequest) Execute() (ETSForecastRequest, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesEtsForecastCreateExecute(r)
}

/*
ApiV2AdviceEnginesEtsForecastCreate Method for ApiV2AdviceEnginesEtsForecastCreate

The forecast positions and amounts for the time_horizon and  risk_level chosen.
Taking into account the initial_auto_deposit and the initial_amount jointly with the selected filters.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AdviceEnginesEtsForecastCreateRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesEtsForecastCreate(ctx _context.Context) ApiApiV2AdviceEnginesEtsForecastCreateRequest {
	return ApiApiV2AdviceEnginesEtsForecastCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ETSForecastRequest
func (a *ApiApiService) ApiV2AdviceEnginesEtsForecastCreateExecute(r ApiApiV2AdviceEnginesEtsForecastCreateRequest) (ETSForecastRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ETSForecastRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesEtsForecastCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/ets/forecast/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.eTSForecastRequest == nil {
		return localVarReturnValue, nil, reportError("eTSForecastRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eTSForecastRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest) Limit(limit int32) ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest) Offset(offset int32) ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest) Execute() (PaginatedPresetCategoryGroupList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesEtsPresetCategoryGroupsListExecute(r)
}

/*
ApiV2AdviceEnginesEtsPresetCategoryGroupsList Method for ApiV2AdviceEnginesEtsPresetCategoryGroupsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesEtsPresetCategoryGroupsList(ctx _context.Context) ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest {
	return ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPresetCategoryGroupList
func (a *ApiApiService) ApiV2AdviceEnginesEtsPresetCategoryGroupsListExecute(r ApiApiV2AdviceEnginesEtsPresetCategoryGroupsListRequest) (PaginatedPresetCategoryGroupList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPresetCategoryGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesEtsPresetCategoryGroupsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/ets/preset-category-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	modelPortfolioForecastRequest *ModelPortfolioForecastRequest
}

func (r ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest) ModelPortfolioForecastRequest(modelPortfolioForecastRequest ModelPortfolioForecastRequest) ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest {
	r.modelPortfolioForecastRequest = &modelPortfolioForecastRequest
	return r
}

func (r ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest) Execute() (ModelPortfolioForecastRequest, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesModelPortfolioForecastCreateExecute(r)
}

/*
ApiV2AdviceEnginesModelPortfolioForecastCreate Method for ApiV2AdviceEnginesModelPortfolioForecastCreate

The forecast positions and amounts for the time_horizon chosen.
Taking into account the initial_auto_deposit and the initial_amount jointly with the selected filters.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesModelPortfolioForecastCreate(ctx _context.Context) ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest {
	return ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelPortfolioForecastRequest
func (a *ApiApiService) ApiV2AdviceEnginesModelPortfolioForecastCreateExecute(r ApiApiV2AdviceEnginesModelPortfolioForecastCreateRequest) (ModelPortfolioForecastRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelPortfolioForecastRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesModelPortfolioForecastCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/model-portfolio/forecast/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.modelPortfolioForecastRequest == nil {
		return localVarReturnValue, nil, reportError("modelPortfolioForecastRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelPortfolioForecastRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	extraData *map[string]interface{}
	limit *int32
	name *string
	offset *int32
	riskHigher *int32
	riskLevel *int32
	riskLower *int32
}

// Additional ModelPortfolio attributes
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) ExtraData(extraData map[string]interface{}) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.extraData = &extraData
	return r
}
// Number of results to return per page.
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) Limit(limit int32) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.limit = &limit
	return r
}
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) Name(name string) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.name = &name
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) Offset(offset int32) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) RiskHigher(riskHigher int32) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.riskHigher = &riskHigher
	return r
}
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) RiskLevel(riskLevel int32) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.riskLevel = &riskLevel
	return r
}
func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) RiskLower(riskLower int32) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	r.riskLower = &riskLower
	return r
}

func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) Execute() (PaginatedInvestorModelPortfolioList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesModelPortfolioModelPortfoliosListExecute(r)
}

/*
ApiV2AdviceEnginesModelPortfolioModelPortfoliosList Method for ApiV2AdviceEnginesModelPortfolioModelPortfoliosList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesModelPortfolioModelPortfoliosList(ctx _context.Context) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest {
	return ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInvestorModelPortfolioList
func (a *ApiApiService) ApiV2AdviceEnginesModelPortfolioModelPortfoliosListExecute(r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosListRequest) (PaginatedInvestorModelPortfolioList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedInvestorModelPortfolioList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesModelPortfolioModelPortfoliosList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/model-portfolio/model-portfolios/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.extraData != nil {
		localVarQueryParams.Add("extra_data", parameterToString(*r.extraData, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.riskHigher != nil {
		localVarQueryParams.Add("risk_higher", parameterToString(*r.riskHigher, ""))
	}
	if r.riskLevel != nil {
		localVarQueryParams.Add("risk_level", parameterToString(*r.riskLevel, ""))
	}
	if r.riskLower != nil {
		localVarQueryParams.Add("risk_lower", parameterToString(*r.riskLower, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	uuid string
}


func (r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequest) Execute() (InvestorModelPortfolio, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveExecute(r)
}

/*
ApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve Method for ApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequest
*/
func (a *ApiApiService) ApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve(ctx _context.Context, uuid string) ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequest {
	return ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return InvestorModelPortfolio
func (a *ApiApiService) ApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveExecute(r ApiApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequest) (InvestorModelPortfolio, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InvestorModelPortfolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/advice-engines/model-portfolio/model-portfolios/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsCategoriesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
	type_ *string
}

// Number of results to return per page.
func (r ApiApiV2AssetsCategoriesListRequest) Limit(limit int32) ApiApiV2AssetsCategoriesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AssetsCategoriesListRequest) Offset(offset int32) ApiApiV2AssetsCategoriesListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2AssetsCategoriesListRequest) Type_(type_ string) ApiApiV2AssetsCategoriesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiApiV2AssetsCategoriesListRequest) Execute() (PaginatedAssetCategoryList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsCategoriesListExecute(r)
}

/*
ApiV2AssetsCategoriesList Method for ApiV2AssetsCategoriesList

Retrieve all asset categories

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AssetsCategoriesListRequest
*/
func (a *ApiApiService) ApiV2AssetsCategoriesList(ctx _context.Context) ApiApiV2AssetsCategoriesListRequest {
	return ApiApiV2AssetsCategoriesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedAssetCategoryList
func (a *ApiApiService) ApiV2AssetsCategoriesListExecute(r ApiApiV2AssetsCategoriesListRequest) (PaginatedAssetCategoryList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAssetCategoryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsCategoriesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/categories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsIntradayPricesLatestRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetIdentifier string
}


func (r ApiApiV2AssetsIntradayPricesLatestRetrieveRequest) Execute() (IntradayPrice, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsIntradayPricesLatestRetrieveExecute(r)
}

/*
ApiV2AssetsIntradayPricesLatestRetrieve Method for ApiV2AssetsIntradayPricesLatestRetrieve

Prices (from an Asset) list view endpoints.

GET: Prices retrieve (rest framework builtin overriding get_object)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assetIdentifier
 @return ApiApiV2AssetsIntradayPricesLatestRetrieveRequest
*/
func (a *ApiApiService) ApiV2AssetsIntradayPricesLatestRetrieve(ctx _context.Context, assetIdentifier string) ApiApiV2AssetsIntradayPricesLatestRetrieveRequest {
	return ApiApiV2AssetsIntradayPricesLatestRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		assetIdentifier: assetIdentifier,
	}
}

// Execute executes the request
//  @return IntradayPrice
func (a *ApiApiService) ApiV2AssetsIntradayPricesLatestRetrieveExecute(r ApiApiV2AssetsIntradayPricesLatestRetrieveRequest) (IntradayPrice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IntradayPrice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsIntradayPricesLatestRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/{asset_identifier}/intraday-prices/latest/"
	localVarPath = strings.Replace(localVarPath, "{"+"asset_identifier"+"}", _neturl.PathEscape(parameterToString(r.assetIdentifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsIntradayPricesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetIdentifier string
	dateAfter *string
	dateBefore *string
	datetimeAfter *time.Time
	datetimeBefore *time.Time
	limit *int32
	offset *int32
}

func (r ApiApiV2AssetsIntradayPricesListRequest) DateAfter(dateAfter string) ApiApiV2AssetsIntradayPricesListRequest {
	r.dateAfter = &dateAfter
	return r
}
func (r ApiApiV2AssetsIntradayPricesListRequest) DateBefore(dateBefore string) ApiApiV2AssetsIntradayPricesListRequest {
	r.dateBefore = &dateBefore
	return r
}
func (r ApiApiV2AssetsIntradayPricesListRequest) DatetimeAfter(datetimeAfter time.Time) ApiApiV2AssetsIntradayPricesListRequest {
	r.datetimeAfter = &datetimeAfter
	return r
}
func (r ApiApiV2AssetsIntradayPricesListRequest) DatetimeBefore(datetimeBefore time.Time) ApiApiV2AssetsIntradayPricesListRequest {
	r.datetimeBefore = &datetimeBefore
	return r
}
// Number of results to return per page.
func (r ApiApiV2AssetsIntradayPricesListRequest) Limit(limit int32) ApiApiV2AssetsIntradayPricesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AssetsIntradayPricesListRequest) Offset(offset int32) ApiApiV2AssetsIntradayPricesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2AssetsIntradayPricesListRequest) Execute() (PaginatedIntradayPriceList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsIntradayPricesListExecute(r)
}

/*
ApiV2AssetsIntradayPricesList Method for ApiV2AssetsIntradayPricesList

Prices (from an Asset) list view endpoints.

GET: Prices retrieve (rest framework builtin overriding get_object)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assetIdentifier
 @return ApiApiV2AssetsIntradayPricesListRequest
*/
func (a *ApiApiService) ApiV2AssetsIntradayPricesList(ctx _context.Context, assetIdentifier string) ApiApiV2AssetsIntradayPricesListRequest {
	return ApiApiV2AssetsIntradayPricesListRequest{
		ApiService: a,
		ctx: ctx,
		assetIdentifier: assetIdentifier,
	}
}

// Execute executes the request
//  @return PaginatedIntradayPriceList
func (a *ApiApiService) ApiV2AssetsIntradayPricesListExecute(r ApiApiV2AssetsIntradayPricesListRequest) (PaginatedIntradayPriceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedIntradayPriceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsIntradayPricesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/{asset_identifier}/intraday-prices/"
	localVarPath = strings.Replace(localVarPath, "{"+"asset_identifier"+"}", _neturl.PathEscape(parameterToString(r.assetIdentifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.dateAfter != nil {
		localVarQueryParams.Add("date_after", parameterToString(*r.dateAfter, ""))
	}
	if r.dateBefore != nil {
		localVarQueryParams.Add("date_before", parameterToString(*r.dateBefore, ""))
	}
	if r.datetimeAfter != nil {
		localVarQueryParams.Add("datetime_after", parameterToString(*r.datetimeAfter, ""))
	}
	if r.datetimeBefore != nil {
		localVarQueryParams.Add("datetime_before", parameterToString(*r.datetimeBefore, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetType *string
	categoryCode *[]string
	categoryType *[]string
	currency *int32
	isin *string
	limit *int32
	market *int32
	name *string
	offset *int32
	status *string
	ticker *string
}

func (r ApiApiV2AssetsListRequest) AssetType(assetType string) ApiApiV2AssetsListRequest {
	r.assetType = &assetType
	return r
}
func (r ApiApiV2AssetsListRequest) CategoryCode(categoryCode []string) ApiApiV2AssetsListRequest {
	r.categoryCode = &categoryCode
	return r
}
func (r ApiApiV2AssetsListRequest) CategoryType(categoryType []string) ApiApiV2AssetsListRequest {
	r.categoryType = &categoryType
	return r
}
func (r ApiApiV2AssetsListRequest) Currency(currency int32) ApiApiV2AssetsListRequest {
	r.currency = &currency
	return r
}
func (r ApiApiV2AssetsListRequest) Isin(isin string) ApiApiV2AssetsListRequest {
	r.isin = &isin
	return r
}
// Number of results to return per page.
func (r ApiApiV2AssetsListRequest) Limit(limit int32) ApiApiV2AssetsListRequest {
	r.limit = &limit
	return r
}
func (r ApiApiV2AssetsListRequest) Market(market int32) ApiApiV2AssetsListRequest {
	r.market = &market
	return r
}
func (r ApiApiV2AssetsListRequest) Name(name string) ApiApiV2AssetsListRequest {
	r.name = &name
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AssetsListRequest) Offset(offset int32) ApiApiV2AssetsListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2AssetsListRequest) Status(status string) ApiApiV2AssetsListRequest {
	r.status = &status
	return r
}
func (r ApiApiV2AssetsListRequest) Ticker(ticker string) ApiApiV2AssetsListRequest {
	r.ticker = &ticker
	return r
}

func (r ApiApiV2AssetsListRequest) Execute() (PaginatedAssetListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsListExecute(r)
}

/*
ApiV2AssetsList Method for ApiV2AssetsList

A list of Assets filtered by category codes.
Default is an empty dict which returns the whole universe.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AssetsListRequest
*/
func (a *ApiApiService) ApiV2AssetsList(ctx _context.Context) ApiApiV2AssetsListRequest {
	return ApiApiV2AssetsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedAssetListList
func (a *ApiApiService) ApiV2AssetsListExecute(r ApiApiV2AssetsListRequest) (PaginatedAssetListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAssetListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.assetType != nil {
		localVarQueryParams.Add("asset_type", parameterToString(*r.assetType, ""))
	}
	if r.categoryCode != nil {
		t := *r.categoryCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("category_code", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("category_code", parameterToString(t, "multi"))
		}
	}
	if r.categoryType != nil {
		t := *r.categoryType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("category_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("category_type", parameterToString(t, "multi"))
		}
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	if r.isin != nil {
		localVarQueryParams.Add("isin", parameterToString(*r.isin, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.ticker != nil {
		localVarQueryParams.Add("ticker", parameterToString(*r.ticker, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsPerformanceListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetIdentifier string
	dateYearAfter *float32
	dateYearBefore *float32
	limit *int32
	offset *int32
}

func (r ApiApiV2AssetsPerformanceListRequest) DateYearAfter(dateYearAfter float32) ApiApiV2AssetsPerformanceListRequest {
	r.dateYearAfter = &dateYearAfter
	return r
}
func (r ApiApiV2AssetsPerformanceListRequest) DateYearBefore(dateYearBefore float32) ApiApiV2AssetsPerformanceListRequest {
	r.dateYearBefore = &dateYearBefore
	return r
}
// Number of results to return per page.
func (r ApiApiV2AssetsPerformanceListRequest) Limit(limit int32) ApiApiV2AssetsPerformanceListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AssetsPerformanceListRequest) Offset(offset int32) ApiApiV2AssetsPerformanceListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2AssetsPerformanceListRequest) Execute() (PaginatedAssetGrowthList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsPerformanceListExecute(r)
}

/*
ApiV2AssetsPerformanceList Method for ApiV2AssetsPerformanceList

Retrieve asset's yearly performance.

This View overwrites ListAPIView's 'list' method because it doesn't have
any hook that allows us to call 'get_asset_price_year_graph after the
filtering is applied.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assetIdentifier
 @return ApiApiV2AssetsPerformanceListRequest
*/
func (a *ApiApiService) ApiV2AssetsPerformanceList(ctx _context.Context, assetIdentifier string) ApiApiV2AssetsPerformanceListRequest {
	return ApiApiV2AssetsPerformanceListRequest{
		ApiService: a,
		ctx: ctx,
		assetIdentifier: assetIdentifier,
	}
}

// Execute executes the request
//  @return PaginatedAssetGrowthList
func (a *ApiApiService) ApiV2AssetsPerformanceListExecute(r ApiApiV2AssetsPerformanceListRequest) (PaginatedAssetGrowthList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAssetGrowthList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsPerformanceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/{asset_identifier}/performance/"
	localVarPath = strings.Replace(localVarPath, "{"+"asset_identifier"+"}", _neturl.PathEscape(parameterToString(r.assetIdentifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.dateYearAfter != nil {
		localVarQueryParams.Add("date_year_after", parameterToString(*r.dateYearAfter, ""))
	}
	if r.dateYearBefore != nil {
		localVarQueryParams.Add("date_year_before", parameterToString(*r.dateYearBefore, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsPricesLatestRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetIdentifier string
}


func (r ApiApiV2AssetsPricesLatestRetrieveRequest) Execute() (Price, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsPricesLatestRetrieveExecute(r)
}

/*
ApiV2AssetsPricesLatestRetrieve Method for ApiV2AssetsPricesLatestRetrieve

Prices (from an Asset) list view endpoints.

GET: Prices retrieve (rest framework builtin overriding get_object)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assetIdentifier
 @return ApiApiV2AssetsPricesLatestRetrieveRequest
*/
func (a *ApiApiService) ApiV2AssetsPricesLatestRetrieve(ctx _context.Context, assetIdentifier string) ApiApiV2AssetsPricesLatestRetrieveRequest {
	return ApiApiV2AssetsPricesLatestRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		assetIdentifier: assetIdentifier,
	}
}

// Execute executes the request
//  @return Price
func (a *ApiApiService) ApiV2AssetsPricesLatestRetrieveExecute(r ApiApiV2AssetsPricesLatestRetrieveRequest) (Price, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Price
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsPricesLatestRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/{asset_identifier}/prices/latest/"
	localVarPath = strings.Replace(localVarPath, "{"+"asset_identifier"+"}", _neturl.PathEscape(parameterToString(r.assetIdentifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsPricesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetIdentifier string
	dateAfter *string
	dateBefore *string
	datetimeAfter *time.Time
	datetimeBefore *time.Time
	limit *int32
	offset *int32
}

func (r ApiApiV2AssetsPricesListRequest) DateAfter(dateAfter string) ApiApiV2AssetsPricesListRequest {
	r.dateAfter = &dateAfter
	return r
}
func (r ApiApiV2AssetsPricesListRequest) DateBefore(dateBefore string) ApiApiV2AssetsPricesListRequest {
	r.dateBefore = &dateBefore
	return r
}
func (r ApiApiV2AssetsPricesListRequest) DatetimeAfter(datetimeAfter time.Time) ApiApiV2AssetsPricesListRequest {
	r.datetimeAfter = &datetimeAfter
	return r
}
func (r ApiApiV2AssetsPricesListRequest) DatetimeBefore(datetimeBefore time.Time) ApiApiV2AssetsPricesListRequest {
	r.datetimeBefore = &datetimeBefore
	return r
}
// Number of results to return per page.
func (r ApiApiV2AssetsPricesListRequest) Limit(limit int32) ApiApiV2AssetsPricesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2AssetsPricesListRequest) Offset(offset int32) ApiApiV2AssetsPricesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2AssetsPricesListRequest) Execute() (PaginatedPriceList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsPricesListExecute(r)
}

/*
ApiV2AssetsPricesList Method for ApiV2AssetsPricesList

Prices (from an Asset) list view endpoints.

GET: Prices retrieve (rest framework builtin overriding get_object)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assetIdentifier
 @return ApiApiV2AssetsPricesListRequest
*/
func (a *ApiApiService) ApiV2AssetsPricesList(ctx _context.Context, assetIdentifier string) ApiApiV2AssetsPricesListRequest {
	return ApiApiV2AssetsPricesListRequest{
		ApiService: a,
		ctx: ctx,
		assetIdentifier: assetIdentifier,
	}
}

// Execute executes the request
//  @return PaginatedPriceList
func (a *ApiApiService) ApiV2AssetsPricesListExecute(r ApiApiV2AssetsPricesListRequest) (PaginatedPriceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPriceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsPricesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/{asset_identifier}/prices/"
	localVarPath = strings.Replace(localVarPath, "{"+"asset_identifier"+"}", _neturl.PathEscape(parameterToString(r.assetIdentifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.dateAfter != nil {
		localVarQueryParams.Add("date_after", parameterToString(*r.dateAfter, ""))
	}
	if r.dateBefore != nil {
		localVarQueryParams.Add("date_before", parameterToString(*r.dateBefore, ""))
	}
	if r.datetimeAfter != nil {
		localVarQueryParams.Add("datetime_after", parameterToString(*r.datetimeAfter, ""))
	}
	if r.datetimeBefore != nil {
		localVarQueryParams.Add("datetime_before", parameterToString(*r.datetimeBefore, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AssetsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	assetIdentifier string
}


func (r ApiApiV2AssetsRetrieveRequest) Execute() (AssetDetail, *_nethttp.Response, error) {
	return r.ApiService.ApiV2AssetsRetrieveExecute(r)
}

/*
ApiV2AssetsRetrieve Method for ApiV2AssetsRetrieve

Allows get an asset instance by
* UUID
* ISIN
* ISIN & MARKET_CODE
* ISIN & MARKET_CODE & CURRENCY_CODE

Examples:
    * assets/a66633d7-4418-4c85-9582-01c80df531d4/
    * assets/IE00B579F325/
    * assets/IE00B579F325_XETR_GBP/
    * assets/IE00B579F325_XETR/

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assetIdentifier
 @return ApiApiV2AssetsRetrieveRequest
*/
func (a *ApiApiService) ApiV2AssetsRetrieve(ctx _context.Context, assetIdentifier string) ApiApiV2AssetsRetrieveRequest {
	return ApiApiV2AssetsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		assetIdentifier: assetIdentifier,
	}
}

// Execute executes the request
//  @return AssetDetail
func (a *ApiApiService) ApiV2AssetsRetrieveExecute(r ApiApiV2AssetsRetrieveRequest) (AssetDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AssetDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2AssetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/assets/{asset_identifier}/"
	localVarPath = strings.Replace(localVarPath, "{"+"asset_identifier"+"}", _neturl.PathEscape(parameterToString(r.assetIdentifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2BillingInvoicesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	dateFrom *string
	dateTo *string
	limit *int32
	offset *int32
	status *string
}

func (r ApiApiV2BillingInvoicesListRequest) DateFrom(dateFrom string) ApiApiV2BillingInvoicesListRequest {
	r.dateFrom = &dateFrom
	return r
}
func (r ApiApiV2BillingInvoicesListRequest) DateTo(dateTo string) ApiApiV2BillingInvoicesListRequest {
	r.dateTo = &dateTo
	return r
}
// Number of results to return per page.
func (r ApiApiV2BillingInvoicesListRequest) Limit(limit int32) ApiApiV2BillingInvoicesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2BillingInvoicesListRequest) Offset(offset int32) ApiApiV2BillingInvoicesListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2BillingInvoicesListRequest) Status(status string) ApiApiV2BillingInvoicesListRequest {
	r.status = &status
	return r
}

func (r ApiApiV2BillingInvoicesListRequest) Execute() (PaginatedInvoiceListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2BillingInvoicesListExecute(r)
}

/*
ApiV2BillingInvoicesList Method for ApiV2BillingInvoicesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2BillingInvoicesListRequest
*/
func (a *ApiApiService) ApiV2BillingInvoicesList(ctx _context.Context) ApiApiV2BillingInvoicesListRequest {
	return ApiApiV2BillingInvoicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInvoiceListList
func (a *ApiApiService) ApiV2BillingInvoicesListExecute(r ApiApiV2BillingInvoicesListRequest) (PaginatedInvoiceListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedInvoiceListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2BillingInvoicesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/billing/invoices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2BillingInvoicesRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	uuid string
	format *string
}

func (r ApiApiV2BillingInvoicesRetrieveRequest) Format(format string) ApiApiV2BillingInvoicesRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiApiV2BillingInvoicesRetrieveRequest) Execute() (InvoiceDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV2BillingInvoicesRetrieveExecute(r)
}

/*
ApiV2BillingInvoicesRetrieve Method for ApiV2BillingInvoicesRetrieve

This mixin implements binary responses.
It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiApiV2BillingInvoicesRetrieveRequest
*/
func (a *ApiApiService) ApiV2BillingInvoicesRetrieve(ctx _context.Context, uuid string) ApiApiV2BillingInvoicesRetrieveRequest {
	return ApiApiV2BillingInvoicesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return InvoiceDetails
func (a *ApiApiService) ApiV2BillingInvoicesRetrieveExecute(r ApiApiV2BillingInvoicesRetrieveRequest) (InvoiceDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InvoiceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2BillingInvoicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/billing/invoices/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/pdf", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2BrokerOrdersCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	createOrder *CreateOrder
}

func (r ApiApiV2BrokerOrdersCreateRequest) CreateOrder(createOrder CreateOrder) ApiApiV2BrokerOrdersCreateRequest {
	r.createOrder = &createOrder
	return r
}

func (r ApiApiV2BrokerOrdersCreateRequest) Execute() (CreateOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV2BrokerOrdersCreateExecute(r)
}

/*
ApiV2BrokerOrdersCreate Method for ApiV2BrokerOrdersCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2BrokerOrdersCreateRequest
*/
func (a *ApiApiService) ApiV2BrokerOrdersCreate(ctx _context.Context, portfolioUuid string) ApiApiV2BrokerOrdersCreateRequest {
	return ApiApiV2BrokerOrdersCreateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return CreateOrder
func (a *ApiApiService) ApiV2BrokerOrdersCreateExecute(r ApiApiV2BrokerOrdersCreateRequest) (CreateOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2BrokerOrdersCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/broker/orders/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createOrder == nil {
		return localVarReturnValue, nil, reportError("createOrder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrder
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2BrokerOrdersDestroyRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2BrokerOrdersDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2BrokerOrdersDestroyExecute(r)
}

/*
ApiV2BrokerOrdersDestroy Method for ApiV2BrokerOrdersDestroy

Cancel or request cancellation to the broker

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2BrokerOrdersDestroyRequest
*/
func (a *ApiApiService) ApiV2BrokerOrdersDestroy(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2BrokerOrdersDestroyRequest {
	return ApiApiV2BrokerOrdersDestroyRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2BrokerOrdersDestroyExecute(r ApiApiV2BrokerOrdersDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2BrokerOrdersDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/broker/orders/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2BrokerOrdersListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	adviceExternalId *string
	asset *string
	completedAfter *string
	completedBefore *string
	extraData *map[string]interface{}
	limit *int32
	offset *int32
	portfolio *string
	status *string
}

func (r ApiApiV2BrokerOrdersListRequest) AdviceExternalId(adviceExternalId string) ApiApiV2BrokerOrdersListRequest {
	r.adviceExternalId = &adviceExternalId
	return r
}
func (r ApiApiV2BrokerOrdersListRequest) Asset(asset string) ApiApiV2BrokerOrdersListRequest {
	r.asset = &asset
	return r
}
func (r ApiApiV2BrokerOrdersListRequest) CompletedAfter(completedAfter string) ApiApiV2BrokerOrdersListRequest {
	r.completedAfter = &completedAfter
	return r
}
func (r ApiApiV2BrokerOrdersListRequest) CompletedBefore(completedBefore string) ApiApiV2BrokerOrdersListRequest {
	r.completedBefore = &completedBefore
	return r
}
// Additional order attributes for the specific portal
func (r ApiApiV2BrokerOrdersListRequest) ExtraData(extraData map[string]interface{}) ApiApiV2BrokerOrdersListRequest {
	r.extraData = &extraData
	return r
}
// Number of results to return per page.
func (r ApiApiV2BrokerOrdersListRequest) Limit(limit int32) ApiApiV2BrokerOrdersListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2BrokerOrdersListRequest) Offset(offset int32) ApiApiV2BrokerOrdersListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2BrokerOrdersListRequest) Portfolio(portfolio string) ApiApiV2BrokerOrdersListRequest {
	r.portfolio = &portfolio
	return r
}
func (r ApiApiV2BrokerOrdersListRequest) Status(status string) ApiApiV2BrokerOrdersListRequest {
	r.status = &status
	return r
}

func (r ApiApiV2BrokerOrdersListRequest) Execute() (PaginatedOrderListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2BrokerOrdersListExecute(r)
}

/*
ApiV2BrokerOrdersList Method for ApiV2BrokerOrdersList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2BrokerOrdersListRequest
*/
func (a *ApiApiService) ApiV2BrokerOrdersList(ctx _context.Context, portfolioUuid string) ApiApiV2BrokerOrdersListRequest {
	return ApiApiV2BrokerOrdersListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedOrderListList
func (a *ApiApiService) ApiV2BrokerOrdersListExecute(r ApiApiV2BrokerOrdersListRequest) (PaginatedOrderListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedOrderListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2BrokerOrdersList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/broker/orders/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.adviceExternalId != nil {
		localVarQueryParams.Add("advice_external_id", parameterToString(*r.adviceExternalId, ""))
	}
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.completedAfter != nil {
		localVarQueryParams.Add("completed_after", parameterToString(*r.completedAfter, ""))
	}
	if r.completedBefore != nil {
		localVarQueryParams.Add("completed_before", parameterToString(*r.completedBefore, ""))
	}
	if r.extraData != nil {
		localVarQueryParams.Add("extra_data", parameterToString(*r.extraData, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.portfolio != nil {
		localVarQueryParams.Add("portfolio", parameterToString(*r.portfolio, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2BrokerOrdersRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2BrokerOrdersRetrieveRequest) Execute() (OrderList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2BrokerOrdersRetrieveExecute(r)
}

/*
ApiV2BrokerOrdersRetrieve Method for ApiV2BrokerOrdersRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2BrokerOrdersRetrieveRequest
*/
func (a *ApiApiService) ApiV2BrokerOrdersRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2BrokerOrdersRetrieveRequest {
	return ApiApiV2BrokerOrdersRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return OrderList
func (a *ApiApiService) ApiV2BrokerOrdersRetrieveExecute(r ApiApiV2BrokerOrdersRetrieveRequest) (OrderList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2BrokerOrdersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/broker/orders/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ClientsMeVerifyEmailCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	emailVerifyRequest *EmailVerifyRequest
}

func (r ApiApiV2ClientsMeVerifyEmailCreateRequest) EmailVerifyRequest(emailVerifyRequest EmailVerifyRequest) ApiApiV2ClientsMeVerifyEmailCreateRequest {
	r.emailVerifyRequest = &emailVerifyRequest
	return r
}

func (r ApiApiV2ClientsMeVerifyEmailCreateRequest) Execute() (EmailVerifyRequest, *_nethttp.Response, error) {
	return r.ApiService.ApiV2ClientsMeVerifyEmailCreateExecute(r)
}

/*
ApiV2ClientsMeVerifyEmailCreate Method for ApiV2ClientsMeVerifyEmailCreate

Request e-mail account verification notification.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2ClientsMeVerifyEmailCreateRequest
*/
func (a *ApiApiService) ApiV2ClientsMeVerifyEmailCreate(ctx _context.Context) ApiApiV2ClientsMeVerifyEmailCreateRequest {
	return ApiApiV2ClientsMeVerifyEmailCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmailVerifyRequest
func (a *ApiApiService) ApiV2ClientsMeVerifyEmailCreateExecute(r ApiApiV2ClientsMeVerifyEmailCreateRequest) (EmailVerifyRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EmailVerifyRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2ClientsMeVerifyEmailCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/me/verify/email/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailVerifyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ClientsNationalDocumentsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2ClientsNationalDocumentsListRequest) Limit(limit int32) ApiApiV2ClientsNationalDocumentsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2ClientsNationalDocumentsListRequest) Offset(offset int32) ApiApiV2ClientsNationalDocumentsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2ClientsNationalDocumentsListRequest) Execute() (PaginatedNationalDocumentList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2ClientsNationalDocumentsListExecute(r)
}

/*
ApiV2ClientsNationalDocumentsList Method for ApiV2ClientsNationalDocumentsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2ClientsNationalDocumentsListRequest
*/
func (a *ApiApiService) ApiV2ClientsNationalDocumentsList(ctx _context.Context) ApiApiV2ClientsNationalDocumentsListRequest {
	return ApiApiV2ClientsNationalDocumentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedNationalDocumentList
func (a *ApiApiService) ApiV2ClientsNationalDocumentsListExecute(r ApiApiV2ClientsNationalDocumentsListRequest) (PaginatedNationalDocumentList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedNationalDocumentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2ClientsNationalDocumentsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/national_documents/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ClientsReferralRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	referralCode string
}


func (r ApiApiV2ClientsReferralRetrieveRequest) Execute() (ClientReferral, *_nethttp.Response, error) {
	return r.ApiService.ApiV2ClientsReferralRetrieveExecute(r)
}

/*
ApiV2ClientsReferralRetrieve Method for ApiV2ClientsReferralRetrieve

Retrieves the currently logged in client referral code

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param referralCode
 @return ApiApiV2ClientsReferralRetrieveRequest
*/
func (a *ApiApiService) ApiV2ClientsReferralRetrieve(ctx _context.Context, referralCode string) ApiApiV2ClientsReferralRetrieveRequest {
	return ApiApiV2ClientsReferralRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		referralCode: referralCode,
	}
}

// Execute executes the request
//  @return ClientReferral
func (a *ApiApiService) ApiV2ClientsReferralRetrieveExecute(r ApiApiV2ClientsReferralRetrieveRequest) (ClientReferral, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClientReferral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2ClientsReferralRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/referral/{referral_code}/"
	localVarPath = strings.Replace(localVarPath, "{"+"referral_code"+"}", _neturl.PathEscape(parameterToString(r.referralCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ClientsVerifyEmailUpdateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	uuid string
	emailVerifyView *EmailVerifyView
}

func (r ApiApiV2ClientsVerifyEmailUpdateRequest) EmailVerifyView(emailVerifyView EmailVerifyView) ApiApiV2ClientsVerifyEmailUpdateRequest {
	r.emailVerifyView = &emailVerifyView
	return r
}

func (r ApiApiV2ClientsVerifyEmailUpdateRequest) Execute() (EmailVerifyView, *_nethttp.Response, error) {
	return r.ApiService.ApiV2ClientsVerifyEmailUpdateExecute(r)
}

/*
ApiV2ClientsVerifyEmailUpdate Method for ApiV2ClientsVerifyEmailUpdate

Verify e-mail account with the given email token.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiApiV2ClientsVerifyEmailUpdateRequest
*/
func (a *ApiApiService) ApiV2ClientsVerifyEmailUpdate(ctx _context.Context, uuid string) ApiApiV2ClientsVerifyEmailUpdateRequest {
	return ApiApiV2ClientsVerifyEmailUpdateRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return EmailVerifyView
func (a *ApiApiService) ApiV2ClientsVerifyEmailUpdateExecute(r ApiApiV2ClientsVerifyEmailUpdateRequest) (EmailVerifyView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EmailVerifyView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2ClientsVerifyEmailUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{uuid}/verify/email/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.emailVerifyView == nil {
		return localVarReturnValue, nil, reportError("emailVerifyView is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailVerifyView
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2FeedsAccessLogsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	browser *string
	browserVersion *string
	channel *string
	city *string
	country *int32
	deviceBrand *string
	deviceModel *string
	ipAddress *string
	limit *int32
	offset *int32
	os *string
	osVersion *string
	userAgent *string
}

func (r ApiApiV2FeedsAccessLogsListRequest) Browser(browser string) ApiApiV2FeedsAccessLogsListRequest {
	r.browser = &browser
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) BrowserVersion(browserVersion string) ApiApiV2FeedsAccessLogsListRequest {
	r.browserVersion = &browserVersion
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) Channel(channel string) ApiApiV2FeedsAccessLogsListRequest {
	r.channel = &channel
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) City(city string) ApiApiV2FeedsAccessLogsListRequest {
	r.city = &city
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) Country(country int32) ApiApiV2FeedsAccessLogsListRequest {
	r.country = &country
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) DeviceBrand(deviceBrand string) ApiApiV2FeedsAccessLogsListRequest {
	r.deviceBrand = &deviceBrand
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) DeviceModel(deviceModel string) ApiApiV2FeedsAccessLogsListRequest {
	r.deviceModel = &deviceModel
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) IpAddress(ipAddress string) ApiApiV2FeedsAccessLogsListRequest {
	r.ipAddress = &ipAddress
	return r
}
// Number of results to return per page.
func (r ApiApiV2FeedsAccessLogsListRequest) Limit(limit int32) ApiApiV2FeedsAccessLogsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2FeedsAccessLogsListRequest) Offset(offset int32) ApiApiV2FeedsAccessLogsListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) Os(os string) ApiApiV2FeedsAccessLogsListRequest {
	r.os = &os
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) OsVersion(osVersion string) ApiApiV2FeedsAccessLogsListRequest {
	r.osVersion = &osVersion
	return r
}
func (r ApiApiV2FeedsAccessLogsListRequest) UserAgent(userAgent string) ApiApiV2FeedsAccessLogsListRequest {
	r.userAgent = &userAgent
	return r
}

func (r ApiApiV2FeedsAccessLogsListRequest) Execute() (PaginatedAccessLogList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2FeedsAccessLogsListExecute(r)
}

/*
ApiV2FeedsAccessLogsList Method for ApiV2FeedsAccessLogsList

Retrieves the latest access to the client's account

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2FeedsAccessLogsListRequest
*/
func (a *ApiApiService) ApiV2FeedsAccessLogsList(ctx _context.Context) ApiApiV2FeedsAccessLogsListRequest {
	return ApiApiV2FeedsAccessLogsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedAccessLogList
func (a *ApiApiService) ApiV2FeedsAccessLogsListExecute(r ApiApiV2FeedsAccessLogsListRequest) (PaginatedAccessLogList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAccessLogList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2FeedsAccessLogsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/feeds/access-logs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.browser != nil {
		localVarQueryParams.Add("browser", parameterToString(*r.browser, ""))
	}
	if r.browserVersion != nil {
		localVarQueryParams.Add("browser_version", parameterToString(*r.browserVersion, ""))
	}
	if r.channel != nil {
		localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.city != nil {
		localVarQueryParams.Add("city", parameterToString(*r.city, ""))
	}
	if r.country != nil {
		localVarQueryParams.Add("country", parameterToString(*r.country, ""))
	}
	if r.deviceBrand != nil {
		localVarQueryParams.Add("device_brand", parameterToString(*r.deviceBrand, ""))
	}
	if r.deviceModel != nil {
		localVarQueryParams.Add("device_model", parameterToString(*r.deviceModel, ""))
	}
	if r.ipAddress != nil {
		localVarQueryParams.Add("ip_address", parameterToString(*r.ipAddress, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.os != nil {
		localVarQueryParams.Add("os", parameterToString(*r.os, ""))
	}
	if r.osVersion != nil {
		localVarQueryParams.Add("os_version", parameterToString(*r.osVersion, ""))
	}
	if r.userAgent != nil {
		localVarQueryParams.Add("user_agent", parameterToString(*r.userAgent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2FeedsActivitiesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
	target *[]string
}

// Number of results to return per page.
func (r ApiApiV2FeedsActivitiesListRequest) Limit(limit int32) ApiApiV2FeedsActivitiesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2FeedsActivitiesListRequest) Offset(offset int32) ApiApiV2FeedsActivitiesListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2FeedsActivitiesListRequest) Target(target []string) ApiApiV2FeedsActivitiesListRequest {
	r.target = &target
	return r
}

func (r ApiApiV2FeedsActivitiesListRequest) Execute() (PaginatedFeedActivityListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2FeedsActivitiesListExecute(r)
}

/*
ApiV2FeedsActivitiesList Method for ApiV2FeedsActivitiesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2FeedsActivitiesListRequest
*/
func (a *ApiApiService) ApiV2FeedsActivitiesList(ctx _context.Context) ApiApiV2FeedsActivitiesListRequest {
	return ApiApiV2FeedsActivitiesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedFeedActivityListList
func (a *ApiApiService) ApiV2FeedsActivitiesListExecute(r ApiApiV2FeedsActivitiesListRequest) (PaginatedFeedActivityListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedFeedActivityListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2FeedsActivitiesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/feeds/activities/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.target != nil {
		t := *r.target
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("target", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("target", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GoalsCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	goalUuid string
	goal *Goal
}

func (r ApiApiV2GoalsCreateRequest) Goal(goal Goal) ApiApiV2GoalsCreateRequest {
	r.goal = &goal
	return r
}

func (r ApiApiV2GoalsCreateRequest) Execute() (Goal, *_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsCreateExecute(r)
}

/*
ApiV2GoalsCreate Method for ApiV2GoalsCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalUuid
 @return ApiApiV2GoalsCreateRequest
*/
func (a *ApiApiService) ApiV2GoalsCreate(ctx _context.Context, goalUuid string) ApiApiV2GoalsCreateRequest {
	return ApiApiV2GoalsCreateRequest{
		ApiService: a,
		ctx: ctx,
		goalUuid: goalUuid,
	}
}

// Execute executes the request
//  @return Goal
func (a *ApiApiService) ApiV2GoalsCreateExecute(r ApiApiV2GoalsCreateRequest) (Goal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Goal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_uuid"+"}", _neturl.PathEscape(parameterToString(r.goalUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.goal == nil {
		return localVarReturnValue, nil, reportError("goal is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.goal
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GoalsDecumulationCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	forecastDecumulationRequest *ForecastDecumulationRequest
}

func (r ApiApiV2GoalsDecumulationCreateRequest) ForecastDecumulationRequest(forecastDecumulationRequest ForecastDecumulationRequest) ApiApiV2GoalsDecumulationCreateRequest {
	r.forecastDecumulationRequest = &forecastDecumulationRequest
	return r
}

func (r ApiApiV2GoalsDecumulationCreateRequest) Execute() (ForecastDecumulationRequest, *_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsDecumulationCreateExecute(r)
}

/*
ApiV2GoalsDecumulationCreate Method for ApiV2GoalsDecumulationCreate

Return a Goal Forecast Decumulation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2GoalsDecumulationCreateRequest
*/
func (a *ApiApiService) ApiV2GoalsDecumulationCreate(ctx _context.Context) ApiApiV2GoalsDecumulationCreateRequest {
	return ApiApiV2GoalsDecumulationCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForecastDecumulationRequest
func (a *ApiApiService) ApiV2GoalsDecumulationCreateExecute(r ApiApiV2GoalsDecumulationCreateRequest) (ForecastDecumulationRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ForecastDecumulationRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsDecumulationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/decumulation/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.forecastDecumulationRequest == nil {
		return localVarReturnValue, nil, reportError("forecastDecumulationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forecastDecumulationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GoalsDestroyRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	goalUuid string
	uuid string
}


func (r ApiApiV2GoalsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsDestroyExecute(r)
}

/*
ApiV2GoalsDestroy Method for ApiV2GoalsDestroy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalUuid
 @param uuid
 @return ApiApiV2GoalsDestroyRequest
*/
func (a *ApiApiService) ApiV2GoalsDestroy(ctx _context.Context, goalUuid string, uuid string) ApiApiV2GoalsDestroyRequest {
	return ApiApiV2GoalsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		goalUuid: goalUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2GoalsDestroyExecute(r ApiApiV2GoalsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_uuid"+"}", _neturl.PathEscape(parameterToString(r.goalUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2GoalsForecastCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	forecastRequest *ForecastRequest
}

func (r ApiApiV2GoalsForecastCreateRequest) ForecastRequest(forecastRequest ForecastRequest) ApiApiV2GoalsForecastCreateRequest {
	r.forecastRequest = &forecastRequest
	return r
}

func (r ApiApiV2GoalsForecastCreateRequest) Execute() (ForecastRequest, *_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsForecastCreateExecute(r)
}

/*
ApiV2GoalsForecastCreate Method for ApiV2GoalsForecastCreate

Return a Goal Forecast

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2GoalsForecastCreateRequest
*/
func (a *ApiApiService) ApiV2GoalsForecastCreate(ctx _context.Context) ApiApiV2GoalsForecastCreateRequest {
	return ApiApiV2GoalsForecastCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForecastRequest
func (a *ApiApiService) ApiV2GoalsForecastCreateExecute(r ApiApiV2GoalsForecastCreateRequest) (ForecastRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ForecastRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsForecastCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/forecast/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.forecastRequest == nil {
		return localVarReturnValue, nil, reportError("forecastRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forecastRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GoalsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	goalUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2GoalsListRequest) Limit(limit int32) ApiApiV2GoalsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2GoalsListRequest) Offset(offset int32) ApiApiV2GoalsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2GoalsListRequest) Execute() (PaginatedGoalList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsListExecute(r)
}

/*
ApiV2GoalsList Method for ApiV2GoalsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalUuid
 @return ApiApiV2GoalsListRequest
*/
func (a *ApiApiService) ApiV2GoalsList(ctx _context.Context, goalUuid string) ApiApiV2GoalsListRequest {
	return ApiApiV2GoalsListRequest{
		ApiService: a,
		ctx: ctx,
		goalUuid: goalUuid,
	}
}

// Execute executes the request
//  @return PaginatedGoalList
func (a *ApiApiService) ApiV2GoalsListExecute(r ApiApiV2GoalsListRequest) (PaginatedGoalList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedGoalList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_uuid"+"}", _neturl.PathEscape(parameterToString(r.goalUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GoalsPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	goalUuid string
	uuid string
	patchedGoal *PatchedGoal
}

func (r ApiApiV2GoalsPartialUpdateRequest) PatchedGoal(patchedGoal PatchedGoal) ApiApiV2GoalsPartialUpdateRequest {
	r.patchedGoal = &patchedGoal
	return r
}

func (r ApiApiV2GoalsPartialUpdateRequest) Execute() (Goal, *_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsPartialUpdateExecute(r)
}

/*
ApiV2GoalsPartialUpdate Method for ApiV2GoalsPartialUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalUuid
 @param uuid
 @return ApiApiV2GoalsPartialUpdateRequest
*/
func (a *ApiApiService) ApiV2GoalsPartialUpdate(ctx _context.Context, goalUuid string, uuid string) ApiApiV2GoalsPartialUpdateRequest {
	return ApiApiV2GoalsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		goalUuid: goalUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Goal
func (a *ApiApiService) ApiV2GoalsPartialUpdateExecute(r ApiApiV2GoalsPartialUpdateRequest) (Goal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Goal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_uuid"+"}", _neturl.PathEscape(parameterToString(r.goalUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGoal
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GoalsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	goalUuid string
	uuid string
}


func (r ApiApiV2GoalsRetrieveRequest) Execute() (Goal, *_nethttp.Response, error) {
	return r.ApiService.ApiV2GoalsRetrieveExecute(r)
}

/*
ApiV2GoalsRetrieve Method for ApiV2GoalsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalUuid
 @param uuid
 @return ApiApiV2GoalsRetrieveRequest
*/
func (a *ApiApiService) ApiV2GoalsRetrieve(ctx _context.Context, goalUuid string, uuid string) ApiApiV2GoalsRetrieveRequest {
	return ApiApiV2GoalsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		goalUuid: goalUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Goal
func (a *ApiApiService) ApiV2GoalsRetrieveExecute(r ApiApiV2GoalsRetrieveRequest) (Goal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Goal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2GoalsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/goals/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_uuid"+"}", _neturl.PathEscape(parameterToString(r.goalUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InboxConversationDetailMessagesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	conversation string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2InboxConversationDetailMessagesListRequest) Limit(limit int32) ApiApiV2InboxConversationDetailMessagesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2InboxConversationDetailMessagesListRequest) Offset(offset int32) ApiApiV2InboxConversationDetailMessagesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2InboxConversationDetailMessagesListRequest) Execute() (PaginatedMessageList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2InboxConversationDetailMessagesListExecute(r)
}

/*
ApiV2InboxConversationDetailMessagesList Method for ApiV2InboxConversationDetailMessagesList

List all messages from a conversation uuid

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversation
 @return ApiApiV2InboxConversationDetailMessagesListRequest
*/
func (a *ApiApiService) ApiV2InboxConversationDetailMessagesList(ctx _context.Context, conversation string) ApiApiV2InboxConversationDetailMessagesListRequest {
	return ApiApiV2InboxConversationDetailMessagesListRequest{
		ApiService: a,
		ctx: ctx,
		conversation: conversation,
	}
}

// Execute executes the request
//  @return PaginatedMessageList
func (a *ApiApiService) ApiV2InboxConversationDetailMessagesListExecute(r ApiApiV2InboxConversationDetailMessagesListRequest) (PaginatedMessageList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedMessageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2InboxConversationDetailMessagesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/inbox/conversations/{conversation}/"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation"+"}", _neturl.PathEscape(parameterToString(r.conversation, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InboxConversationsCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	uuid *string
	portal *int32
	created *time.Time
	subject *string
	messages *Message
}

func (r ApiApiV2InboxConversationsCreateRequest) Uuid(uuid string) ApiApiV2InboxConversationsCreateRequest {
	r.uuid = &uuid
	return r
}
func (r ApiApiV2InboxConversationsCreateRequest) Portal(portal int32) ApiApiV2InboxConversationsCreateRequest {
	r.portal = &portal
	return r
}
func (r ApiApiV2InboxConversationsCreateRequest) Created(created time.Time) ApiApiV2InboxConversationsCreateRequest {
	r.created = &created
	return r
}
func (r ApiApiV2InboxConversationsCreateRequest) Subject(subject string) ApiApiV2InboxConversationsCreateRequest {
	r.subject = &subject
	return r
}
func (r ApiApiV2InboxConversationsCreateRequest) Messages(messages Message) ApiApiV2InboxConversationsCreateRequest {
	r.messages = &messages
	return r
}

func (r ApiApiV2InboxConversationsCreateRequest) Execute() (ConversationCreate, *_nethttp.Response, error) {
	return r.ApiService.ApiV2InboxConversationsCreateExecute(r)
}

/*
ApiV2InboxConversationsCreate Method for ApiV2InboxConversationsCreate

get:
List all conversations with last_message of a user

post:
Create new conversation with N messages (without attachments)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InboxConversationsCreateRequest
*/
func (a *ApiApiService) ApiV2InboxConversationsCreate(ctx _context.Context) ApiApiV2InboxConversationsCreateRequest {
	return ApiApiV2InboxConversationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationCreate
func (a *ApiApiService) ApiV2InboxConversationsCreateExecute(r ApiApiV2InboxConversationsCreateRequest) (ConversationCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConversationCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2InboxConversationsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/inbox/conversations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}
	if r.portal == nil {
		return localVarReturnValue, nil, reportError("portal is required and must be specified")
	}
	if r.created == nil {
		return localVarReturnValue, nil, reportError("created is required and must be specified")
	}
	if r.subject == nil {
		return localVarReturnValue, nil, reportError("subject is required and must be specified")
	}
	if strlen(*r.subject) > 80 {
		return localVarReturnValue, nil, reportError("subject must have less than 80 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(*r.uuid, ""))
	localVarFormParams.Add("portal", parameterToString(*r.portal, ""))
	localVarFormParams.Add("created", parameterToString(*r.created, ""))
	localVarFormParams.Add("subject", parameterToString(*r.subject, ""))
	if r.messages != nil {
		paramJson, err := parameterToJson(*r.messages)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("messages", paramJson)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InboxConversationsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2InboxConversationsListRequest) Limit(limit int32) ApiApiV2InboxConversationsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2InboxConversationsListRequest) Offset(offset int32) ApiApiV2InboxConversationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2InboxConversationsListRequest) Execute() (PaginatedConversationListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2InboxConversationsListExecute(r)
}

/*
ApiV2InboxConversationsList Method for ApiV2InboxConversationsList

get:
List all conversations with last_message of a user

post:
Create new conversation with N messages (without attachments)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InboxConversationsListRequest
*/
func (a *ApiApiService) ApiV2InboxConversationsList(ctx _context.Context) ApiApiV2InboxConversationsListRequest {
	return ApiApiV2InboxConversationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedConversationListList
func (a *ApiApiService) ApiV2InboxConversationsListExecute(r ApiApiV2InboxConversationsListRequest) (PaginatedConversationListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedConversationListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2InboxConversationsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/inbox/conversations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	conversation string
	message string
	uuid string
	format *string
}

func (r ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest) Format(format string) ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest) Execute() (Attachment, *_nethttp.Response, error) {
	return r.ApiService.ApiV2InboxConversationsMessagesAttachmentsRetrieveExecute(r)
}

/*
ApiV2InboxConversationsMessagesAttachmentsRetrieve Method for ApiV2InboxConversationsMessagesAttachmentsRetrieve

View to access to an attachment

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversation
 @param message
 @param uuid
 @return ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest
*/
func (a *ApiApiService) ApiV2InboxConversationsMessagesAttachmentsRetrieve(ctx _context.Context, conversation string, message string, uuid string) ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest {
	return ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		conversation: conversation,
		message: message,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Attachment
func (a *ApiApiService) ApiV2InboxConversationsMessagesAttachmentsRetrieveExecute(r ApiApiV2InboxConversationsMessagesAttachmentsRetrieveRequest) (Attachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Attachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2InboxConversationsMessagesAttachmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/inbox/conversations/{conversation}/messages/{message}/attachments/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation"+"}", _neturl.PathEscape(parameterToString(r.conversation, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message"+"}", _neturl.PathEscape(parameterToString(r.message, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/pdf", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InboxConversationsMessagesCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	conversation string
	user *string
	readDate *time.Time
	created *time.Time
	attachments *[]Attachment
	uuid *string
	content *string
}

func (r ApiApiV2InboxConversationsMessagesCreateRequest) User(user string) ApiApiV2InboxConversationsMessagesCreateRequest {
	r.user = &user
	return r
}
func (r ApiApiV2InboxConversationsMessagesCreateRequest) ReadDate(readDate time.Time) ApiApiV2InboxConversationsMessagesCreateRequest {
	r.readDate = &readDate
	return r
}
func (r ApiApiV2InboxConversationsMessagesCreateRequest) Created(created time.Time) ApiApiV2InboxConversationsMessagesCreateRequest {
	r.created = &created
	return r
}
func (r ApiApiV2InboxConversationsMessagesCreateRequest) Attachments(attachments []Attachment) ApiApiV2InboxConversationsMessagesCreateRequest {
	r.attachments = &attachments
	return r
}
func (r ApiApiV2InboxConversationsMessagesCreateRequest) Uuid(uuid string) ApiApiV2InboxConversationsMessagesCreateRequest {
	r.uuid = &uuid
	return r
}
func (r ApiApiV2InboxConversationsMessagesCreateRequest) Content(content string) ApiApiV2InboxConversationsMessagesCreateRequest {
	r.content = &content
	return r
}

func (r ApiApiV2InboxConversationsMessagesCreateRequest) Execute() (Message, *_nethttp.Response, error) {
	return r.ApiService.ApiV2InboxConversationsMessagesCreateExecute(r)
}

/*
ApiV2InboxConversationsMessagesCreate Method for ApiV2InboxConversationsMessagesCreate

View for creating message on a specific conversation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversation
 @return ApiApiV2InboxConversationsMessagesCreateRequest
*/
func (a *ApiApiService) ApiV2InboxConversationsMessagesCreate(ctx _context.Context, conversation string) ApiApiV2InboxConversationsMessagesCreateRequest {
	return ApiApiV2InboxConversationsMessagesCreateRequest{
		ApiService: a,
		ctx: ctx,
		conversation: conversation,
	}
}

// Execute executes the request
//  @return Message
func (a *ApiApiService) ApiV2InboxConversationsMessagesCreateExecute(r ApiApiV2InboxConversationsMessagesCreateRequest) (Message, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2InboxConversationsMessagesCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/inbox/conversations/{conversation}/messages/"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation"+"}", _neturl.PathEscape(parameterToString(r.conversation, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}
	if r.readDate == nil {
		return localVarReturnValue, nil, reportError("readDate is required and must be specified")
	}
	if r.created == nil {
		return localVarReturnValue, nil, reportError("created is required and must be specified")
	}
	if r.attachments == nil {
		return localVarReturnValue, nil, reportError("attachments is required and must be specified")
	}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("user", parameterToString(*r.user, ""))
	localVarFormParams.Add("read_date", parameterToString(*r.readDate, ""))
	if r.content != nil {
		localVarFormParams.Add("content", parameterToString(*r.content, ""))
	}
	localVarFormParams.Add("created", parameterToString(*r.created, ""))
	localVarFormParams.Add("attachments", parameterToString(*r.attachments, "csv"))
	localVarFormParams.Add("uuid", parameterToString(*r.uuid, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2MobileVersionRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	platform string
}


func (r ApiApiV2MobileVersionRetrieveRequest) Execute() (MinimumAppVersion, *_nethttp.Response, error) {
	return r.ApiService.ApiV2MobileVersionRetrieveExecute(r)
}

/*
ApiV2MobileVersionRetrieve Method for ApiV2MobileVersionRetrieve

Returns the number of the last required APP Version for a platform.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platform
 @return ApiApiV2MobileVersionRetrieveRequest
*/
func (a *ApiApiService) ApiV2MobileVersionRetrieve(ctx _context.Context, platform string) ApiApiV2MobileVersionRetrieveRequest {
	return ApiApiV2MobileVersionRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		platform: platform,
	}
}

// Execute executes the request
//  @return MinimumAppVersion
func (a *ApiApiService) ApiV2MobileVersionRetrieveExecute(r ApiApiV2MobileVersionRetrieveRequest) (MinimumAppVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MinimumAppVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2MobileVersionRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/mobile/{platform}/version/"
	localVarPath = strings.Replace(localVarPath, "{"+"platform"+"}", _neturl.PathEscape(parameterToString(r.platform, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PlatformSettingsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
}


func (r ApiApiV2PlatformSettingsListRequest) Execute() ([]NucoroSetting, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PlatformSettingsListExecute(r)
}

/*
ApiV2PlatformSettingsList Method for ApiV2PlatformSettingsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2PlatformSettingsListRequest
*/
func (a *ApiApiService) ApiV2PlatformSettingsList(ctx _context.Context) ApiApiV2PlatformSettingsListRequest {
	return ApiApiV2PlatformSettingsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NucoroSetting
func (a *ApiApiService) ApiV2PlatformSettingsListExecute(r ApiApiV2PlatformSettingsListRequest) ([]NucoroSetting, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []NucoroSetting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PlatformSettingsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/platform/settings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortalCountriesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2PortalCountriesListRequest) Limit(limit int32) ApiApiV2PortalCountriesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortalCountriesListRequest) Offset(offset int32) ApiApiV2PortalCountriesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortalCountriesListRequest) Execute() (PaginatedCountryListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortalCountriesListExecute(r)
}

/*
ApiV2PortalCountriesList Method for ApiV2PortalCountriesList

Retrieves the list of countries

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2PortalCountriesListRequest
*/
func (a *ApiApiService) ApiV2PortalCountriesList(ctx _context.Context) ApiApiV2PortalCountriesListRequest {
	return ApiApiV2PortalCountriesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCountryListList
func (a *ApiApiService) ApiV2PortalCountriesListExecute(r ApiApiV2PortalCountriesListRequest) (PaginatedCountryListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedCountryListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortalCountriesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portal/countries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortalSettingsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
}


func (r ApiApiV2PortalSettingsRetrieveRequest) Execute() (PortalSettingValueList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortalSettingsRetrieveExecute(r)
}

/*
ApiV2PortalSettingsRetrieve Method for ApiV2PortalSettingsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2PortalSettingsRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortalSettingsRetrieve(ctx _context.Context) ApiApiV2PortalSettingsRetrieveRequest {
	return ApiApiV2PortalSettingsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PortalSettingValueList
func (a *ApiApiService) ApiV2PortalSettingsRetrieveExecute(r ApiApiV2PortalSettingsRetrieveRequest) (PortalSettingValueList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortalSettingValueList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortalSettingsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portal/settings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortalTosCurrentRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
}


func (r ApiApiV2PortalTosCurrentRetrieveRequest) Execute() (Tos, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortalTosCurrentRetrieveExecute(r)
}

/*
ApiV2PortalTosCurrentRetrieve Method for ApiV2PortalTosCurrentRetrieve

Retrieves the current ToS for the Portal

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2PortalTosCurrentRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortalTosCurrentRetrieve(ctx _context.Context) ApiApiV2PortalTosCurrentRetrieveRequest {
	return ApiApiV2PortalTosCurrentRetrieveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tos
func (a *ApiApiService) ApiV2PortalTosCurrentRetrieveExecute(r ApiApiV2PortalTosCurrentRetrieveRequest) (Tos, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tos
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortalTosCurrentRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portal/tos/current/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortalTosListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2PortalTosListRequest) Limit(limit int32) ApiApiV2PortalTosListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortalTosListRequest) Offset(offset int32) ApiApiV2PortalTosListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortalTosListRequest) Execute() (PaginatedTosList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortalTosListExecute(r)
}

/*
ApiV2PortalTosList Method for ApiV2PortalTosList

List all ToS for the current Portal

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2PortalTosListRequest
*/
func (a *ApiApiService) ApiV2PortalTosList(ctx _context.Context) ApiApiV2PortalTosListRequest {
	return ApiApiV2PortalTosListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTosList
func (a *ApiApiService) ApiV2PortalTosListExecute(r ApiApiV2PortalTosListRequest) (PaginatedTosList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedTosList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortalTosList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portal/tos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortalTosRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	uuid string
}


func (r ApiApiV2PortalTosRetrieveRequest) Execute() (Tos, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortalTosRetrieveExecute(r)
}

/*
ApiV2PortalTosRetrieve Method for ApiV2PortalTosRetrieve

Retrieves a specific ToS

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiApiV2PortalTosRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortalTosRetrieve(ctx _context.Context, uuid string) ApiApiV2PortalTosRetrieveRequest {
	return ApiApiV2PortalTosRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Tos
func (a *ApiApiService) ApiV2PortalTosRetrieveExecute(r ApiApiV2PortalTosRetrieveRequest) (Tos, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tos
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortalTosRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portal/tos/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosActivitiesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	limit *int32
	offset *int32
	target *[]string
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosActivitiesListRequest) Limit(limit int32) ApiApiV2PortfoliosActivitiesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosActivitiesListRequest) Offset(offset int32) ApiApiV2PortfoliosActivitiesListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2PortfoliosActivitiesListRequest) Target(target []string) ApiApiV2PortfoliosActivitiesListRequest {
	r.target = &target
	return r
}

func (r ApiApiV2PortfoliosActivitiesListRequest) Execute() (PaginatedFeedActivityListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosActivitiesListExecute(r)
}

/*
ApiV2PortfoliosActivitiesList Method for ApiV2PortfoliosActivitiesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosActivitiesListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosActivitiesList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosActivitiesListRequest {
	return ApiApiV2PortfoliosActivitiesListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedFeedActivityListList
func (a *ApiApiService) ApiV2PortfoliosActivitiesListExecute(r ApiApiV2PortfoliosActivitiesListRequest) (PaginatedFeedActivityListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedFeedActivityListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosActivitiesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/activities/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.target != nil {
		t := *r.target
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("target", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("target", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosActivitiesRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosActivitiesRetrieveRequest) Execute() (FeedActivityList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosActivitiesRetrieveExecute(r)
}

/*
ApiV2PortfoliosActivitiesRetrieve Method for ApiV2PortfoliosActivitiesRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosActivitiesRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosActivitiesRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosActivitiesRetrieveRequest {
	return ApiApiV2PortfoliosActivitiesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return FeedActivityList
func (a *ApiApiService) ApiV2PortfoliosActivitiesRetrieveExecute(r ApiApiV2PortfoliosActivitiesRetrieveRequest) (FeedActivityList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FeedActivityList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosActivitiesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/activities/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsEndDayRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
}


func (r ApiApiV2PortfoliosAllocationsEndDayRequest) Execute() (AllocationList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsEndDayExecute(r)
}

/*
ApiV2PortfoliosAllocationsEndDay Method for ApiV2PortfoliosAllocationsEndDay

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosAllocationsEndDayRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsEndDay(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosAllocationsEndDayRequest {
	return ApiApiV2PortfoliosAllocationsEndDayRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return AllocationList
func (a *ApiApiService) ApiV2PortfoliosAllocationsEndDayExecute(r ApiApiV2PortfoliosAllocationsEndDayRequest) (AllocationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AllocationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsEndDay")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsEndDayByDateRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	allocationDate string
	portfolioUuid string
}


func (r ApiApiV2PortfoliosAllocationsEndDayByDateRetrieveRequest) Execute() (AllocationDetail, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsEndDayByDateRetrieveExecute(r)
}

/*
ApiV2PortfoliosAllocationsEndDayByDateRetrieve Method for ApiV2PortfoliosAllocationsEndDayByDateRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param allocationDate
 @param portfolioUuid
 @return ApiApiV2PortfoliosAllocationsEndDayByDateRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsEndDayByDateRetrieve(ctx _context.Context, allocationDate string, portfolioUuid string) ApiApiV2PortfoliosAllocationsEndDayByDateRetrieveRequest {
	return ApiApiV2PortfoliosAllocationsEndDayByDateRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		allocationDate: allocationDate,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return AllocationDetail
func (a *ApiApiService) ApiV2PortfoliosAllocationsEndDayByDateRetrieveExecute(r ApiApiV2PortfoliosAllocationsEndDayByDateRetrieveRequest) (AllocationDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AllocationDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsEndDayByDateRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/{allocation_date}/"
	localVarPath = strings.Replace(localVarPath, "{"+"allocation_date"+"}", _neturl.PathEscape(parameterToString(r.allocationDate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsEndDayLatestRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
}


func (r ApiApiV2PortfoliosAllocationsEndDayLatestRetrieveRequest) Execute() (AllocationDetail, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsEndDayLatestRetrieveExecute(r)
}

/*
ApiV2PortfoliosAllocationsEndDayLatestRetrieve Method for ApiV2PortfoliosAllocationsEndDayLatestRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosAllocationsEndDayLatestRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsEndDayLatestRetrieve(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosAllocationsEndDayLatestRetrieveRequest {
	return ApiApiV2PortfoliosAllocationsEndDayLatestRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return AllocationDetail
func (a *ApiApiService) ApiV2PortfoliosAllocationsEndDayLatestRetrieveExecute(r ApiApiV2PortfoliosAllocationsEndDayLatestRetrieveRequest) (AllocationDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AllocationDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsEndDayLatestRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/latest/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsHistoryRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolio string
}


func (r ApiApiV2PortfoliosAllocationsHistoryRetrieveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsHistoryRetrieveExecute(r)
}

/*
ApiV2PortfoliosAllocationsHistoryRetrieve Method for ApiV2PortfoliosAllocationsHistoryRetrieve

Allocations History for a given portfolio

It accepts two optional parameters, `date_to` and `date_from` to limit
the daily allocations to a certain data range. If they are not given, all the
allocations are returned.

---

## Parameters:

 * **name**: `date_from`
 * **description**: The initial date.
 * **parameter type**: query param

 * **name**: `date_from`
 * **description**: The final date.
 * **parameter type**: query param

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolio
 @return ApiApiV2PortfoliosAllocationsHistoryRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsHistoryRetrieve(ctx _context.Context, portfolio string) ApiApiV2PortfoliosAllocationsHistoryRetrieveRequest {
	return ApiApiV2PortfoliosAllocationsHistoryRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolio: portfolio,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2PortfoliosAllocationsHistoryRetrieveExecute(r ApiApiV2PortfoliosAllocationsHistoryRetrieveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsHistoryRetrieve")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio}/allocations/history/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio"+"}", _neturl.PathEscape(parameterToString(r.portfolio, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsIntradayLatestRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
}


func (r ApiApiV2PortfoliosAllocationsIntradayLatestRetrieveRequest) Execute() (CurrentAllocation, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsIntradayLatestRetrieveExecute(r)
}

/*
ApiV2PortfoliosAllocationsIntradayLatestRetrieve Method for ApiV2PortfoliosAllocationsIntradayLatestRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosAllocationsIntradayLatestRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsIntradayLatestRetrieve(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosAllocationsIntradayLatestRetrieveRequest {
	return ApiApiV2PortfoliosAllocationsIntradayLatestRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return CurrentAllocation
func (a *ApiApiService) ApiV2PortfoliosAllocationsIntradayLatestRetrieveExecute(r ApiApiV2PortfoliosAllocationsIntradayLatestRetrieveRequest) (CurrentAllocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrentAllocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsIntradayLatestRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/allocations/intraday/latest/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	limit *int32
	offset *int32
	valuationDateAfter *string
	valuationDateBefore *string
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosAllocationsListRequest) Limit(limit int32) ApiApiV2PortfoliosAllocationsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosAllocationsListRequest) Offset(offset int32) ApiApiV2PortfoliosAllocationsListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2PortfoliosAllocationsListRequest) ValuationDateAfter(valuationDateAfter string) ApiApiV2PortfoliosAllocationsListRequest {
	r.valuationDateAfter = &valuationDateAfter
	return r
}
func (r ApiApiV2PortfoliosAllocationsListRequest) ValuationDateBefore(valuationDateBefore string) ApiApiV2PortfoliosAllocationsListRequest {
	r.valuationDateBefore = &valuationDateBefore
	return r
}

func (r ApiApiV2PortfoliosAllocationsListRequest) Execute() (PaginatedAllocationListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsListExecute(r)
}

/*
ApiV2PortfoliosAllocationsList Method for ApiV2PortfoliosAllocationsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosAllocationsListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosAllocationsListRequest {
	return ApiApiV2PortfoliosAllocationsListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedAllocationListList
func (a *ApiApiService) ApiV2PortfoliosAllocationsListExecute(r ApiApiV2PortfoliosAllocationsListRequest) (PaginatedAllocationListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAllocationListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/allocations/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.valuationDateAfter != nil {
		localVarQueryParams.Add("valuation_date_after", parameterToString(*r.valuationDateAfter, ""))
	}
	if r.valuationDateBefore != nil {
		localVarQueryParams.Add("valuation_date_before", parameterToString(*r.valuationDateBefore, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosAllocationsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	id int32
	portfolioUuid string
}


func (r ApiApiV2PortfoliosAllocationsRetrieveRequest) Execute() (AllocationList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosAllocationsRetrieveExecute(r)
}

/*
ApiV2PortfoliosAllocationsRetrieve Method for ApiV2PortfoliosAllocationsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this allocation.
 @param portfolioUuid
 @return ApiApiV2PortfoliosAllocationsRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosAllocationsRetrieve(ctx _context.Context, id int32, portfolioUuid string) ApiApiV2PortfoliosAllocationsRetrieveRequest {
	return ApiApiV2PortfoliosAllocationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return AllocationList
func (a *ApiApiService) ApiV2PortfoliosAllocationsRetrieveExecute(r ApiApiV2PortfoliosAllocationsRetrieveRequest) (AllocationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AllocationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosAllocationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/allocations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	portfolioCreate *PortfolioCreate
}

func (r ApiApiV2PortfoliosCreateRequest) PortfolioCreate(portfolioCreate PortfolioCreate) ApiApiV2PortfoliosCreateRequest {
	r.portfolioCreate = &portfolioCreate
	return r
}

func (r ApiApiV2PortfoliosCreateRequest) Execute() (PortfolioCreate, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosCreateExecute(r)
}

/*
ApiV2PortfoliosCreate Method for ApiV2PortfoliosCreate

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosCreateRequest
*/
func (a *ApiApiService) ApiV2PortfoliosCreate(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosCreateRequest {
	return ApiApiV2PortfoliosCreateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PortfolioCreate
func (a *ApiApiService) ApiV2PortfoliosCreateExecute(r ApiApiV2PortfoliosCreateRequest) (PortfolioCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortfolioCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.portfolioCreate == nil {
		return localVarReturnValue, nil, reportError("portfolioCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.portfolioCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosDepositsCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	depositCreate *DepositCreate
}

func (r ApiApiV2PortfoliosDepositsCreateRequest) DepositCreate(depositCreate DepositCreate) ApiApiV2PortfoliosDepositsCreateRequest {
	r.depositCreate = &depositCreate
	return r
}

func (r ApiApiV2PortfoliosDepositsCreateRequest) Execute() (DepositCreate, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosDepositsCreateExecute(r)
}

/*
ApiV2PortfoliosDepositsCreate Method for ApiV2PortfoliosDepositsCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosDepositsCreateRequest
*/
func (a *ApiApiService) ApiV2PortfoliosDepositsCreate(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosDepositsCreateRequest {
	return ApiApiV2PortfoliosDepositsCreateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return DepositCreate
func (a *ApiApiService) ApiV2PortfoliosDepositsCreateExecute(r ApiApiV2PortfoliosDepositsCreateRequest) (DepositCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DepositCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosDepositsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/deposits/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.depositCreate == nil {
		return localVarReturnValue, nil, reportError("depositCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.depositCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosDepositsDestroyRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosDepositsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosDepositsDestroyExecute(r)
}

/*
ApiV2PortfoliosDepositsDestroy Method for ApiV2PortfoliosDepositsDestroy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosDepositsDestroyRequest
*/
func (a *ApiApiService) ApiV2PortfoliosDepositsDestroy(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosDepositsDestroyRequest {
	return ApiApiV2PortfoliosDepositsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2PortfoliosDepositsDestroyExecute(r ApiApiV2PortfoliosDepositsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosDepositsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/deposits/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosDepositsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	limit *int32
	offset *int32
	status *[]string
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosDepositsListRequest) Limit(limit int32) ApiApiV2PortfoliosDepositsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosDepositsListRequest) Offset(offset int32) ApiApiV2PortfoliosDepositsListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2PortfoliosDepositsListRequest) Status(status []string) ApiApiV2PortfoliosDepositsListRequest {
	r.status = &status
	return r
}

func (r ApiApiV2PortfoliosDepositsListRequest) Execute() (PaginatedDepositListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosDepositsListExecute(r)
}

/*
ApiV2PortfoliosDepositsList Method for ApiV2PortfoliosDepositsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosDepositsListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosDepositsList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosDepositsListRequest {
	return ApiApiV2PortfoliosDepositsListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedDepositListList
func (a *ApiApiService) ApiV2PortfoliosDepositsListExecute(r ApiApiV2PortfoliosDepositsListRequest) (PaginatedDepositListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedDepositListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosDepositsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/deposits/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosDepositsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosDepositsRetrieveRequest) Execute() (DepositDetail, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosDepositsRetrieveExecute(r)
}

/*
ApiV2PortfoliosDepositsRetrieve Method for ApiV2PortfoliosDepositsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosDepositsRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosDepositsRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosDepositsRetrieveRequest {
	return ApiApiV2PortfoliosDepositsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return DepositDetail
func (a *ApiApiService) ApiV2PortfoliosDepositsRetrieveExecute(r ApiApiV2PortfoliosDepositsRetrieveRequest) (DepositDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DepositDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosDepositsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/deposits/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosDestroyRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosDestroyExecute(r)
}

/*
ApiV2PortfoliosDestroy Method for ApiV2PortfoliosDestroy

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosDestroyRequest
*/
func (a *ApiApiService) ApiV2PortfoliosDestroy(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosDestroyRequest {
	return ApiApiV2PortfoliosDestroyRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2PortfoliosDestroyExecute(r ApiApiV2PortfoliosDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	client *string
	externalCustodianId *string
	limit *int32
	name *string
	offset *int32
	ordering *[]string
	portfolioType *int32
	status *[]string
	valuationDateAfter *string
	valuationDateBefore *string
}

func (r ApiApiV2PortfoliosListRequest) Client(client string) ApiApiV2PortfoliosListRequest {
	r.client = &client
	return r
}
func (r ApiApiV2PortfoliosListRequest) ExternalCustodianId(externalCustodianId string) ApiApiV2PortfoliosListRequest {
	r.externalCustodianId = &externalCustodianId
	return r
}
// Number of results to return per page.
func (r ApiApiV2PortfoliosListRequest) Limit(limit int32) ApiApiV2PortfoliosListRequest {
	r.limit = &limit
	return r
}
func (r ApiApiV2PortfoliosListRequest) Name(name string) ApiApiV2PortfoliosListRequest {
	r.name = &name
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosListRequest) Offset(offset int32) ApiApiV2PortfoliosListRequest {
	r.offset = &offset
	return r
}
// Ordering
func (r ApiApiV2PortfoliosListRequest) Ordering(ordering []string) ApiApiV2PortfoliosListRequest {
	r.ordering = &ordering
	return r
}
func (r ApiApiV2PortfoliosListRequest) PortfolioType(portfolioType int32) ApiApiV2PortfoliosListRequest {
	r.portfolioType = &portfolioType
	return r
}
func (r ApiApiV2PortfoliosListRequest) Status(status []string) ApiApiV2PortfoliosListRequest {
	r.status = &status
	return r
}
func (r ApiApiV2PortfoliosListRequest) ValuationDateAfter(valuationDateAfter string) ApiApiV2PortfoliosListRequest {
	r.valuationDateAfter = &valuationDateAfter
	return r
}
func (r ApiApiV2PortfoliosListRequest) ValuationDateBefore(valuationDateBefore string) ApiApiV2PortfoliosListRequest {
	r.valuationDateBefore = &valuationDateBefore
	return r
}

func (r ApiApiV2PortfoliosListRequest) Execute() (PaginatedPortfolioListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosListExecute(r)
}

/*
ApiV2PortfoliosList Method for ApiV2PortfoliosList

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosListRequest {
	return ApiApiV2PortfoliosListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedPortfolioListList
func (a *ApiApiService) ApiV2PortfoliosListExecute(r ApiApiV2PortfoliosListRequest) (PaginatedPortfolioListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPortfolioListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.client != nil {
		localVarQueryParams.Add("client", parameterToString(*r.client, ""))
	}
	if r.externalCustodianId != nil {
		localVarQueryParams.Add("external_custodian_id", parameterToString(*r.externalCustodianId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.portfolioType != nil {
		localVarQueryParams.Add("portfolio_type", parameterToString(*r.portfolioType, ""))
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.valuationDateAfter != nil {
		localVarQueryParams.Add("valuation_date_after", parameterToString(*r.valuationDateAfter, ""))
	}
	if r.valuationDateBefore != nil {
		localVarQueryParams.Add("valuation_date_before", parameterToString(*r.valuationDateBefore, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosOrdersCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	createOrder *CreateOrder
}

func (r ApiApiV2PortfoliosOrdersCreateRequest) CreateOrder(createOrder CreateOrder) ApiApiV2PortfoliosOrdersCreateRequest {
	r.createOrder = &createOrder
	return r
}

func (r ApiApiV2PortfoliosOrdersCreateRequest) Execute() (CreateOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosOrdersCreateExecute(r)
}

/*
ApiV2PortfoliosOrdersCreate Method for ApiV2PortfoliosOrdersCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosOrdersCreateRequest
*/
func (a *ApiApiService) ApiV2PortfoliosOrdersCreate(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosOrdersCreateRequest {
	return ApiApiV2PortfoliosOrdersCreateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return CreateOrder
func (a *ApiApiService) ApiV2PortfoliosOrdersCreateExecute(r ApiApiV2PortfoliosOrdersCreateRequest) (CreateOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosOrdersCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/orders/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createOrder == nil {
		return localVarReturnValue, nil, reportError("createOrder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrder
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosOrdersDestroyRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosOrdersDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosOrdersDestroyExecute(r)
}

/*
ApiV2PortfoliosOrdersDestroy Method for ApiV2PortfoliosOrdersDestroy

Cancel or request cancellation to the broker

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosOrdersDestroyRequest
*/
func (a *ApiApiService) ApiV2PortfoliosOrdersDestroy(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosOrdersDestroyRequest {
	return ApiApiV2PortfoliosOrdersDestroyRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2PortfoliosOrdersDestroyExecute(r ApiApiV2PortfoliosOrdersDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosOrdersDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/orders/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosOrdersListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	adviceExternalId *string
	asset *string
	completedAfter *string
	completedBefore *string
	extraData *map[string]interface{}
	limit *int32
	offset *int32
	portfolio *string
	status *string
}

func (r ApiApiV2PortfoliosOrdersListRequest) AdviceExternalId(adviceExternalId string) ApiApiV2PortfoliosOrdersListRequest {
	r.adviceExternalId = &adviceExternalId
	return r
}
func (r ApiApiV2PortfoliosOrdersListRequest) Asset(asset string) ApiApiV2PortfoliosOrdersListRequest {
	r.asset = &asset
	return r
}
func (r ApiApiV2PortfoliosOrdersListRequest) CompletedAfter(completedAfter string) ApiApiV2PortfoliosOrdersListRequest {
	r.completedAfter = &completedAfter
	return r
}
func (r ApiApiV2PortfoliosOrdersListRequest) CompletedBefore(completedBefore string) ApiApiV2PortfoliosOrdersListRequest {
	r.completedBefore = &completedBefore
	return r
}
// Additional order attributes for the specific portal
func (r ApiApiV2PortfoliosOrdersListRequest) ExtraData(extraData map[string]interface{}) ApiApiV2PortfoliosOrdersListRequest {
	r.extraData = &extraData
	return r
}
// Number of results to return per page.
func (r ApiApiV2PortfoliosOrdersListRequest) Limit(limit int32) ApiApiV2PortfoliosOrdersListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosOrdersListRequest) Offset(offset int32) ApiApiV2PortfoliosOrdersListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2PortfoliosOrdersListRequest) Portfolio(portfolio string) ApiApiV2PortfoliosOrdersListRequest {
	r.portfolio = &portfolio
	return r
}
func (r ApiApiV2PortfoliosOrdersListRequest) Status(status string) ApiApiV2PortfoliosOrdersListRequest {
	r.status = &status
	return r
}

func (r ApiApiV2PortfoliosOrdersListRequest) Execute() (PaginatedOrderListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosOrdersListExecute(r)
}

/*
ApiV2PortfoliosOrdersList Method for ApiV2PortfoliosOrdersList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosOrdersListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosOrdersList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosOrdersListRequest {
	return ApiApiV2PortfoliosOrdersListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedOrderListList
func (a *ApiApiService) ApiV2PortfoliosOrdersListExecute(r ApiApiV2PortfoliosOrdersListRequest) (PaginatedOrderListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedOrderListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosOrdersList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/orders/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.adviceExternalId != nil {
		localVarQueryParams.Add("advice_external_id", parameterToString(*r.adviceExternalId, ""))
	}
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.completedAfter != nil {
		localVarQueryParams.Add("completed_after", parameterToString(*r.completedAfter, ""))
	}
	if r.completedBefore != nil {
		localVarQueryParams.Add("completed_before", parameterToString(*r.completedBefore, ""))
	}
	if r.extraData != nil {
		localVarQueryParams.Add("extra_data", parameterToString(*r.extraData, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.portfolio != nil {
		localVarQueryParams.Add("portfolio", parameterToString(*r.portfolio, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosOrdersRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosOrdersRetrieveRequest) Execute() (OrderList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosOrdersRetrieveExecute(r)
}

/*
ApiV2PortfoliosOrdersRetrieve Method for ApiV2PortfoliosOrdersRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosOrdersRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosOrdersRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosOrdersRetrieveRequest {
	return ApiApiV2PortfoliosOrdersRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return OrderList
func (a *ApiApiService) ApiV2PortfoliosOrdersRetrieveExecute(r ApiApiV2PortfoliosOrdersRetrieveRequest) (OrderList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosOrdersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/orders/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
	patchedPortfolioUpdate *PatchedPortfolioUpdate
}

func (r ApiApiV2PortfoliosPartialUpdateRequest) PatchedPortfolioUpdate(patchedPortfolioUpdate PatchedPortfolioUpdate) ApiApiV2PortfoliosPartialUpdateRequest {
	r.patchedPortfolioUpdate = &patchedPortfolioUpdate
	return r
}

func (r ApiApiV2PortfoliosPartialUpdateRequest) Execute() (PortfolioUpdate, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosPartialUpdateExecute(r)
}

/*
ApiV2PortfoliosPartialUpdate Method for ApiV2PortfoliosPartialUpdate

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosPartialUpdateRequest
*/
func (a *ApiApiService) ApiV2PortfoliosPartialUpdate(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosPartialUpdateRequest {
	return ApiApiV2PortfoliosPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return PortfolioUpdate
func (a *ApiApiService) ApiV2PortfoliosPartialUpdateExecute(r ApiApiV2PortfoliosPartialUpdateRequest) (PortfolioUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortfolioUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPortfolioUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosPerformanceMwrrListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	dateAfter *string
	dateBefore *string
	limit *int32
	offset *int32
}

func (r ApiApiV2PortfoliosPerformanceMwrrListRequest) DateAfter(dateAfter string) ApiApiV2PortfoliosPerformanceMwrrListRequest {
	r.dateAfter = &dateAfter
	return r
}
func (r ApiApiV2PortfoliosPerformanceMwrrListRequest) DateBefore(dateBefore string) ApiApiV2PortfoliosPerformanceMwrrListRequest {
	r.dateBefore = &dateBefore
	return r
}
// Number of results to return per page.
func (r ApiApiV2PortfoliosPerformanceMwrrListRequest) Limit(limit int32) ApiApiV2PortfoliosPerformanceMwrrListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosPerformanceMwrrListRequest) Offset(offset int32) ApiApiV2PortfoliosPerformanceMwrrListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortfoliosPerformanceMwrrListRequest) Execute() (PaginatedPortfolioPerformanceList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosPerformanceMwrrListExecute(r)
}

/*
ApiV2PortfoliosPerformanceMwrrList Method for ApiV2PortfoliosPerformanceMwrrList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosPerformanceMwrrListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosPerformanceMwrrList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosPerformanceMwrrListRequest {
	return ApiApiV2PortfoliosPerformanceMwrrListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedPortfolioPerformanceList
func (a *ApiApiService) ApiV2PortfoliosPerformanceMwrrListExecute(r ApiApiV2PortfoliosPerformanceMwrrListRequest) (PaginatedPortfolioPerformanceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPortfolioPerformanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosPerformanceMwrrList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/performance/mwrr/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.dateAfter != nil {
		localVarQueryParams.Add("date_after", parameterToString(*r.dateAfter, ""))
	}
	if r.dateBefore != nil {
		localVarQueryParams.Add("date_before", parameterToString(*r.dateBefore, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosPerformancePositionsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosPerformancePositionsListRequest) Limit(limit int32) ApiApiV2PortfoliosPerformancePositionsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosPerformancePositionsListRequest) Offset(offset int32) ApiApiV2PortfoliosPerformancePositionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortfoliosPerformancePositionsListRequest) Execute() (PaginatedPortfolioPerformancePositionsList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosPerformancePositionsListExecute(r)
}

/*
ApiV2PortfoliosPerformancePositionsList Method for ApiV2PortfoliosPerformancePositionsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosPerformancePositionsListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosPerformancePositionsList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosPerformancePositionsListRequest {
	return ApiApiV2PortfoliosPerformancePositionsListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedPortfolioPerformancePositionsList
func (a *ApiApiService) ApiV2PortfoliosPerformancePositionsListExecute(r ApiApiV2PortfoliosPerformancePositionsListRequest) (PaginatedPortfolioPerformancePositionsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPortfolioPerformancePositionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosPerformancePositionsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/performance/positions/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosPerformanceTwrrListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	dateAfter *string
	dateBefore *string
	limit *int32
	offset *int32
}

func (r ApiApiV2PortfoliosPerformanceTwrrListRequest) DateAfter(dateAfter string) ApiApiV2PortfoliosPerformanceTwrrListRequest {
	r.dateAfter = &dateAfter
	return r
}
func (r ApiApiV2PortfoliosPerformanceTwrrListRequest) DateBefore(dateBefore string) ApiApiV2PortfoliosPerformanceTwrrListRequest {
	r.dateBefore = &dateBefore
	return r
}
// Number of results to return per page.
func (r ApiApiV2PortfoliosPerformanceTwrrListRequest) Limit(limit int32) ApiApiV2PortfoliosPerformanceTwrrListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosPerformanceTwrrListRequest) Offset(offset int32) ApiApiV2PortfoliosPerformanceTwrrListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortfoliosPerformanceTwrrListRequest) Execute() (PaginatedPortfolioPerformanceList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosPerformanceTwrrListExecute(r)
}

/*
ApiV2PortfoliosPerformanceTwrrList Method for ApiV2PortfoliosPerformanceTwrrList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosPerformanceTwrrListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosPerformanceTwrrList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosPerformanceTwrrListRequest {
	return ApiApiV2PortfoliosPerformanceTwrrListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedPortfolioPerformanceList
func (a *ApiApiService) ApiV2PortfoliosPerformanceTwrrListExecute(r ApiApiV2PortfoliosPerformanceTwrrListRequest) (PaginatedPortfolioPerformanceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPortfolioPerformanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosPerformanceTwrrList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/performance/twrr/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.dateAfter != nil {
		localVarQueryParams.Add("date_after", parameterToString(*r.dateAfter, ""))
	}
	if r.dateBefore != nil {
		localVarQueryParams.Add("date_before", parameterToString(*r.dateBefore, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosPortfoliotypesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosPortfoliotypesListRequest) Limit(limit int32) ApiApiV2PortfoliosPortfoliotypesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosPortfoliotypesListRequest) Offset(offset int32) ApiApiV2PortfoliosPortfoliotypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortfoliosPortfoliotypesListRequest) Execute() (PaginatedPortfolioTypeList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosPortfoliotypesListExecute(r)
}

/*
ApiV2PortfoliosPortfoliotypesList Method for ApiV2PortfoliosPortfoliotypesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2PortfoliosPortfoliotypesListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosPortfoliotypesList(ctx _context.Context) ApiApiV2PortfoliosPortfoliotypesListRequest {
	return ApiApiV2PortfoliosPortfoliotypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPortfolioTypeList
func (a *ApiApiService) ApiV2PortfoliosPortfoliotypesListExecute(r ApiApiV2PortfoliosPortfoliotypesListRequest) (PaginatedPortfolioTypeList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPortfolioTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosPortfoliotypesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/portfoliotypes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	code string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest) Limit(limit int32) ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest) Offset(offset int32) ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest) Execute() (PaginatedBasePortfolioTypeRestrictionsList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosPortfoliotypesRestrictionsListExecute(r)
}

/*
ApiV2PortfoliosPortfoliotypesRestrictionsList Method for ApiV2PortfoliosPortfoliotypesRestrictionsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code
 @return ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosPortfoliotypesRestrictionsList(ctx _context.Context, code string) ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest {
	return ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return PaginatedBasePortfolioTypeRestrictionsList
func (a *ApiApiService) ApiV2PortfoliosPortfoliotypesRestrictionsListExecute(r ApiApiV2PortfoliosPortfoliotypesRestrictionsListRequest) (PaginatedBasePortfolioTypeRestrictionsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedBasePortfolioTypeRestrictionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosPortfoliotypesRestrictionsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/portfoliotypes/{code}/restrictions/"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosRebalancesListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosRebalancesListRequest) Limit(limit int32) ApiApiV2PortfoliosRebalancesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosRebalancesListRequest) Offset(offset int32) ApiApiV2PortfoliosRebalancesListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2PortfoliosRebalancesListRequest) Execute() (PaginatedRebalanceList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosRebalancesListExecute(r)
}

/*
ApiV2PortfoliosRebalancesList Method for ApiV2PortfoliosRebalancesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosRebalancesListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosRebalancesList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosRebalancesListRequest {
	return ApiApiV2PortfoliosRebalancesListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedRebalanceList
func (a *ApiApiService) ApiV2PortfoliosRebalancesListExecute(r ApiApiV2PortfoliosRebalancesListRequest) (PaginatedRebalanceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedRebalanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosRebalancesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/rebalances/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosRebalancesRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosRebalancesRetrieveRequest) Execute() (Rebalance, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosRebalancesRetrieveExecute(r)
}

/*
ApiV2PortfoliosRebalancesRetrieve Method for ApiV2PortfoliosRebalancesRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosRebalancesRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosRebalancesRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosRebalancesRetrieveRequest {
	return ApiApiV2PortfoliosRebalancesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Rebalance
func (a *ApiApiService) ApiV2PortfoliosRebalancesRetrieveExecute(r ApiApiV2PortfoliosRebalancesRetrieveRequest) (Rebalance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Rebalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosRebalancesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/rebalances/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosRestrictionsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosRestrictionsRetrieveRequest) Execute() (PortfolioTypeRestrictions, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosRestrictionsRetrieveExecute(r)
}

/*
ApiV2PortfoliosRestrictionsRetrieve Method for ApiV2PortfoliosRestrictionsRetrieve

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosRestrictionsRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosRestrictionsRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosRestrictionsRetrieveRequest {
	return ApiApiV2PortfoliosRestrictionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return PortfolioTypeRestrictions
func (a *ApiApiService) ApiV2PortfoliosRestrictionsRetrieveExecute(r ApiApiV2PortfoliosRestrictionsRetrieveRequest) (PortfolioTypeRestrictions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortfolioTypeRestrictions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosRestrictionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{uuid}/restrictions/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosRetrieveRequest) Execute() (PortfolioDetail, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosRetrieveExecute(r)
}

/*
ApiV2PortfoliosRetrieve Method for ApiV2PortfoliosRetrieve

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosRetrieveRequest {
	return ApiApiV2PortfoliosRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return PortfolioDetail
func (a *ApiApiService) ApiV2PortfoliosRetrieveExecute(r ApiApiV2PortfoliosRetrieveRequest) (PortfolioDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortfolioDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosUpdateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
	portfolioUpdate *PortfolioUpdate
}

func (r ApiApiV2PortfoliosUpdateRequest) PortfolioUpdate(portfolioUpdate PortfolioUpdate) ApiApiV2PortfoliosUpdateRequest {
	r.portfolioUpdate = &portfolioUpdate
	return r
}

func (r ApiApiV2PortfoliosUpdateRequest) Execute() (PortfolioUpdate, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosUpdateExecute(r)
}

/*
ApiV2PortfoliosUpdate Method for ApiV2PortfoliosUpdate

Allow aggregate/group fields of the ModelView model or its related entities.
   Query params should use dot notation.

Requires:
    ListModelMixin (ListAPIView, ListCreateApiView)

Args:
    * aggregatable_fields (dict): optional.
        Keys: fields that allow aggregation (including related entities with "__" notation).
        Values: django qs functions or aggregate_fns
        Example:
            aggregatable_fields = {
                'allocations__balance': [Sum, Avg],
            }

    * groupable_fields (list): optional. fields that allow grouping (including related entities with "__" notation).
        Example:
            groupable_fields = ['portfolio__portfolio_type']

Query Param Examples:
    >>> ?group_by=portfolio.portfolio_type
    >>> ?aggregate[Sum]=portfolio.allocations.balance
    >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosUpdateRequest
*/
func (a *ApiApiService) ApiV2PortfoliosUpdate(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosUpdateRequest {
	return ApiApiV2PortfoliosUpdateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return PortfolioUpdate
func (a *ApiApiService) ApiV2PortfoliosUpdateExecute(r ApiApiV2PortfoliosUpdateRequest) (PortfolioUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortfolioUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.portfolioUpdate == nil {
		return localVarReturnValue, nil, reportError("portfolioUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.portfolioUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosWithdrawalsCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	investorWithdrawalCreate *InvestorWithdrawalCreate
}

func (r ApiApiV2PortfoliosWithdrawalsCreateRequest) InvestorWithdrawalCreate(investorWithdrawalCreate InvestorWithdrawalCreate) ApiApiV2PortfoliosWithdrawalsCreateRequest {
	r.investorWithdrawalCreate = &investorWithdrawalCreate
	return r
}

func (r ApiApiV2PortfoliosWithdrawalsCreateRequest) Execute() (InvestorWithdrawalCreate, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosWithdrawalsCreateExecute(r)
}

/*
ApiV2PortfoliosWithdrawalsCreate Method for ApiV2PortfoliosWithdrawalsCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosWithdrawalsCreateRequest
*/
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsCreate(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosWithdrawalsCreateRequest {
	return ApiApiV2PortfoliosWithdrawalsCreateRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return InvestorWithdrawalCreate
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsCreateExecute(r ApiApiV2PortfoliosWithdrawalsCreateRequest) (InvestorWithdrawalCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InvestorWithdrawalCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosWithdrawalsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/withdrawals/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.investorWithdrawalCreate == nil {
		return localVarReturnValue, nil, reportError("investorWithdrawalCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.investorWithdrawalCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosWithdrawalsDestroyRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosWithdrawalsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosWithdrawalsDestroyExecute(r)
}

/*
ApiV2PortfoliosWithdrawalsDestroy Method for ApiV2PortfoliosWithdrawalsDestroy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosWithdrawalsDestroyRequest
*/
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsDestroy(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosWithdrawalsDestroyRequest {
	return ApiApiV2PortfoliosWithdrawalsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsDestroyExecute(r ApiApiV2PortfoliosWithdrawalsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosWithdrawalsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/withdrawals/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosWithdrawalsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	limit *int32
	offset *int32
	status *[]string
}

// Number of results to return per page.
func (r ApiApiV2PortfoliosWithdrawalsListRequest) Limit(limit int32) ApiApiV2PortfoliosWithdrawalsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2PortfoliosWithdrawalsListRequest) Offset(offset int32) ApiApiV2PortfoliosWithdrawalsListRequest {
	r.offset = &offset
	return r
}
func (r ApiApiV2PortfoliosWithdrawalsListRequest) Status(status []string) ApiApiV2PortfoliosWithdrawalsListRequest {
	r.status = &status
	return r
}

func (r ApiApiV2PortfoliosWithdrawalsListRequest) Execute() (PaginatedInvestorWithdrawalListList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosWithdrawalsListExecute(r)
}

/*
ApiV2PortfoliosWithdrawalsList Method for ApiV2PortfoliosWithdrawalsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @return ApiApiV2PortfoliosWithdrawalsListRequest
*/
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsList(ctx _context.Context, portfolioUuid string) ApiApiV2PortfoliosWithdrawalsListRequest {
	return ApiApiV2PortfoliosWithdrawalsListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
	}
}

// Execute executes the request
//  @return PaginatedInvestorWithdrawalListList
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsListExecute(r ApiApiV2PortfoliosWithdrawalsListRequest) (PaginatedInvestorWithdrawalListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedInvestorWithdrawalListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosWithdrawalsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/withdrawals/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2PortfoliosWithdrawalsRetrieveRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	portfolioUuid string
	uuid string
}


func (r ApiApiV2PortfoliosWithdrawalsRetrieveRequest) Execute() (WithdrawalDetail, *_nethttp.Response, error) {
	return r.ApiService.ApiV2PortfoliosWithdrawalsRetrieveExecute(r)
}

/*
ApiV2PortfoliosWithdrawalsRetrieve Method for ApiV2PortfoliosWithdrawalsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioUuid
 @param uuid
 @return ApiApiV2PortfoliosWithdrawalsRetrieveRequest
*/
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsRetrieve(ctx _context.Context, portfolioUuid string, uuid string) ApiApiV2PortfoliosWithdrawalsRetrieveRequest {
	return ApiApiV2PortfoliosWithdrawalsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		portfolioUuid: portfolioUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return WithdrawalDetail
func (a *ApiApiService) ApiV2PortfoliosWithdrawalsRetrieveExecute(r ApiApiV2PortfoliosWithdrawalsRetrieveRequest) (WithdrawalDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WithdrawalDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2PortfoliosWithdrawalsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/portfolios/{portfolio_uuid}/withdrawals/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolio_uuid"+"}", _neturl.PathEscape(parameterToString(r.portfolioUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2RiskQuestionsListRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiApiV2RiskQuestionsListRequest) Limit(limit int32) ApiApiV2RiskQuestionsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiApiV2RiskQuestionsListRequest) Offset(offset int32) ApiApiV2RiskQuestionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV2RiskQuestionsListRequest) Execute() (PaginatedQuestionList, *_nethttp.Response, error) {
	return r.ApiService.ApiV2RiskQuestionsListExecute(r)
}

/*
ApiV2RiskQuestionsList Method for ApiV2RiskQuestionsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2RiskQuestionsListRequest
*/
func (a *ApiApiService) ApiV2RiskQuestionsList(ctx _context.Context) ApiApiV2RiskQuestionsListRequest {
	return ApiApiV2RiskQuestionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedQuestionList
func (a *ApiApiService) ApiV2RiskQuestionsListExecute(r ApiApiV2RiskQuestionsListRequest) (PaginatedQuestionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedQuestionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2RiskQuestionsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/risk/questions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2VerificationsVerifierWebhookCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	action string
	verifier string
}


func (r ApiApiV2VerificationsVerifierWebhookCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV2VerificationsVerifierWebhookCreateExecute(r)
}

/*
ApiV2VerificationsVerifierWebhookCreate Method for ApiV2VerificationsVerifierWebhookCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param action
 @param verifier
 @return ApiApiV2VerificationsVerifierWebhookCreateRequest
*/
func (a *ApiApiService) ApiV2VerificationsVerifierWebhookCreate(ctx _context.Context, action string, verifier string) ApiApiV2VerificationsVerifierWebhookCreateRequest {
	return ApiApiV2VerificationsVerifierWebhookCreateRequest{
		ApiService: a,
		ctx: ctx,
		action: action,
		verifier: verifier,
	}
}

// Execute executes the request
func (a *ApiApiService) ApiV2VerificationsVerifierWebhookCreateExecute(r ApiApiV2VerificationsVerifierWebhookCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2VerificationsVerifierWebhookCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/verifications/verifier_webhook/{verifier}/{action}/"
	localVarPath = strings.Replace(localVarPath, "{"+"action"+"}", _neturl.PathEscape(parameterToString(r.action, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verifier"+"}", _neturl.PathEscape(parameterToString(r.verifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2WebsocketAuthenticationTicketCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	websocketAuthentication *WebsocketAuthentication
}

func (r ApiApiV2WebsocketAuthenticationTicketCreateRequest) WebsocketAuthentication(websocketAuthentication WebsocketAuthentication) ApiApiV2WebsocketAuthenticationTicketCreateRequest {
	r.websocketAuthentication = &websocketAuthentication
	return r
}

func (r ApiApiV2WebsocketAuthenticationTicketCreateRequest) Execute() (AuthenticationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiV2WebsocketAuthenticationTicketCreateExecute(r)
}

/*
ApiV2WebsocketAuthenticationTicketCreate Method for ApiV2WebsocketAuthenticationTicketCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2WebsocketAuthenticationTicketCreateRequest
*/
func (a *ApiApiService) ApiV2WebsocketAuthenticationTicketCreate(ctx _context.Context) ApiApiV2WebsocketAuthenticationTicketCreateRequest {
	return ApiApiV2WebsocketAuthenticationTicketCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthenticationResponse
func (a *ApiApiService) ApiV2WebsocketAuthenticationTicketCreateExecute(r ApiApiV2WebsocketAuthenticationTicketCreateRequest) (AuthenticationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AuthenticationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2WebsocketAuthenticationTicketCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/websocket/authentication/ticket/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.websocketAuthentication == nil {
		return localVarReturnValue, nil, reportError("websocketAuthentication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.websocketAuthentication
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2WebsocketAuthorizeAssetCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	websocketAuthentication *WebsocketAuthentication
}

func (r ApiApiV2WebsocketAuthorizeAssetCreateRequest) WebsocketAuthentication(websocketAuthentication WebsocketAuthentication) ApiApiV2WebsocketAuthorizeAssetCreateRequest {
	r.websocketAuthentication = &websocketAuthentication
	return r
}

func (r ApiApiV2WebsocketAuthorizeAssetCreateRequest) Execute() (Response, *_nethttp.Response, error) {
	return r.ApiService.ApiV2WebsocketAuthorizeAssetCreateExecute(r)
}

/*
ApiV2WebsocketAuthorizeAssetCreate Method for ApiV2WebsocketAuthorizeAssetCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2WebsocketAuthorizeAssetCreateRequest
*/
func (a *ApiApiService) ApiV2WebsocketAuthorizeAssetCreate(ctx _context.Context) ApiApiV2WebsocketAuthorizeAssetCreateRequest {
	return ApiApiV2WebsocketAuthorizeAssetCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *ApiApiService) ApiV2WebsocketAuthorizeAssetCreateExecute(r ApiApiV2WebsocketAuthorizeAssetCreateRequest) (Response, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2WebsocketAuthorizeAssetCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/websocket/authorize/asset/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.websocketAuthentication == nil {
		return localVarReturnValue, nil, reportError("websocketAuthentication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.websocketAuthentication
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2WebsocketAuthorizeCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	websocketAuthentication *WebsocketAuthentication
}

func (r ApiApiV2WebsocketAuthorizeCreateRequest) WebsocketAuthentication(websocketAuthentication WebsocketAuthentication) ApiApiV2WebsocketAuthorizeCreateRequest {
	r.websocketAuthentication = &websocketAuthentication
	return r
}

func (r ApiApiV2WebsocketAuthorizeCreateRequest) Execute() (Response, *_nethttp.Response, error) {
	return r.ApiService.ApiV2WebsocketAuthorizeCreateExecute(r)
}

/*
ApiV2WebsocketAuthorizeCreate Method for ApiV2WebsocketAuthorizeCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2WebsocketAuthorizeCreateRequest
*/
func (a *ApiApiService) ApiV2WebsocketAuthorizeCreate(ctx _context.Context) ApiApiV2WebsocketAuthorizeCreateRequest {
	return ApiApiV2WebsocketAuthorizeCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *ApiApiService) ApiV2WebsocketAuthorizeCreateExecute(r ApiApiV2WebsocketAuthorizeCreateRequest) (Response, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2WebsocketAuthorizeCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/websocket/authorize/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.websocketAuthentication == nil {
		return localVarReturnValue, nil, reportError("websocketAuthentication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.websocketAuthentication
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2WebsocketAuthorizePortfolioCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	websocketAuthentication *WebsocketAuthentication
}

func (r ApiApiV2WebsocketAuthorizePortfolioCreateRequest) WebsocketAuthentication(websocketAuthentication WebsocketAuthentication) ApiApiV2WebsocketAuthorizePortfolioCreateRequest {
	r.websocketAuthentication = &websocketAuthentication
	return r
}

func (r ApiApiV2WebsocketAuthorizePortfolioCreateRequest) Execute() (Response, *_nethttp.Response, error) {
	return r.ApiService.ApiV2WebsocketAuthorizePortfolioCreateExecute(r)
}

/*
ApiV2WebsocketAuthorizePortfolioCreate Method for ApiV2WebsocketAuthorizePortfolioCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2WebsocketAuthorizePortfolioCreateRequest
*/
func (a *ApiApiService) ApiV2WebsocketAuthorizePortfolioCreate(ctx _context.Context) ApiApiV2WebsocketAuthorizePortfolioCreateRequest {
	return ApiApiV2WebsocketAuthorizePortfolioCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *ApiApiService) ApiV2WebsocketAuthorizePortfolioCreateExecute(r ApiApiV2WebsocketAuthorizePortfolioCreateRequest) (Response, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2WebsocketAuthorizePortfolioCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/websocket/authorize/portfolio/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.websocketAuthentication == nil {
		return localVarReturnValue, nil, reportError("websocketAuthentication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.websocketAuthentication
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2WebsocketOnSubscribeCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	subscribe *Subscribe
}

func (r ApiApiV2WebsocketOnSubscribeCreateRequest) Subscribe(subscribe Subscribe) ApiApiV2WebsocketOnSubscribeCreateRequest {
	r.subscribe = &subscribe
	return r
}

func (r ApiApiV2WebsocketOnSubscribeCreateRequest) Execute() (Subscribe, *_nethttp.Response, error) {
	return r.ApiService.ApiV2WebsocketOnSubscribeCreateExecute(r)
}

/*
ApiV2WebsocketOnSubscribeCreate Method for ApiV2WebsocketOnSubscribeCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2WebsocketOnSubscribeCreateRequest
*/
func (a *ApiApiService) ApiV2WebsocketOnSubscribeCreate(ctx _context.Context) ApiApiV2WebsocketOnSubscribeCreateRequest {
	return ApiApiV2WebsocketOnSubscribeCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Subscribe
func (a *ApiApiService) ApiV2WebsocketOnSubscribeCreateExecute(r ApiApiV2WebsocketOnSubscribeCreateRequest) (Subscribe, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscribe
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2WebsocketOnSubscribeCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/websocket/on_subscribe/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscribe == nil {
		return localVarReturnValue, nil, reportError("subscribe is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscribe
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2WebsocketOnUnsubscribeCreateRequest struct {
	ctx _context.Context
	ApiService *ApiApiService
	unsubscribe *Unsubscribe
}

func (r ApiApiV2WebsocketOnUnsubscribeCreateRequest) Unsubscribe(unsubscribe Unsubscribe) ApiApiV2WebsocketOnUnsubscribeCreateRequest {
	r.unsubscribe = &unsubscribe
	return r
}

func (r ApiApiV2WebsocketOnUnsubscribeCreateRequest) Execute() (Unsubscribe, *_nethttp.Response, error) {
	return r.ApiService.ApiV2WebsocketOnUnsubscribeCreateExecute(r)
}

/*
ApiV2WebsocketOnUnsubscribeCreate Method for ApiV2WebsocketOnUnsubscribeCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2WebsocketOnUnsubscribeCreateRequest
*/
func (a *ApiApiService) ApiV2WebsocketOnUnsubscribeCreate(ctx _context.Context) ApiApiV2WebsocketOnUnsubscribeCreateRequest {
	return ApiApiV2WebsocketOnUnsubscribeCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Unsubscribe
func (a *ApiApiService) ApiV2WebsocketOnUnsubscribeCreateExecute(r ApiApiV2WebsocketOnUnsubscribeCreateRequest) (Unsubscribe, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Unsubscribe
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApiApiService.ApiV2WebsocketOnUnsubscribeCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/websocket/on_unsubscribe/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unsubscribe == nil {
		return localVarReturnValue, nil, reportError("unsubscribe is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unsubscribe
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
