/*
Nucoro API

No description

API version: 4.175.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// ClientApiService ClientApi service
type ClientApiService service

type ApiClientAddressCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	addressCreate *AddressCreate
}

func (r ApiClientAddressCreateRequest) AddressCreate(addressCreate AddressCreate) ApiClientAddressCreateRequest {
	r.addressCreate = &addressCreate
	return r
}

func (r ApiClientAddressCreateRequest) Execute() (AddressCreate, *_nethttp.Response, error) {
	return r.ApiService.ClientAddressCreateExecute(r)
}

/*
ClientAddressCreate Method for ClientAddressCreate

Create an address for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientAddressCreateRequest
*/
func (a *ClientApiService) ClientAddressCreate(ctx _context.Context, clientUuid string) ApiClientAddressCreateRequest {
	return ApiClientAddressCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return AddressCreate
func (a *ClientApiService) ClientAddressCreateExecute(r ApiClientAddressCreateRequest) (AddressCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AddressCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientAddressCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/addresses/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.addressCreate == nil {
		return localVarReturnValue, nil, reportError("addressCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addressCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientAddressDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientAddressDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientAddressDeleteExecute(r)
}

/*
ClientAddressDelete Method for ClientAddressDelete

Delete a client address

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientAddressDeleteRequest
*/
func (a *ClientApiService) ClientAddressDelete(ctx _context.Context, clientUuid string, uuid string) ApiClientAddressDeleteRequest {
	return ApiClientAddressDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientAddressDeleteExecute(r ApiClientAddressDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientAddressDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/addresses/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientAddressPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	patchedAddressUpdate *PatchedAddressUpdate
}

func (r ApiClientAddressPartialUpdateRequest) PatchedAddressUpdate(patchedAddressUpdate PatchedAddressUpdate) ApiClientAddressPartialUpdateRequest {
	r.patchedAddressUpdate = &patchedAddressUpdate
	return r
}

func (r ApiClientAddressPartialUpdateRequest) Execute() (AddressUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientAddressPartialUpdateExecute(r)
}

/*
ClientAddressPartialUpdate Method for ClientAddressPartialUpdate

Partial Update a client address

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientAddressPartialUpdateRequest
*/
func (a *ClientApiService) ClientAddressPartialUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientAddressPartialUpdateRequest {
	return ApiClientAddressPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return AddressUpdate
func (a *ClientApiService) ClientAddressPartialUpdateExecute(r ApiClientAddressPartialUpdateRequest) (AddressUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AddressUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientAddressPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/addresses/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAddressUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientAddressRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientAddressRetrieveRequest) Execute() (AddressList, *_nethttp.Response, error) {
	return r.ApiService.ClientAddressRetrieveExecute(r)
}

/*
ClientAddressRetrieve Method for ClientAddressRetrieve

Retrieve a client address

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientAddressRetrieveRequest
*/
func (a *ClientApiService) ClientAddressRetrieve(ctx _context.Context, clientUuid string, uuid string) ApiClientAddressRetrieveRequest {
	return ApiClientAddressRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return AddressList
func (a *ClientApiService) ClientAddressRetrieveExecute(r ApiClientAddressRetrieveRequest) (AddressList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AddressList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientAddressRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/addresses/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientAddressUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	addressUpdate *AddressUpdate
}

func (r ApiClientAddressUpdateRequest) AddressUpdate(addressUpdate AddressUpdate) ApiClientAddressUpdateRequest {
	r.addressUpdate = &addressUpdate
	return r
}

func (r ApiClientAddressUpdateRequest) Execute() (AddressUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientAddressUpdateExecute(r)
}

/*
ClientAddressUpdate Method for ClientAddressUpdate

Update a client address

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientAddressUpdateRequest
*/
func (a *ClientApiService) ClientAddressUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientAddressUpdateRequest {
	return ApiClientAddressUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return AddressUpdate
func (a *ClientApiService) ClientAddressUpdateExecute(r ApiClientAddressUpdateRequest) (AddressUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AddressUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientAddressUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/addresses/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.addressUpdate == nil {
		return localVarReturnValue, nil, reportError("addressUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addressUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientAddressesListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientAddressesListRequest) Limit(limit int32) ApiClientAddressesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientAddressesListRequest) Offset(offset int32) ApiClientAddressesListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientAddressesListRequest) Execute() (PaginatedAddressListList, *_nethttp.Response, error) {
	return r.ApiService.ClientAddressesListExecute(r)
}

/*
ClientAddressesList Method for ClientAddressesList

List address for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientAddressesListRequest
*/
func (a *ClientApiService) ClientAddressesList(ctx _context.Context, clientUuid string) ApiClientAddressesListRequest {
	return ApiClientAddressesListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return PaginatedAddressListList
func (a *ClientApiService) ClientAddressesListExecute(r ApiClientAddressesListRequest) (PaginatedAddressListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAddressListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientAddressesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/addresses/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientBankAccountCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	bankAccountCreateUpdate *BankAccountCreateUpdate
}

func (r ApiClientBankAccountCreateRequest) BankAccountCreateUpdate(bankAccountCreateUpdate BankAccountCreateUpdate) ApiClientBankAccountCreateRequest {
	r.bankAccountCreateUpdate = &bankAccountCreateUpdate
	return r
}

func (r ApiClientBankAccountCreateRequest) Execute() (BankAccountCreateUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientBankAccountCreateExecute(r)
}

/*
ClientBankAccountCreate Method for ClientBankAccountCreate

Create a bank account for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientBankAccountCreateRequest
*/
func (a *ClientApiService) ClientBankAccountCreate(ctx _context.Context, clientUuid string) ApiClientBankAccountCreateRequest {
	return ApiClientBankAccountCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return BankAccountCreateUpdate
func (a *ClientApiService) ClientBankAccountCreateExecute(r ApiClientBankAccountCreateRequest) (BankAccountCreateUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BankAccountCreateUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientBankAccountCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/bank-accounts/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bankAccountCreateUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientBankAccountDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientBankAccountDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientBankAccountDeleteExecute(r)
}

/*
ClientBankAccountDelete Method for ClientBankAccountDelete

Delete a client bank account

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientBankAccountDeleteRequest
*/
func (a *ClientApiService) ClientBankAccountDelete(ctx _context.Context, clientUuid string, uuid string) ApiClientBankAccountDeleteRequest {
	return ApiClientBankAccountDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientBankAccountDeleteExecute(r ApiClientBankAccountDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientBankAccountDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientBankAccountPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	patchedBankAccountCreateUpdate *PatchedBankAccountCreateUpdate
}

func (r ApiClientBankAccountPartialUpdateRequest) PatchedBankAccountCreateUpdate(patchedBankAccountCreateUpdate PatchedBankAccountCreateUpdate) ApiClientBankAccountPartialUpdateRequest {
	r.patchedBankAccountCreateUpdate = &patchedBankAccountCreateUpdate
	return r
}

func (r ApiClientBankAccountPartialUpdateRequest) Execute() (BankAccountCreateUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientBankAccountPartialUpdateExecute(r)
}

/*
ClientBankAccountPartialUpdate Method for ClientBankAccountPartialUpdate

Partial Update a client bank account

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientBankAccountPartialUpdateRequest
*/
func (a *ClientApiService) ClientBankAccountPartialUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientBankAccountPartialUpdateRequest {
	return ApiClientBankAccountPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return BankAccountCreateUpdate
func (a *ClientApiService) ClientBankAccountPartialUpdateExecute(r ApiClientBankAccountPartialUpdateRequest) (BankAccountCreateUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BankAccountCreateUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientBankAccountPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBankAccountCreateUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientBankAccountRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientBankAccountRetrieveRequest) Execute() (BankAccountList, *_nethttp.Response, error) {
	return r.ApiService.ClientBankAccountRetrieveExecute(r)
}

/*
ClientBankAccountRetrieve Method for ClientBankAccountRetrieve

Retrieve a client bank account

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientBankAccountRetrieveRequest
*/
func (a *ClientApiService) ClientBankAccountRetrieve(ctx _context.Context, clientUuid string, uuid string) ApiClientBankAccountRetrieveRequest {
	return ApiClientBankAccountRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return BankAccountList
func (a *ClientApiService) ClientBankAccountRetrieveExecute(r ApiClientBankAccountRetrieveRequest) (BankAccountList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BankAccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientBankAccountRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientBankAccountUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	bankAccountCreateUpdate *BankAccountCreateUpdate
}

func (r ApiClientBankAccountUpdateRequest) BankAccountCreateUpdate(bankAccountCreateUpdate BankAccountCreateUpdate) ApiClientBankAccountUpdateRequest {
	r.bankAccountCreateUpdate = &bankAccountCreateUpdate
	return r
}

func (r ApiClientBankAccountUpdateRequest) Execute() (BankAccountCreateUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientBankAccountUpdateExecute(r)
}

/*
ClientBankAccountUpdate Method for ClientBankAccountUpdate

Update a client bank account

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientBankAccountUpdateRequest
*/
func (a *ClientApiService) ClientBankAccountUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientBankAccountUpdateRequest {
	return ApiClientBankAccountUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return BankAccountCreateUpdate
func (a *ClientApiService) ClientBankAccountUpdateExecute(r ApiClientBankAccountUpdateRequest) (BankAccountCreateUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BankAccountCreateUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientBankAccountUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bankAccountCreateUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientBankAccountsListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientBankAccountsListRequest) Limit(limit int32) ApiClientBankAccountsListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientBankAccountsListRequest) Offset(offset int32) ApiClientBankAccountsListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientBankAccountsListRequest) Execute() (PaginatedBankAccountListList, *_nethttp.Response, error) {
	return r.ApiService.ClientBankAccountsListExecute(r)
}

/*
ClientBankAccountsList Method for ClientBankAccountsList

List Bank Account for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientBankAccountsListRequest
*/
func (a *ClientApiService) ClientBankAccountsList(ctx _context.Context, clientUuid string) ApiClientBankAccountsListRequest {
	return ApiClientBankAccountsListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return PaginatedBankAccountListList
func (a *ClientApiService) ClientBankAccountsListExecute(r ApiClientBankAccountsListRequest) (PaginatedBankAccountListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedBankAccountListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientBankAccountsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/bank-accounts/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientCompleteOnboardingRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	clientDetail *ClientDetail
}

func (r ApiClientCompleteOnboardingRequest) ClientDetail(clientDetail ClientDetail) ApiClientCompleteOnboardingRequest {
	r.clientDetail = &clientDetail
	return r
}

func (r ApiClientCompleteOnboardingRequest) Execute() (ClientDetail, *_nethttp.Response, error) {
	return r.ApiService.ClientCompleteOnboardingExecute(r)
}

/*
ClientCompleteOnboarding Method for ClientCompleteOnboarding

Complete onboarding for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientCompleteOnboardingRequest
*/
func (a *ClientApiService) ClientCompleteOnboarding(ctx _context.Context, clientUuid string, uuid string) ApiClientCompleteOnboardingRequest {
	return ApiClientCompleteOnboardingRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ClientDetail
func (a *ClientApiService) ClientCompleteOnboardingExecute(r ApiClientCompleteOnboardingRequest) (ClientDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClientDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientCompleteOnboarding")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{uuid}/onboarding/complete/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clientDetail == nil {
		return localVarReturnValue, nil, reportError("clientDetail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientDetail
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientCreate *ClientCreate
}

func (r ApiClientCreateRequest) ClientCreate(clientCreate ClientCreate) ApiClientCreateRequest {
	r.clientCreate = &clientCreate
	return r
}

func (r ApiClientCreateRequest) Execute() (ClientCreate, *_nethttp.Response, error) {
	return r.ApiService.ClientCreateExecute(r)
}

/*
ClientCreate Method for ClientCreate

Create a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClientCreateRequest
*/
func (a *ClientApiService) ClientCreate(ctx _context.Context) ApiClientCreateRequest {
	return ApiClientCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClientCreate
func (a *ClientApiService) ClientCreateExecute(r ApiClientCreateRequest) (ClientCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClientCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clientCreate == nil {
		return localVarReturnValue, nil, reportError("clientCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientDocumentCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid *string
	name *string
	docType *DocTypeEnum
	path *string
	description *string
}

func (r ApiClientDocumentCreateRequest) Uuid(uuid string) ApiClientDocumentCreateRequest {
	r.uuid = &uuid
	return r
}
func (r ApiClientDocumentCreateRequest) Name(name string) ApiClientDocumentCreateRequest {
	r.name = &name
	return r
}
func (r ApiClientDocumentCreateRequest) DocType(docType DocTypeEnum) ApiClientDocumentCreateRequest {
	r.docType = &docType
	return r
}
func (r ApiClientDocumentCreateRequest) Path(path string) ApiClientDocumentCreateRequest {
	r.path = &path
	return r
}
func (r ApiClientDocumentCreateRequest) Description(description string) ApiClientDocumentCreateRequest {
	r.description = &description
	return r
}

func (r ApiClientDocumentCreateRequest) Execute() (Document, *_nethttp.Response, error) {
	return r.ApiService.ClientDocumentCreateExecute(r)
}

/*
ClientDocumentCreate Method for ClientDocumentCreate

Create a document for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientDocumentCreateRequest
*/
func (a *ClientApiService) ClientDocumentCreate(ctx _context.Context, clientUuid string) ApiClientDocumentCreateRequest {
	return ApiClientDocumentCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return Document
func (a *ClientApiService) ClientDocumentCreateExecute(r ApiClientDocumentCreateRequest) (Document, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Document
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientDocumentCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/documents/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.docType == nil {
		return localVarReturnValue, nil, reportError("docType is required and must be specified")
	}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(*r.uuid, ""))
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	localVarFormParams.Add("doc_type", parameterToString(*r.docType, ""))
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	localVarFormParams.Add("path", parameterToString(*r.path, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientDocumentDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientDocumentDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientDocumentDeleteExecute(r)
}

/*
ClientDocumentDelete Method for ClientDocumentDelete

Delete a client document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientDocumentDeleteRequest
*/
func (a *ClientApiService) ClientDocumentDelete(ctx _context.Context, clientUuid string, uuid string) ApiClientDocumentDeleteRequest {
	return ApiClientDocumentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientDocumentDeleteExecute(r ApiClientDocumentDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientDocumentDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientDocumentListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	client *int32
	description *string
	docType *[]string
	extraData *map[string]interface{}
	limit *int32
	name *string
	offset *int32
}

func (r ApiClientDocumentListRequest) Client(client int32) ApiClientDocumentListRequest {
	r.client = &client
	return r
}
func (r ApiClientDocumentListRequest) Description(description string) ApiClientDocumentListRequest {
	r.description = &description
	return r
}
func (r ApiClientDocumentListRequest) DocType(docType []string) ApiClientDocumentListRequest {
	r.docType = &docType
	return r
}
// Additional document attributes for the specific portal
func (r ApiClientDocumentListRequest) ExtraData(extraData map[string]interface{}) ApiClientDocumentListRequest {
	r.extraData = &extraData
	return r
}
// Number of results to return per page.
func (r ApiClientDocumentListRequest) Limit(limit int32) ApiClientDocumentListRequest {
	r.limit = &limit
	return r
}
func (r ApiClientDocumentListRequest) Name(name string) ApiClientDocumentListRequest {
	r.name = &name
	return r
}
// The initial index from which to return the results.
func (r ApiClientDocumentListRequest) Offset(offset int32) ApiClientDocumentListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientDocumentListRequest) Execute() (PaginatedDocumentList, *_nethttp.Response, error) {
	return r.ApiService.ClientDocumentListExecute(r)
}

/*
ClientDocumentList Method for ClientDocumentList

List Document for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientDocumentListRequest
*/
func (a *ClientApiService) ClientDocumentList(ctx _context.Context, clientUuid string) ApiClientDocumentListRequest {
	return ApiClientDocumentListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return PaginatedDocumentList
func (a *ClientApiService) ClientDocumentListExecute(r ApiClientDocumentListRequest) (PaginatedDocumentList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedDocumentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientDocumentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/documents/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.client != nil {
		localVarQueryParams.Add("client", parameterToString(*r.client, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.docType != nil {
		t := *r.docType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("doc_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("doc_type", parameterToString(t, "multi"))
		}
	}
	if r.extraData != nil {
		localVarQueryParams.Add("extra_data", parameterToString(*r.extraData, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientDocumentRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientDocumentRetrieveRequest) Execute() (Document, *_nethttp.Response, error) {
	return r.ApiService.ClientDocumentRetrieveExecute(r)
}

/*
ClientDocumentRetrieve Method for ClientDocumentRetrieve

Retrieve a client document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientDocumentRetrieveRequest
*/
func (a *ClientApiService) ClientDocumentRetrieve(ctx _context.Context, clientUuid string, uuid string) ApiClientDocumentRetrieveRequest {
	return ApiClientDocumentRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Document
func (a *ClientApiService) ClientDocumentRetrieveExecute(r ApiClientDocumentRetrieveRequest) (Document, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Document
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientDocumentRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	externalCustodianId *string
	extraData *map[string]interface{}
	limit *int32
	offset *int32
	ordering *[]string
	search *string
	status *string
}

func (r ApiClientListRequest) ExternalCustodianId(externalCustodianId string) ApiClientListRequest {
	r.externalCustodianId = &externalCustodianId
	return r
}
// Additional client attributes for the specific portal
func (r ApiClientListRequest) ExtraData(extraData map[string]interface{}) ApiClientListRequest {
	r.extraData = &extraData
	return r
}
// Number of results to return per page.
func (r ApiClientListRequest) Limit(limit int32) ApiClientListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientListRequest) Offset(offset int32) ApiClientListRequest {
	r.offset = &offset
	return r
}
// Ordering
func (r ApiClientListRequest) Ordering(ordering []string) ApiClientListRequest {
	r.ordering = &ordering
	return r
}
// A search term.
func (r ApiClientListRequest) Search(search string) ApiClientListRequest {
	r.search = &search
	return r
}
func (r ApiClientListRequest) Status(status string) ApiClientListRequest {
	r.status = &status
	return r
}

func (r ApiClientListRequest) Execute() (PaginatedClientDetailList, *_nethttp.Response, error) {
	return r.ApiService.ClientListExecute(r)
}

/*
ClientList Method for ClientList

List client for a Relationship manager

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClientListRequest
*/
func (a *ClientApiService) ClientList(ctx _context.Context) ApiClientListRequest {
	return ApiClientListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedClientDetailList
func (a *ClientApiService) ClientListExecute(r ApiClientListRequest) (PaginatedClientDetailList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedClientDetailList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.externalCustodianId != nil {
		localVarQueryParams.Add("external_custodian_id", parameterToString(*r.externalCustodianId, ""))
	}
	if r.extraData != nil {
		localVarQueryParams.Add("extra_data", parameterToString(*r.extraData, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientNationalityCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	nationalityCreate *NationalityCreate
}

func (r ApiClientNationalityCreateRequest) NationalityCreate(nationalityCreate NationalityCreate) ApiClientNationalityCreateRequest {
	r.nationalityCreate = &nationalityCreate
	return r
}

func (r ApiClientNationalityCreateRequest) Execute() (NationalityCreate, *_nethttp.Response, error) {
	return r.ApiService.ClientNationalityCreateExecute(r)
}

/*
ClientNationalityCreate Method for ClientNationalityCreate

Create nationality for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientNationalityCreateRequest
*/
func (a *ClientApiService) ClientNationalityCreate(ctx _context.Context, clientUuid string) ApiClientNationalityCreateRequest {
	return ApiClientNationalityCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return NationalityCreate
func (a *ClientApiService) ClientNationalityCreateExecute(r ApiClientNationalityCreateRequest) (NationalityCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NationalityCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientNationalityCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/nationalities/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.nationalityCreate == nil {
		return localVarReturnValue, nil, reportError("nationalityCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nationalityCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientNationlitiesListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientNationlitiesListRequest) Limit(limit int32) ApiClientNationlitiesListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientNationlitiesListRequest) Offset(offset int32) ApiClientNationlitiesListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientNationlitiesListRequest) Execute() (PaginatedNationalityListList, *_nethttp.Response, error) {
	return r.ApiService.ClientNationlitiesListExecute(r)
}

/*
ClientNationlitiesList Method for ClientNationlitiesList

List nationlities for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientNationlitiesListRequest
*/
func (a *ClientApiService) ClientNationlitiesList(ctx _context.Context, clientUuid string) ApiClientNationlitiesListRequest {
	return ApiClientNationlitiesListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return PaginatedNationalityListList
func (a *ClientApiService) ClientNationlitiesListExecute(r ApiClientNationlitiesListRequest) (PaginatedNationalityListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedNationalityListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientNationlitiesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/nationalities/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientNationlityDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientNationlityDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientNationlityDeleteExecute(r)
}

/*
ClientNationlityDelete Method for ClientNationlityDelete

Delete a client nationality

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientNationlityDeleteRequest
*/
func (a *ClientApiService) ClientNationlityDelete(ctx _context.Context, clientUuid string, uuid string) ApiClientNationlityDeleteRequest {
	return ApiClientNationlityDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientNationlityDeleteExecute(r ApiClientNationlityDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientNationlityDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/nationalities/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientNationlityPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	patchedNationalityUpdate *PatchedNationalityUpdate
}

func (r ApiClientNationlityPartialUpdateRequest) PatchedNationalityUpdate(patchedNationalityUpdate PatchedNationalityUpdate) ApiClientNationlityPartialUpdateRequest {
	r.patchedNationalityUpdate = &patchedNationalityUpdate
	return r
}

func (r ApiClientNationlityPartialUpdateRequest) Execute() (NationalityUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientNationlityPartialUpdateExecute(r)
}

/*
ClientNationlityPartialUpdate Method for ClientNationlityPartialUpdate

Partial Update a client nationality

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientNationlityPartialUpdateRequest
*/
func (a *ClientApiService) ClientNationlityPartialUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientNationlityPartialUpdateRequest {
	return ApiClientNationlityPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NationalityUpdate
func (a *ClientApiService) ClientNationlityPartialUpdateExecute(r ApiClientNationlityPartialUpdateRequest) (NationalityUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NationalityUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientNationlityPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/nationalities/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedNationalityUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientNationlityRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientNationlityRetrieveRequest) Execute() (NationalityList, *_nethttp.Response, error) {
	return r.ApiService.ClientNationlityRetrieveExecute(r)
}

/*
ClientNationlityRetrieve Method for ClientNationlityRetrieve

Retrieve a client nationality

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientNationlityRetrieveRequest
*/
func (a *ClientApiService) ClientNationlityRetrieve(ctx _context.Context, clientUuid string, uuid string) ApiClientNationlityRetrieveRequest {
	return ApiClientNationlityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NationalityList
func (a *ClientApiService) ClientNationlityRetrieveExecute(r ApiClientNationlityRetrieveRequest) (NationalityList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NationalityList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientNationlityRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/nationalities/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientNationlityUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	nationalityUpdate *NationalityUpdate
}

func (r ApiClientNationlityUpdateRequest) NationalityUpdate(nationalityUpdate NationalityUpdate) ApiClientNationlityUpdateRequest {
	r.nationalityUpdate = &nationalityUpdate
	return r
}

func (r ApiClientNationlityUpdateRequest) Execute() (NationalityUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientNationlityUpdateExecute(r)
}

/*
ClientNationlityUpdate Method for ClientNationlityUpdate

Update a client nationality

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientNationlityUpdateRequest
*/
func (a *ClientApiService) ClientNationlityUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientNationlityUpdateRequest {
	return ApiClientNationlityUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NationalityUpdate
func (a *ClientApiService) ClientNationlityUpdateExecute(r ApiClientNationlityUpdateRequest) (NationalityUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NationalityUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientNationlityUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/nationalities/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.nationalityUpdate == nil {
		return localVarReturnValue, nil, reportError("nationalityUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nationalityUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	uuid string
	patchedApplicationClientUpdate *PatchedApplicationClientUpdate
}

func (r ApiClientPartialUpdateRequest) PatchedApplicationClientUpdate(patchedApplicationClientUpdate PatchedApplicationClientUpdate) ApiClientPartialUpdateRequest {
	r.patchedApplicationClientUpdate = &patchedApplicationClientUpdate
	return r
}

func (r ApiClientPartialUpdateRequest) Execute() (ApplicationClientUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientPartialUpdateExecute(r)
}

/*
ClientPartialUpdate Method for ClientPartialUpdate

Partial Update a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiClientPartialUpdateRequest
*/
func (a *ClientApiService) ClientPartialUpdate(ctx _context.Context, uuid string) ApiClientPartialUpdateRequest {
	return ApiClientPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ApplicationClientUpdate
func (a *ClientApiService) ClientPartialUpdateExecute(r ApiClientPartialUpdateRequest) (ApplicationClientUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationClientUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedApplicationClientUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	uuid string
}


func (r ApiClientRetrieveRequest) Execute() (ClientDetail, *_nethttp.Response, error) {
	return r.ApiService.ClientRetrieveExecute(r)
}

/*
ClientRetrieve Method for ClientRetrieve

Retrieve a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiClientRetrieveRequest
*/
func (a *ClientApiService) ClientRetrieve(ctx _context.Context, uuid string) ApiClientRetrieveRequest {
	return ApiClientRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ClientDetail
func (a *ClientApiService) ClientRetrieveExecute(r ApiClientRetrieveRequest) (ClientDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClientDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientRiskAssessmentCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	assessment *Assessment
}

func (r ApiClientRiskAssessmentCreateRequest) Assessment(assessment Assessment) ApiClientRiskAssessmentCreateRequest {
	r.assessment = &assessment
	return r
}

func (r ApiClientRiskAssessmentCreateRequest) Execute() (Assessment, *_nethttp.Response, error) {
	return r.ApiService.ClientRiskAssessmentCreateExecute(r)
}

/*
ClientRiskAssessmentCreate Method for ClientRiskAssessmentCreate

Create a risk assessment for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientRiskAssessmentCreateRequest
*/
func (a *ClientApiService) ClientRiskAssessmentCreate(ctx _context.Context, clientUuid string) ApiClientRiskAssessmentCreateRequest {
	return ApiClientRiskAssessmentCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return Assessment
func (a *ClientApiService) ClientRiskAssessmentCreateExecute(r ApiClientRiskAssessmentCreateRequest) (Assessment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Assessment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientRiskAssessmentCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/risk-assessments/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.assessment == nil {
		return localVarReturnValue, nil, reportError("assessment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assessment
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientRiskAssessmentDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientRiskAssessmentDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientRiskAssessmentDeleteExecute(r)
}

/*
ClientRiskAssessmentDelete Method for ClientRiskAssessmentDelete

Delete a client risk assessment

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientRiskAssessmentDeleteRequest
*/
func (a *ClientApiService) ClientRiskAssessmentDelete(ctx _context.Context, clientUuid string, uuid string) ApiClientRiskAssessmentDeleteRequest {
	return ApiClientRiskAssessmentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientRiskAssessmentDeleteExecute(r ApiClientRiskAssessmentDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientRiskAssessmentDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/risk-assessments/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientRiskAssessmentListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	limit *int32
	offset *int32
	status *[]string
}

// Number of results to return per page.
func (r ApiClientRiskAssessmentListRequest) Limit(limit int32) ApiClientRiskAssessmentListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientRiskAssessmentListRequest) Offset(offset int32) ApiClientRiskAssessmentListRequest {
	r.offset = &offset
	return r
}
func (r ApiClientRiskAssessmentListRequest) Status(status []string) ApiClientRiskAssessmentListRequest {
	r.status = &status
	return r
}

func (r ApiClientRiskAssessmentListRequest) Execute() (PaginatedAssessmentList, *_nethttp.Response, error) {
	return r.ApiService.ClientRiskAssessmentListExecute(r)
}

/*
ClientRiskAssessmentList Method for ClientRiskAssessmentList

List Risk Assessment for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientRiskAssessmentListRequest
*/
func (a *ClientApiService) ClientRiskAssessmentList(ctx _context.Context, clientUuid string) ApiClientRiskAssessmentListRequest {
	return ApiClientRiskAssessmentListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return PaginatedAssessmentList
func (a *ClientApiService) ClientRiskAssessmentListExecute(r ApiClientRiskAssessmentListRequest) (PaginatedAssessmentList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAssessmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientRiskAssessmentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/risk-assessments/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientRiskAssessmentPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	patchedAssessment *PatchedAssessment
}

func (r ApiClientRiskAssessmentPartialUpdateRequest) PatchedAssessment(patchedAssessment PatchedAssessment) ApiClientRiskAssessmentPartialUpdateRequest {
	r.patchedAssessment = &patchedAssessment
	return r
}

func (r ApiClientRiskAssessmentPartialUpdateRequest) Execute() (Assessment, *_nethttp.Response, error) {
	return r.ApiService.ClientRiskAssessmentPartialUpdateExecute(r)
}

/*
ClientRiskAssessmentPartialUpdate Method for ClientRiskAssessmentPartialUpdate

Partial Update a client risk assessment

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientRiskAssessmentPartialUpdateRequest
*/
func (a *ClientApiService) ClientRiskAssessmentPartialUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientRiskAssessmentPartialUpdateRequest {
	return ApiClientRiskAssessmentPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Assessment
func (a *ClientApiService) ClientRiskAssessmentPartialUpdateExecute(r ApiClientRiskAssessmentPartialUpdateRequest) (Assessment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Assessment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientRiskAssessmentPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/risk-assessments/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAssessment
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientRiskAssessmentRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientRiskAssessmentRetrieveRequest) Execute() (Assessment, *_nethttp.Response, error) {
	return r.ApiService.ClientRiskAssessmentRetrieveExecute(r)
}

/*
ClientRiskAssessmentRetrieve Method for ClientRiskAssessmentRetrieve

Retrieve a client risk assessment

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientRiskAssessmentRetrieveRequest
*/
func (a *ClientApiService) ClientRiskAssessmentRetrieve(ctx _context.Context, clientUuid string, uuid string) ApiClientRiskAssessmentRetrieveRequest {
	return ApiClientRiskAssessmentRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Assessment
func (a *ClientApiService) ClientRiskAssessmentRetrieveExecute(r ApiClientRiskAssessmentRetrieveRequest) (Assessment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Assessment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientRiskAssessmentRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/risk-assessments/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientTWRRPerformanceRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientTWRRPerformanceRequest) Execute() (ClientPerformance, *_nethttp.Response, error) {
	return r.ApiService.ClientTWRRPerformanceExecute(r)
}

/*
ClientTWRRPerformance Method for ClientTWRRPerformance

Calculate TWRR Performance for client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientTWRRPerformanceRequest
*/
func (a *ClientApiService) ClientTWRRPerformance(ctx _context.Context, clientUuid string, uuid string) ApiClientTWRRPerformanceRequest {
	return ApiClientTWRRPerformanceRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ClientPerformance
func (a *ClientApiService) ClientTWRRPerformanceExecute(r ApiClientTWRRPerformanceRequest) (ClientPerformance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClientPerformance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTWRRPerformance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{uuid}/performance/twrr/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientTaxInformationCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	taxInformationCreateUpdate *TaxInformationCreateUpdate
}

func (r ApiClientTaxInformationCreateRequest) TaxInformationCreateUpdate(taxInformationCreateUpdate TaxInformationCreateUpdate) ApiClientTaxInformationCreateRequest {
	r.taxInformationCreateUpdate = &taxInformationCreateUpdate
	return r
}

func (r ApiClientTaxInformationCreateRequest) Execute() (TaxInformationCreateUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientTaxInformationCreateExecute(r)
}

/*
ClientTaxInformationCreate Method for ClientTaxInformationCreate

Create a tax inforation for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientTaxInformationCreateRequest
*/
func (a *ClientApiService) ClientTaxInformationCreate(ctx _context.Context, clientUuid string) ApiClientTaxInformationCreateRequest {
	return ApiClientTaxInformationCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return TaxInformationCreateUpdate
func (a *ClientApiService) ClientTaxInformationCreateExecute(r ApiClientTaxInformationCreateRequest) (TaxInformationCreateUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TaxInformationCreateUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTaxInformationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/tax-informations/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.taxInformationCreateUpdate == nil {
		return localVarReturnValue, nil, reportError("taxInformationCreateUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taxInformationCreateUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientTaxInformationDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientTaxInformationDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientTaxInformationDeleteExecute(r)
}

/*
ClientTaxInformationDelete Method for ClientTaxInformationDelete

Delete a client tax inforation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientTaxInformationDeleteRequest
*/
func (a *ClientApiService) ClientTaxInformationDelete(ctx _context.Context, clientUuid string, uuid string) ApiClientTaxInformationDeleteRequest {
	return ApiClientTaxInformationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientTaxInformationDeleteExecute(r ApiClientTaxInformationDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTaxInformationDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientTaxInformationListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientTaxInformationListRequest) Limit(limit int32) ApiClientTaxInformationListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientTaxInformationListRequest) Offset(offset int32) ApiClientTaxInformationListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientTaxInformationListRequest) Execute() (PaginatedTaxInformationListList, *_nethttp.Response, error) {
	return r.ApiService.ClientTaxInformationListExecute(r)
}

/*
ClientTaxInformationList Method for ClientTaxInformationList

List tax information for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @return ApiClientTaxInformationListRequest
*/
func (a *ClientApiService) ClientTaxInformationList(ctx _context.Context, clientUuid string) ApiClientTaxInformationListRequest {
	return ApiClientTaxInformationListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return PaginatedTaxInformationListList
func (a *ClientApiService) ClientTaxInformationListExecute(r ApiClientTaxInformationListRequest) (PaginatedTaxInformationListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedTaxInformationListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTaxInformationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/tax-informations/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientTaxInformationPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	patchedTaxInformationCreateUpdate *PatchedTaxInformationCreateUpdate
}

func (r ApiClientTaxInformationPartialUpdateRequest) PatchedTaxInformationCreateUpdate(patchedTaxInformationCreateUpdate PatchedTaxInformationCreateUpdate) ApiClientTaxInformationPartialUpdateRequest {
	r.patchedTaxInformationCreateUpdate = &patchedTaxInformationCreateUpdate
	return r
}

func (r ApiClientTaxInformationPartialUpdateRequest) Execute() (TaxInformationCreateUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientTaxInformationPartialUpdateExecute(r)
}

/*
ClientTaxInformationPartialUpdate Method for ClientTaxInformationPartialUpdate

Partial Update a client tax inforation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientTaxInformationPartialUpdateRequest
*/
func (a *ClientApiService) ClientTaxInformationPartialUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientTaxInformationPartialUpdateRequest {
	return ApiClientTaxInformationPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return TaxInformationCreateUpdate
func (a *ClientApiService) ClientTaxInformationPartialUpdateExecute(r ApiClientTaxInformationPartialUpdateRequest) (TaxInformationCreateUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TaxInformationCreateUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTaxInformationPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTaxInformationCreateUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientTaxInformationRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
}


func (r ApiClientTaxInformationRetrieveRequest) Execute() (TaxInformationList, *_nethttp.Response, error) {
	return r.ApiService.ClientTaxInformationRetrieveExecute(r)
}

/*
ClientTaxInformationRetrieve Method for ClientTaxInformationRetrieve

Retrieve a client tax inforation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientTaxInformationRetrieveRequest
*/
func (a *ClientApiService) ClientTaxInformationRetrieve(ctx _context.Context, clientUuid string, uuid string) ApiClientTaxInformationRetrieveRequest {
	return ApiClientTaxInformationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return TaxInformationList
func (a *ClientApiService) ClientTaxInformationRetrieveExecute(r ApiClientTaxInformationRetrieveRequest) (TaxInformationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TaxInformationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTaxInformationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientTaxInformationUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	taxInformationCreateUpdate *TaxInformationCreateUpdate
}

func (r ApiClientTaxInformationUpdateRequest) TaxInformationCreateUpdate(taxInformationCreateUpdate TaxInformationCreateUpdate) ApiClientTaxInformationUpdateRequest {
	r.taxInformationCreateUpdate = &taxInformationCreateUpdate
	return r
}

func (r ApiClientTaxInformationUpdateRequest) Execute() (TaxInformationCreateUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientTaxInformationUpdateExecute(r)
}

/*
ClientTaxInformationUpdate Method for ClientTaxInformationUpdate

Update a client tax inforation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @return ApiClientTaxInformationUpdateRequest
*/
func (a *ClientApiService) ClientTaxInformationUpdate(ctx _context.Context, clientUuid string, uuid string) ApiClientTaxInformationUpdateRequest {
	return ApiClientTaxInformationUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return TaxInformationCreateUpdate
func (a *ClientApiService) ClientTaxInformationUpdateExecute(r ApiClientTaxInformationUpdateRequest) (TaxInformationCreateUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TaxInformationCreateUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientTaxInformationUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.taxInformationCreateUpdate == nil {
		return localVarReturnValue, nil, reportError("taxInformationCreateUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taxInformationCreateUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	uuid string
	applicationClientUpdate *ApplicationClientUpdate
}

func (r ApiClientUpdateRequest) ApplicationClientUpdate(applicationClientUpdate ApplicationClientUpdate) ApiClientUpdateRequest {
	r.applicationClientUpdate = &applicationClientUpdate
	return r
}

func (r ApiClientUpdateRequest) Execute() (ApplicationClientUpdate, *_nethttp.Response, error) {
	return r.ApiService.ClientUpdateExecute(r)
}

/*
ClientUpdate Method for ClientUpdate

Update a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiClientUpdateRequest
*/
func (a *ClientApiService) ClientUpdate(ctx _context.Context, uuid string) ApiClientUpdateRequest {
	return ApiClientUpdateRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ApplicationClientUpdate
func (a *ClientApiService) ClientUpdateExecute(r ApiClientUpdateRequest) (ApplicationClientUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationClientUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.applicationClientUpdate == nil {
		return localVarReturnValue, nil, reportError("applicationClientUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationClientUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	verifyTypeCode string
	verificationCreate *VerificationCreate
}

func (r ApiClientVerificationCreateRequest) VerificationCreate(verificationCreate VerificationCreate) ApiClientVerificationCreateRequest {
	r.verificationCreate = &verificationCreate
	return r
}

func (r ApiClientVerificationCreateRequest) Execute() (VerificationCreate, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationCreateExecute(r)
}

/*
ClientVerificationCreate Method for ClientVerificationCreate

Create a verification for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationCreateRequest
*/
func (a *ClientApiService) ClientVerificationCreate(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationCreateRequest {
	return ApiClientVerificationCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationCreate
func (a *ClientApiService) ClientVerificationCreateExecute(r ApiClientVerificationCreateRequest) (VerificationCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.verificationCreate == nil {
		return localVarReturnValue, nil, reportError("verificationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verificationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentCreateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	verifyTypeCode string
	uuid *string
	verifyType *VerifyTypeEnum
	created *time.Time
	updated *time.Time
	verificationDocuments *[]VerificationDocumentCreate
	status *StatusBd7Enum
	result *OneOfResultEnumBlankEnum
}

func (r ApiClientVerificationDocumentCreateRequest) Uuid(uuid string) ApiClientVerificationDocumentCreateRequest {
	r.uuid = &uuid
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) VerifyType(verifyType VerifyTypeEnum) ApiClientVerificationDocumentCreateRequest {
	r.verifyType = &verifyType
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Created(created time.Time) ApiClientVerificationDocumentCreateRequest {
	r.created = &created
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Updated(updated time.Time) ApiClientVerificationDocumentCreateRequest {
	r.updated = &updated
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) VerificationDocuments(verificationDocuments []VerificationDocumentCreate) ApiClientVerificationDocumentCreateRequest {
	r.verificationDocuments = &verificationDocuments
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Status(status StatusBd7Enum) ApiClientVerificationDocumentCreateRequest {
	r.status = &status
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Result(result OneOfResultEnumBlankEnum) ApiClientVerificationDocumentCreateRequest {
	r.result = &result
	return r
}

func (r ApiClientVerificationDocumentCreateRequest) Execute() (VerificationWithType, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentCreateExecute(r)
}

/*
ClientVerificationDocumentCreate Method for ClientVerificationDocumentCreate

Create a verification Document for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentCreateRequest
*/
func (a *ClientApiService) ClientVerificationDocumentCreate(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationDocumentCreateRequest {
	return ApiClientVerificationDocumentCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationWithType
func (a *ClientApiService) ClientVerificationDocumentCreateExecute(r ApiClientVerificationDocumentCreateRequest) (VerificationWithType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationWithType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationDocumentCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}
	if r.verifyType == nil {
		return localVarReturnValue, nil, reportError("verifyType is required and must be specified")
	}
	if r.created == nil {
		return localVarReturnValue, nil, reportError("created is required and must be specified")
	}
	if r.updated == nil {
		return localVarReturnValue, nil, reportError("updated is required and must be specified")
	}
	if r.verificationDocuments == nil {
		return localVarReturnValue, nil, reportError("verificationDocuments is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(*r.uuid, ""))
	localVarFormParams.Add("verify_type", parameterToString(*r.verifyType, ""))
	if r.status != nil {
		localVarFormParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.result != nil {
		paramJson, err := parameterToJson(*r.result)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("result", paramJson)
	}
	localVarFormParams.Add("created", parameterToString(*r.created, ""))
	localVarFormParams.Add("updated", parameterToString(*r.updated, ""))
	localVarFormParams.Add("verification_documents", parameterToString(*r.verificationDocuments, "csv"))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentDeleteRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	verifyTypeCode string
}


func (r ApiClientVerificationDocumentDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentDeleteExecute(r)
}

/*
ClientVerificationDocumentDelete Method for ClientVerificationDocumentDelete

Delete a client verificatoin document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentDeleteRequest
*/
func (a *ClientApiService) ClientVerificationDocumentDelete(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentDeleteRequest {
	return ApiClientVerificationDocumentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
func (a *ClientApiService) ClientVerificationDocumentDeleteExecute(r ApiClientVerificationDocumentDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationDocumentDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	verifyTypeCode string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientVerificationDocumentListRequest) Limit(limit int32) ApiClientVerificationDocumentListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientVerificationDocumentListRequest) Offset(offset int32) ApiClientVerificationDocumentListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientVerificationDocumentListRequest) Execute() (PaginatedVerificationDocumentList, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentListExecute(r)
}

/*
ClientVerificationDocumentList Method for ClientVerificationDocumentList

List Verification Document for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentListRequest
*/
func (a *ClientApiService) ClientVerificationDocumentList(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationDocumentListRequest {
	return ApiClientVerificationDocumentListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return PaginatedVerificationDocumentList
func (a *ClientApiService) ClientVerificationDocumentListExecute(r ApiClientVerificationDocumentListRequest) (PaginatedVerificationDocumentList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedVerificationDocumentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationDocumentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	verifyTypeCode string
	uuid2 *string
	documentType *DocumentTypeEnum
	documentFront *string
	documentBack *string
}

func (r ApiClientVerificationDocumentPartialUpdateRequest) Uuid2(uuid2 string) ApiClientVerificationDocumentPartialUpdateRequest {
	r.uuid2 = &uuid2
	return r
}
func (r ApiClientVerificationDocumentPartialUpdateRequest) DocumentType(documentType DocumentTypeEnum) ApiClientVerificationDocumentPartialUpdateRequest {
	r.documentType = &documentType
	return r
}
func (r ApiClientVerificationDocumentPartialUpdateRequest) DocumentFront(documentFront string) ApiClientVerificationDocumentPartialUpdateRequest {
	r.documentFront = &documentFront
	return r
}
func (r ApiClientVerificationDocumentPartialUpdateRequest) DocumentBack(documentBack string) ApiClientVerificationDocumentPartialUpdateRequest {
	r.documentBack = &documentBack
	return r
}

func (r ApiClientVerificationDocumentPartialUpdateRequest) Execute() (VerificationDocument, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentPartialUpdateExecute(r)
}

/*
ClientVerificationDocumentPartialUpdate Method for ClientVerificationDocumentPartialUpdate

Partial Update a client verification document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentPartialUpdateRequest
*/
func (a *ClientApiService) ClientVerificationDocumentPartialUpdate(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentPartialUpdateRequest {
	return ApiClientVerificationDocumentPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationDocument
func (a *ClientApiService) ClientVerificationDocumentPartialUpdateExecute(r ApiClientVerificationDocumentPartialUpdateRequest) (VerificationDocument, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationDocumentPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.uuid2 != nil {
		localVarFormParams.Add("uuid", parameterToString(*r.uuid2, ""))
	}
	if r.documentType != nil {
		localVarFormParams.Add("document_type", parameterToString(*r.documentType, ""))
	}
	if r.documentFront != nil {
		localVarFormParams.Add("document_front", parameterToString(*r.documentFront, ""))
	}
	if r.documentBack != nil {
		localVarFormParams.Add("document_back", parameterToString(*r.documentBack, ""))
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	verifyTypeCode string
}


func (r ApiClientVerificationDocumentRetrieveRequest) Execute() (VerificationDocument, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentRetrieveExecute(r)
}

/*
ClientVerificationDocumentRetrieve Method for ClientVerificationDocumentRetrieve

Retrieve a client verification document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentRetrieveRequest
*/
func (a *ClientApiService) ClientVerificationDocumentRetrieve(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentRetrieveRequest {
	return ApiClientVerificationDocumentRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationDocument
func (a *ClientApiService) ClientVerificationDocumentRetrieveExecute(r ApiClientVerificationDocumentRetrieveRequest) (VerificationDocument, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationDocumentRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentUpdateRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	verifyTypeCode string
	uuid2 *string
	documentType *DocumentTypeEnum
	documentFront *string
	documentBack *string
}

func (r ApiClientVerificationDocumentUpdateRequest) Uuid2(uuid2 string) ApiClientVerificationDocumentUpdateRequest {
	r.uuid2 = &uuid2
	return r
}
func (r ApiClientVerificationDocumentUpdateRequest) DocumentType(documentType DocumentTypeEnum) ApiClientVerificationDocumentUpdateRequest {
	r.documentType = &documentType
	return r
}
func (r ApiClientVerificationDocumentUpdateRequest) DocumentFront(documentFront string) ApiClientVerificationDocumentUpdateRequest {
	r.documentFront = &documentFront
	return r
}
func (r ApiClientVerificationDocumentUpdateRequest) DocumentBack(documentBack string) ApiClientVerificationDocumentUpdateRequest {
	r.documentBack = &documentBack
	return r
}

func (r ApiClientVerificationDocumentUpdateRequest) Execute() (VerificationDocument, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentUpdateExecute(r)
}

/*
ClientVerificationDocumentUpdate Method for ClientVerificationDocumentUpdate

Update a client verification document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentUpdateRequest
*/
func (a *ClientApiService) ClientVerificationDocumentUpdate(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentUpdateRequest {
	return ApiClientVerificationDocumentUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationDocument
func (a *ClientApiService) ClientVerificationDocumentUpdateExecute(r ApiClientVerificationDocumentUpdateRequest) (VerificationDocument, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationDocumentUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uuid2 == nil {
		return localVarReturnValue, nil, reportError("uuid2 is required and must be specified")
	}
	if r.documentType == nil {
		return localVarReturnValue, nil, reportError("documentType is required and must be specified")
	}
	if r.documentFront == nil {
		return localVarReturnValue, nil, reportError("documentFront is required and must be specified")
	}
	if r.documentBack == nil {
		return localVarReturnValue, nil, reportError("documentBack is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(*r.uuid2, ""))
	localVarFormParams.Add("document_type", parameterToString(*r.documentType, ""))
	localVarFormParams.Add("document_front", parameterToString(*r.documentFront, ""))
	localVarFormParams.Add("document_back", parameterToString(*r.documentBack, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationListRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	verifyTypeCode string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientVerificationListRequest) Limit(limit int32) ApiClientVerificationListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientVerificationListRequest) Offset(offset int32) ApiClientVerificationListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientVerificationListRequest) Execute() (PaginatedVerificationListList, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationListExecute(r)
}

/*
ClientVerificationList Method for ClientVerificationList

List Verification for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationListRequest
*/
func (a *ClientApiService) ClientVerificationList(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationListRequest {
	return ApiClientVerificationListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return PaginatedVerificationListList
func (a *ClientApiService) ClientVerificationListExecute(r ApiClientVerificationListRequest) (PaginatedVerificationListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedVerificationListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationRetrieveRequest struct {
	ctx _context.Context
	ApiService *ClientApiService
	clientUuid string
	uuid string
	verifyTypeCode string
}


func (r ApiClientVerificationRetrieveRequest) Execute() (VerificationList, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationRetrieveExecute(r)
}

/*
ClientVerificationRetrieve Method for ClientVerificationRetrieve

Retrieve a client verification 

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationRetrieveRequest
*/
func (a *ClientApiService) ClientVerificationRetrieve(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationRetrieveRequest {
	return ApiClientVerificationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationList
func (a *ClientApiService) ClientVerificationRetrieveExecute(r ApiClientVerificationRetrieveRequest) (VerificationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientApiService.ClientVerificationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
