/*
Nucoro API

No description

API version: 4.175.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// KYCApiService KYCApi service
type KYCApiService service

type ApiClientVerificationCreateRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	verifyTypeCode string
	verificationCreate *VerificationCreate
}

func (r ApiClientVerificationCreateRequest) VerificationCreate(verificationCreate VerificationCreate) ApiClientVerificationCreateRequest {
	r.verificationCreate = &verificationCreate
	return r
}

func (r ApiClientVerificationCreateRequest) Execute() (VerificationCreate, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationCreateExecute(r)
}

/*
ClientVerificationCreate Method for ClientVerificationCreate

Create a verification for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationCreateRequest
*/
func (a *KYCApiService) ClientVerificationCreate(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationCreateRequest {
	return ApiClientVerificationCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationCreate
func (a *KYCApiService) ClientVerificationCreateExecute(r ApiClientVerificationCreateRequest) (VerificationCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.verificationCreate == nil {
		return localVarReturnValue, nil, reportError("verificationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verificationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentCreateRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	verifyTypeCode string
	uuid *string
	verifyType *VerifyTypeEnum
	created *time.Time
	updated *time.Time
	verificationDocuments *[]VerificationDocumentCreate
	status *StatusBd7Enum
	result *OneOfResultEnumBlankEnum
}

func (r ApiClientVerificationDocumentCreateRequest) Uuid(uuid string) ApiClientVerificationDocumentCreateRequest {
	r.uuid = &uuid
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) VerifyType(verifyType VerifyTypeEnum) ApiClientVerificationDocumentCreateRequest {
	r.verifyType = &verifyType
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Created(created time.Time) ApiClientVerificationDocumentCreateRequest {
	r.created = &created
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Updated(updated time.Time) ApiClientVerificationDocumentCreateRequest {
	r.updated = &updated
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) VerificationDocuments(verificationDocuments []VerificationDocumentCreate) ApiClientVerificationDocumentCreateRequest {
	r.verificationDocuments = &verificationDocuments
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Status(status StatusBd7Enum) ApiClientVerificationDocumentCreateRequest {
	r.status = &status
	return r
}
func (r ApiClientVerificationDocumentCreateRequest) Result(result OneOfResultEnumBlankEnum) ApiClientVerificationDocumentCreateRequest {
	r.result = &result
	return r
}

func (r ApiClientVerificationDocumentCreateRequest) Execute() (VerificationWithType, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentCreateExecute(r)
}

/*
ClientVerificationDocumentCreate Method for ClientVerificationDocumentCreate

Create a verification Document for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentCreateRequest
*/
func (a *KYCApiService) ClientVerificationDocumentCreate(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationDocumentCreateRequest {
	return ApiClientVerificationDocumentCreateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationWithType
func (a *KYCApiService) ClientVerificationDocumentCreateExecute(r ApiClientVerificationDocumentCreateRequest) (VerificationWithType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationWithType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationDocumentCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}
	if r.verifyType == nil {
		return localVarReturnValue, nil, reportError("verifyType is required and must be specified")
	}
	if r.created == nil {
		return localVarReturnValue, nil, reportError("created is required and must be specified")
	}
	if r.updated == nil {
		return localVarReturnValue, nil, reportError("updated is required and must be specified")
	}
	if r.verificationDocuments == nil {
		return localVarReturnValue, nil, reportError("verificationDocuments is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(*r.uuid, ""))
	localVarFormParams.Add("verify_type", parameterToString(*r.verifyType, ""))
	if r.status != nil {
		localVarFormParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.result != nil {
		paramJson, err := parameterToJson(*r.result)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("result", paramJson)
	}
	localVarFormParams.Add("created", parameterToString(*r.created, ""))
	localVarFormParams.Add("updated", parameterToString(*r.updated, ""))
	localVarFormParams.Add("verification_documents", parameterToString(*r.verificationDocuments, "csv"))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentDeleteRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	uuid string
	verifyTypeCode string
}


func (r ApiClientVerificationDocumentDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentDeleteExecute(r)
}

/*
ClientVerificationDocumentDelete Method for ClientVerificationDocumentDelete

Delete a client verificatoin document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentDeleteRequest
*/
func (a *KYCApiService) ClientVerificationDocumentDelete(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentDeleteRequest {
	return ApiClientVerificationDocumentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
func (a *KYCApiService) ClientVerificationDocumentDeleteExecute(r ApiClientVerificationDocumentDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationDocumentDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentListRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	verifyTypeCode string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientVerificationDocumentListRequest) Limit(limit int32) ApiClientVerificationDocumentListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientVerificationDocumentListRequest) Offset(offset int32) ApiClientVerificationDocumentListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientVerificationDocumentListRequest) Execute() (PaginatedVerificationDocumentList, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentListExecute(r)
}

/*
ClientVerificationDocumentList Method for ClientVerificationDocumentList

List Verification Document for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentListRequest
*/
func (a *KYCApiService) ClientVerificationDocumentList(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationDocumentListRequest {
	return ApiClientVerificationDocumentListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return PaginatedVerificationDocumentList
func (a *KYCApiService) ClientVerificationDocumentListExecute(r ApiClientVerificationDocumentListRequest) (PaginatedVerificationDocumentList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedVerificationDocumentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationDocumentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	uuid string
	verifyTypeCode string
	uuid2 *string
	documentType *DocumentTypeEnum
	documentFront *string
	documentBack *string
}

func (r ApiClientVerificationDocumentPartialUpdateRequest) Uuid2(uuid2 string) ApiClientVerificationDocumentPartialUpdateRequest {
	r.uuid2 = &uuid2
	return r
}
func (r ApiClientVerificationDocumentPartialUpdateRequest) DocumentType(documentType DocumentTypeEnum) ApiClientVerificationDocumentPartialUpdateRequest {
	r.documentType = &documentType
	return r
}
func (r ApiClientVerificationDocumentPartialUpdateRequest) DocumentFront(documentFront string) ApiClientVerificationDocumentPartialUpdateRequest {
	r.documentFront = &documentFront
	return r
}
func (r ApiClientVerificationDocumentPartialUpdateRequest) DocumentBack(documentBack string) ApiClientVerificationDocumentPartialUpdateRequest {
	r.documentBack = &documentBack
	return r
}

func (r ApiClientVerificationDocumentPartialUpdateRequest) Execute() (VerificationDocument, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentPartialUpdateExecute(r)
}

/*
ClientVerificationDocumentPartialUpdate Method for ClientVerificationDocumentPartialUpdate

Partial Update a client verification document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentPartialUpdateRequest
*/
func (a *KYCApiService) ClientVerificationDocumentPartialUpdate(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentPartialUpdateRequest {
	return ApiClientVerificationDocumentPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationDocument
func (a *KYCApiService) ClientVerificationDocumentPartialUpdateExecute(r ApiClientVerificationDocumentPartialUpdateRequest) (VerificationDocument, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationDocumentPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.uuid2 != nil {
		localVarFormParams.Add("uuid", parameterToString(*r.uuid2, ""))
	}
	if r.documentType != nil {
		localVarFormParams.Add("document_type", parameterToString(*r.documentType, ""))
	}
	if r.documentFront != nil {
		localVarFormParams.Add("document_front", parameterToString(*r.documentFront, ""))
	}
	if r.documentBack != nil {
		localVarFormParams.Add("document_back", parameterToString(*r.documentBack, ""))
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentRetrieveRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	uuid string
	verifyTypeCode string
}


func (r ApiClientVerificationDocumentRetrieveRequest) Execute() (VerificationDocument, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentRetrieveExecute(r)
}

/*
ClientVerificationDocumentRetrieve Method for ClientVerificationDocumentRetrieve

Retrieve a client verification document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentRetrieveRequest
*/
func (a *KYCApiService) ClientVerificationDocumentRetrieve(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentRetrieveRequest {
	return ApiClientVerificationDocumentRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationDocument
func (a *KYCApiService) ClientVerificationDocumentRetrieveExecute(r ApiClientVerificationDocumentRetrieveRequest) (VerificationDocument, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationDocumentRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationDocumentUpdateRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	uuid string
	verifyTypeCode string
	uuid2 *string
	documentType *DocumentTypeEnum
	documentFront *string
	documentBack *string
}

func (r ApiClientVerificationDocumentUpdateRequest) Uuid2(uuid2 string) ApiClientVerificationDocumentUpdateRequest {
	r.uuid2 = &uuid2
	return r
}
func (r ApiClientVerificationDocumentUpdateRequest) DocumentType(documentType DocumentTypeEnum) ApiClientVerificationDocumentUpdateRequest {
	r.documentType = &documentType
	return r
}
func (r ApiClientVerificationDocumentUpdateRequest) DocumentFront(documentFront string) ApiClientVerificationDocumentUpdateRequest {
	r.documentFront = &documentFront
	return r
}
func (r ApiClientVerificationDocumentUpdateRequest) DocumentBack(documentBack string) ApiClientVerificationDocumentUpdateRequest {
	r.documentBack = &documentBack
	return r
}

func (r ApiClientVerificationDocumentUpdateRequest) Execute() (VerificationDocument, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationDocumentUpdateExecute(r)
}

/*
ClientVerificationDocumentUpdate Method for ClientVerificationDocumentUpdate

Update a client verification document

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationDocumentUpdateRequest
*/
func (a *KYCApiService) ClientVerificationDocumentUpdate(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationDocumentUpdateRequest {
	return ApiClientVerificationDocumentUpdateRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationDocument
func (a *KYCApiService) ClientVerificationDocumentUpdateExecute(r ApiClientVerificationDocumentUpdateRequest) (VerificationDocument, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationDocumentUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uuid2 == nil {
		return localVarReturnValue, nil, reportError("uuid2 is required and must be specified")
	}
	if r.documentType == nil {
		return localVarReturnValue, nil, reportError("documentType is required and must be specified")
	}
	if r.documentFront == nil {
		return localVarReturnValue, nil, reportError("documentFront is required and must be specified")
	}
	if r.documentBack == nil {
		return localVarReturnValue, nil, reportError("documentBack is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(*r.uuid2, ""))
	localVarFormParams.Add("document_type", parameterToString(*r.documentType, ""))
	localVarFormParams.Add("document_front", parameterToString(*r.documentFront, ""))
	localVarFormParams.Add("document_back", parameterToString(*r.documentBack, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationListRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	verifyTypeCode string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiClientVerificationListRequest) Limit(limit int32) ApiClientVerificationListRequest {
	r.limit = &limit
	return r
}
// The initial index from which to return the results.
func (r ApiClientVerificationListRequest) Offset(offset int32) ApiClientVerificationListRequest {
	r.offset = &offset
	return r
}

func (r ApiClientVerificationListRequest) Execute() (PaginatedVerificationListList, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationListExecute(r)
}

/*
ClientVerificationList Method for ClientVerificationList

List Verification for a client

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param verifyTypeCode
 @return ApiClientVerificationListRequest
*/
func (a *KYCApiService) ClientVerificationList(ctx _context.Context, clientUuid string, verifyTypeCode string) ApiClientVerificationListRequest {
	return ApiClientVerificationListRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return PaginatedVerificationListList
func (a *KYCApiService) ClientVerificationListExecute(r ApiClientVerificationListRequest) (PaginatedVerificationListList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedVerificationListList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClientVerificationRetrieveRequest struct {
	ctx _context.Context
	ApiService *KYCApiService
	clientUuid string
	uuid string
	verifyTypeCode string
}


func (r ApiClientVerificationRetrieveRequest) Execute() (VerificationList, *_nethttp.Response, error) {
	return r.ApiService.ClientVerificationRetrieveExecute(r)
}

/*
ClientVerificationRetrieve Method for ClientVerificationRetrieve

Retrieve a client verification 

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientUuid
 @param uuid
 @param verifyTypeCode
 @return ApiClientVerificationRetrieveRequest
*/
func (a *KYCApiService) ClientVerificationRetrieve(ctx _context.Context, clientUuid string, uuid string, verifyTypeCode string) ApiClientVerificationRetrieveRequest {
	return ApiClientVerificationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		clientUuid: clientUuid,
		uuid: uuid,
		verifyTypeCode: verifyTypeCode,
	}
}

// Execute executes the request
//  @return VerificationList
func (a *KYCApiService) ClientVerificationRetrieveExecute(r ApiClientVerificationRetrieveRequest) (VerificationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VerificationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCApiService.ClientVerificationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/{uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"client_uuid"+"}", _neturl.PathEscape(parameterToString(r.clientUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verify_type_code"+"}", _neturl.PathEscape(parameterToString(r.verifyTypeCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
