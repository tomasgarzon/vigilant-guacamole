/**
 * Nucoro API v2
 *
 * No description
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.AddressCreate
import org.openapitools.client.models.AddressList
import org.openapitools.client.models.AddressUpdate
import org.openapitools.client.models.ApplicationClientUpdate
import org.openapitools.client.models.Assessment
import org.openapitools.client.models.BankAccountCreateUpdate
import org.openapitools.client.models.BankAccountList
import org.openapitools.client.models.ClientCreate
import org.openapitools.client.models.ClientDetail
import org.openapitools.client.models.ClientPerformance
import org.openapitools.client.models.DocumentTypeEnum
import org.openapitools.client.models.NationalityCreate
import org.openapitools.client.models.NationalityList
import org.openapitools.client.models.NationalityUpdate
import org.openapitools.client.models.PaginatedAddressListList
import org.openapitools.client.models.PaginatedAssessmentList
import org.openapitools.client.models.PaginatedBankAccountListList
import org.openapitools.client.models.PaginatedClientDetailList
import org.openapitools.client.models.PaginatedNationalityListList
import org.openapitools.client.models.PaginatedTaxInformationListList
import org.openapitools.client.models.PaginatedVerificationDocumentList
import org.openapitools.client.models.PaginatedVerificationListList
import org.openapitools.client.models.PatchedAddressUpdate
import org.openapitools.client.models.PatchedApplicationClientUpdate
import org.openapitools.client.models.PatchedAssessment
import org.openapitools.client.models.PatchedBankAccountCreateUpdate
import org.openapitools.client.models.PatchedNationalityUpdate
import org.openapitools.client.models.PatchedTaxInformationCreateUpdate
import org.openapitools.client.models.ResultEnum
import org.openapitools.client.models.StatusBd7Enum
import org.openapitools.client.models.TaxInformationCreateUpdate
import org.openapitools.client.models.TaxInformationList
import org.openapitools.client.models.VerificationCreate
import org.openapitools.client.models.VerificationDocument
import org.openapitools.client.models.VerificationDocumentCreate
import org.openapitools.client.models.VerificationList
import org.openapitools.client.models.VerificationWithType
import org.openapitools.client.models.VerifyTypeEnum

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ClientApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * Create an address for a client
    * @param clientUuid  
    * @param addressCreate  
    * @return AddressCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressCreate(clientUuid: java.util.UUID, addressCreate: AddressCreate) : AddressCreate {
        val localVariableConfig = clientAddressCreateRequestConfig(clientUuid = clientUuid, addressCreate = addressCreate)

        val localVarResponse = request<AddressCreate, AddressCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressCreate
    *
    * @param clientUuid  
    * @param addressCreate  
    * @return RequestConfig
    */
    fun clientAddressCreateRequestConfig(clientUuid: java.util.UUID, addressCreate: AddressCreate) : RequestConfig<AddressCreate> {
        val localVariableBody = addressCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/addresses/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client address
    * @param addressUuid  
    * @param clientUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressDelete(addressUuid: java.util.UUID, clientUuid: java.util.UUID) : Unit {
        val localVariableConfig = clientAddressDeleteRequestConfig(addressUuid = addressUuid, clientUuid = clientUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressDelete
    *
    * @param addressUuid  
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientAddressDeleteRequestConfig(addressUuid: java.util.UUID, clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/addresses/{address_uuid}/".replace("{"+"address_uuid"+"}", "$addressUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client address
    * @param addressUuid  
    * @param clientUuid  
    * @param patchedAddressUpdate  (optional)
    * @return AddressUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressPartialUpdate(addressUuid: java.util.UUID, clientUuid: java.util.UUID, patchedAddressUpdate: PatchedAddressUpdate?) : AddressUpdate {
        val localVariableConfig = clientAddressPartialUpdateRequestConfig(addressUuid = addressUuid, clientUuid = clientUuid, patchedAddressUpdate = patchedAddressUpdate)

        val localVarResponse = request<PatchedAddressUpdate, AddressUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressPartialUpdate
    *
    * @param addressUuid  
    * @param clientUuid  
    * @param patchedAddressUpdate  (optional)
    * @return RequestConfig
    */
    fun clientAddressPartialUpdateRequestConfig(addressUuid: java.util.UUID, clientUuid: java.util.UUID, patchedAddressUpdate: PatchedAddressUpdate?) : RequestConfig<PatchedAddressUpdate> {
        val localVariableBody = patchedAddressUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/addresses/{address_uuid}/".replace("{"+"address_uuid"+"}", "$addressUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client address
    * @param addressUuid  
    * @param clientUuid  
    * @return AddressList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressRetrieve(addressUuid: java.util.UUID, clientUuid: java.util.UUID) : AddressList {
        val localVariableConfig = clientAddressRetrieveRequestConfig(addressUuid = addressUuid, clientUuid = clientUuid)

        val localVarResponse = request<Unit, AddressList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressRetrieve
    *
    * @param addressUuid  
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientAddressRetrieveRequestConfig(addressUuid: java.util.UUID, clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/addresses/{address_uuid}/".replace("{"+"address_uuid"+"}", "$addressUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client address
    * @param addressUuid  
    * @param clientUuid  
    * @param addressUpdate  
    * @return AddressUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressUpdate(addressUuid: java.util.UUID, clientUuid: java.util.UUID, addressUpdate: AddressUpdate) : AddressUpdate {
        val localVariableConfig = clientAddressUpdateRequestConfig(addressUuid = addressUuid, clientUuid = clientUuid, addressUpdate = addressUpdate)

        val localVarResponse = request<AddressUpdate, AddressUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressUpdate
    *
    * @param addressUuid  
    * @param clientUuid  
    * @param addressUpdate  
    * @return RequestConfig
    */
    fun clientAddressUpdateRequestConfig(addressUuid: java.util.UUID, clientUuid: java.util.UUID, addressUpdate: AddressUpdate) : RequestConfig<AddressUpdate> {
        val localVariableBody = addressUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/addresses/{address_uuid}/".replace("{"+"address_uuid"+"}", "$addressUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List address for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedAddressListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedAddressListList {
        val localVariableConfig = clientAddressesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedAddressListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAddressListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientAddressesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/addresses/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a bank account for a client
    * @param clientUuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return BankAccountCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountCreate(clientUuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : BankAccountCreateUpdate {
        val localVariableConfig = clientBankAccountCreateRequestConfig(clientUuid = clientUuid, bankAccountCreateUpdate = bankAccountCreateUpdate)

        val localVarResponse = request<BankAccountCreateUpdate, BankAccountCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountCreate
    *
    * @param clientUuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientBankAccountCreateRequestConfig(clientUuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : RequestConfig<BankAccountCreateUpdate> {
        val localVariableBody = bankAccountCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client bank account
    * @param bankAccountUuid  
    * @param clientUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountDelete(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID) : Unit {
        val localVariableConfig = clientBankAccountDeleteRequestConfig(bankAccountUuid = bankAccountUuid, clientUuid = clientUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountDelete
    *
    * @param bankAccountUuid  
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientBankAccountDeleteRequestConfig(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{bank_account_uuid}/".replace("{"+"bank_account_uuid"+"}", "$bankAccountUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client bank account
    * @param bankAccountUuid  
    * @param clientUuid  
    * @param patchedBankAccountCreateUpdate  (optional)
    * @return BankAccountCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountPartialUpdate(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID, patchedBankAccountCreateUpdate: PatchedBankAccountCreateUpdate?) : BankAccountCreateUpdate {
        val localVariableConfig = clientBankAccountPartialUpdateRequestConfig(bankAccountUuid = bankAccountUuid, clientUuid = clientUuid, patchedBankAccountCreateUpdate = patchedBankAccountCreateUpdate)

        val localVarResponse = request<PatchedBankAccountCreateUpdate, BankAccountCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountPartialUpdate
    *
    * @param bankAccountUuid  
    * @param clientUuid  
    * @param patchedBankAccountCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientBankAccountPartialUpdateRequestConfig(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID, patchedBankAccountCreateUpdate: PatchedBankAccountCreateUpdate?) : RequestConfig<PatchedBankAccountCreateUpdate> {
        val localVariableBody = patchedBankAccountCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{bank_account_uuid}/".replace("{"+"bank_account_uuid"+"}", "$bankAccountUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client bank account
    * @param bankAccountUuid  
    * @param clientUuid  
    * @return BankAccountList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountRetrieve(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID) : BankAccountList {
        val localVariableConfig = clientBankAccountRetrieveRequestConfig(bankAccountUuid = bankAccountUuid, clientUuid = clientUuid)

        val localVarResponse = request<Unit, BankAccountList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountRetrieve
    *
    * @param bankAccountUuid  
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientBankAccountRetrieveRequestConfig(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{bank_account_uuid}/".replace("{"+"bank_account_uuid"+"}", "$bankAccountUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client bank account
    * @param bankAccountUuid  
    * @param clientUuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return BankAccountCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountUpdate(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : BankAccountCreateUpdate {
        val localVariableConfig = clientBankAccountUpdateRequestConfig(bankAccountUuid = bankAccountUuid, clientUuid = clientUuid, bankAccountCreateUpdate = bankAccountCreateUpdate)

        val localVarResponse = request<BankAccountCreateUpdate, BankAccountCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountUpdate
    *
    * @param bankAccountUuid  
    * @param clientUuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientBankAccountUpdateRequestConfig(bankAccountUuid: java.util.UUID, clientUuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : RequestConfig<BankAccountCreateUpdate> {
        val localVariableBody = bankAccountCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{bank_account_uuid}/".replace("{"+"bank_account_uuid"+"}", "$bankAccountUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Bank Account for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedBankAccountListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountsList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedBankAccountListList {
        val localVariableConfig = clientBankAccountsListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedBankAccountListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedBankAccountListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountsList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientBankAccountsListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Complete onboarding for a client
    * @param clientUuid  
    * @param clientDetail  
    * @return ClientDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientCompleteOnboarding(clientUuid: java.util.UUID, clientDetail: ClientDetail) : ClientDetail {
        val localVariableConfig = clientCompleteOnboardingRequestConfig(clientUuid = clientUuid, clientDetail = clientDetail)

        val localVarResponse = request<ClientDetail, ClientDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientCompleteOnboarding
    *
    * @param clientUuid  
    * @param clientDetail  
    * @return RequestConfig
    */
    fun clientCompleteOnboardingRequestConfig(clientUuid: java.util.UUID, clientDetail: ClientDetail) : RequestConfig<ClientDetail> {
        val localVariableBody = clientDetail
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/onboarding/complete/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a client
    * @param clientCreate  
    * @return ClientCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientCreate(clientCreate: ClientCreate) : ClientCreate {
        val localVariableConfig = clientCreateRequestConfig(clientCreate = clientCreate)

        val localVarResponse = request<ClientCreate, ClientCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientCreate
    *
    * @param clientCreate  
    * @return RequestConfig
    */
    fun clientCreateRequestConfig(clientCreate: ClientCreate) : RequestConfig<ClientCreate> {
        val localVariableBody = clientCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List client for a Relationship manager
    * @param externalCustodianId  (optional)
    * @param extraData Additional client attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param ordering Ordering (optional)
    * @param search A search term. (optional)
    * @param status  (optional)
    * @return PaginatedClientDetailList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientList(externalCustodianId: kotlin.String?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, ordering: kotlin.collections.List<kotlin.String>?, search: kotlin.String?, status: kotlin.String?) : PaginatedClientDetailList {
        val localVariableConfig = clientListRequestConfig(externalCustodianId = externalCustodianId, extraData = extraData, limit = limit, offset = offset, ordering = ordering, search = search, status = status)

        val localVarResponse = request<Unit, PaginatedClientDetailList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedClientDetailList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientList
    *
    * @param externalCustodianId  (optional)
    * @param extraData Additional client attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param ordering Ordering (optional)
    * @param search A search term. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun clientListRequestConfig(externalCustodianId: kotlin.String?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, ordering: kotlin.collections.List<kotlin.String>?, search: kotlin.String?, status: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (externalCustodianId != null) {
                    put("external_custodian_id", listOf(externalCustodianId.toString()))
                }
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (ordering != null) {
                    put("ordering", toMultiValue(ordering.toList(), "csv"))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create nationality for a client
    * @param clientUuid  
    * @param nationalityCreate  
    * @return NationalityCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationalityCreate(clientUuid: java.util.UUID, nationalityCreate: NationalityCreate) : NationalityCreate {
        val localVariableConfig = clientNationalityCreateRequestConfig(clientUuid = clientUuid, nationalityCreate = nationalityCreate)

        val localVarResponse = request<NationalityCreate, NationalityCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationalityCreate
    *
    * @param clientUuid  
    * @param nationalityCreate  
    * @return RequestConfig
    */
    fun clientNationalityCreateRequestConfig(clientUuid: java.util.UUID, nationalityCreate: NationalityCreate) : RequestConfig<NationalityCreate> {
        val localVariableBody = nationalityCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/nationalities/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List nationlities for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedNationalityListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlitiesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedNationalityListList {
        val localVariableConfig = clientNationlitiesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedNationalityListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNationalityListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlitiesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientNationlitiesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/nationalities/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client nationality
    * @param clientUuid  
    * @param nationalityUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityDelete(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID) : Unit {
        val localVariableConfig = clientNationlityDeleteRequestConfig(clientUuid = clientUuid, nationalityUuid = nationalityUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityDelete
    *
    * @param clientUuid  
    * @param nationalityUuid  
    * @return RequestConfig
    */
    fun clientNationlityDeleteRequestConfig(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/nationalities/{nationality_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"nationality_uuid"+"}", "$nationalityUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client nationality
    * @param clientUuid  
    * @param nationalityUuid  
    * @param patchedNationalityUpdate  (optional)
    * @return NationalityUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityPartialUpdate(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID, patchedNationalityUpdate: PatchedNationalityUpdate?) : NationalityUpdate {
        val localVariableConfig = clientNationlityPartialUpdateRequestConfig(clientUuid = clientUuid, nationalityUuid = nationalityUuid, patchedNationalityUpdate = patchedNationalityUpdate)

        val localVarResponse = request<PatchedNationalityUpdate, NationalityUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityPartialUpdate
    *
    * @param clientUuid  
    * @param nationalityUuid  
    * @param patchedNationalityUpdate  (optional)
    * @return RequestConfig
    */
    fun clientNationlityPartialUpdateRequestConfig(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID, patchedNationalityUpdate: PatchedNationalityUpdate?) : RequestConfig<PatchedNationalityUpdate> {
        val localVariableBody = patchedNationalityUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/nationalities/{nationality_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"nationality_uuid"+"}", "$nationalityUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client nationality
    * @param clientUuid  
    * @param nationalityUuid  
    * @return NationalityList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityRetrieve(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID) : NationalityList {
        val localVariableConfig = clientNationlityRetrieveRequestConfig(clientUuid = clientUuid, nationalityUuid = nationalityUuid)

        val localVarResponse = request<Unit, NationalityList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityRetrieve
    *
    * @param clientUuid  
    * @param nationalityUuid  
    * @return RequestConfig
    */
    fun clientNationlityRetrieveRequestConfig(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/nationalities/{nationality_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"nationality_uuid"+"}", "$nationalityUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client nationality
    * @param clientUuid  
    * @param nationalityUuid  
    * @param nationalityUpdate  
    * @return NationalityUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityUpdate(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID, nationalityUpdate: NationalityUpdate) : NationalityUpdate {
        val localVariableConfig = clientNationlityUpdateRequestConfig(clientUuid = clientUuid, nationalityUuid = nationalityUuid, nationalityUpdate = nationalityUpdate)

        val localVarResponse = request<NationalityUpdate, NationalityUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityUpdate
    *
    * @param clientUuid  
    * @param nationalityUuid  
    * @param nationalityUpdate  
    * @return RequestConfig
    */
    fun clientNationlityUpdateRequestConfig(clientUuid: java.util.UUID, nationalityUuid: java.util.UUID, nationalityUpdate: NationalityUpdate) : RequestConfig<NationalityUpdate> {
        val localVariableBody = nationalityUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/nationalities/{nationality_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"nationality_uuid"+"}", "$nationalityUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client
    * @param clientUuid  
    * @param patchedApplicationClientUpdate  (optional)
    * @return ApplicationClientUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientPartialUpdate(clientUuid: java.util.UUID, patchedApplicationClientUpdate: PatchedApplicationClientUpdate?) : ApplicationClientUpdate {
        val localVariableConfig = clientPartialUpdateRequestConfig(clientUuid = clientUuid, patchedApplicationClientUpdate = patchedApplicationClientUpdate)

        val localVarResponse = request<PatchedApplicationClientUpdate, ApplicationClientUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplicationClientUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientPartialUpdate
    *
    * @param clientUuid  
    * @param patchedApplicationClientUpdate  (optional)
    * @return RequestConfig
    */
    fun clientPartialUpdateRequestConfig(clientUuid: java.util.UUID, patchedApplicationClientUpdate: PatchedApplicationClientUpdate?) : RequestConfig<PatchedApplicationClientUpdate> {
        val localVariableBody = patchedApplicationClientUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client
    * @param clientUuid  
    * @return ClientDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRetrieve(clientUuid: java.util.UUID) : ClientDetail {
        val localVariableConfig = clientRetrieveRequestConfig(clientUuid = clientUuid)

        val localVarResponse = request<Unit, ClientDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRetrieve
    *
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientRetrieveRequestConfig(clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a risk assessment for a client
    * @param clientUuid  
    * @param assessment  
    * @return Assessment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentCreate(clientUuid: java.util.UUID, assessment: Assessment) : Assessment {
        val localVariableConfig = clientRiskAssessmentCreateRequestConfig(clientUuid = clientUuid, assessment = assessment)

        val localVarResponse = request<Assessment, Assessment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Assessment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentCreate
    *
    * @param clientUuid  
    * @param assessment  
    * @return RequestConfig
    */
    fun clientRiskAssessmentCreateRequestConfig(clientUuid: java.util.UUID, assessment: Assessment) : RequestConfig<Assessment> {
        val localVariableBody = assessment
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client risk assessment
    * @param assessmentUuid  
    * @param clientUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentDelete(assessmentUuid: java.util.UUID, clientUuid: java.util.UUID) : Unit {
        val localVariableConfig = clientRiskAssessmentDeleteRequestConfig(assessmentUuid = assessmentUuid, clientUuid = clientUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentDelete
    *
    * @param assessmentUuid  
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientRiskAssessmentDeleteRequestConfig(assessmentUuid: java.util.UUID, clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/{assessment_uuid}/".replace("{"+"assessment_uuid"+"}", "$assessmentUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Risk Assessment for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return PaginatedAssessmentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : PaginatedAssessmentList {
        val localVariableConfig = clientRiskAssessmentListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset, status = status)

        val localVarResponse = request<Unit, PaginatedAssessmentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAssessmentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun clientRiskAssessmentListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", toMultiValue(status.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client risk assessment
    * @param assessmentUuid  
    * @param clientUuid  
    * @param patchedAssessment  (optional)
    * @return Assessment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentPartialUpdate(assessmentUuid: java.util.UUID, clientUuid: java.util.UUID, patchedAssessment: PatchedAssessment?) : Assessment {
        val localVariableConfig = clientRiskAssessmentPartialUpdateRequestConfig(assessmentUuid = assessmentUuid, clientUuid = clientUuid, patchedAssessment = patchedAssessment)

        val localVarResponse = request<PatchedAssessment, Assessment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Assessment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentPartialUpdate
    *
    * @param assessmentUuid  
    * @param clientUuid  
    * @param patchedAssessment  (optional)
    * @return RequestConfig
    */
    fun clientRiskAssessmentPartialUpdateRequestConfig(assessmentUuid: java.util.UUID, clientUuid: java.util.UUID, patchedAssessment: PatchedAssessment?) : RequestConfig<PatchedAssessment> {
        val localVariableBody = patchedAssessment
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/{assessment_uuid}/".replace("{"+"assessment_uuid"+"}", "$assessmentUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client risk assessment
    * @param assessmentUuid  
    * @param clientUuid  
    * @return Assessment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentRetrieve(assessmentUuid: java.util.UUID, clientUuid: java.util.UUID) : Assessment {
        val localVariableConfig = clientRiskAssessmentRetrieveRequestConfig(assessmentUuid = assessmentUuid, clientUuid = clientUuid)

        val localVarResponse = request<Unit, Assessment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Assessment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentRetrieve
    *
    * @param assessmentUuid  
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientRiskAssessmentRetrieveRequestConfig(assessmentUuid: java.util.UUID, clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/{assessment_uuid}/".replace("{"+"assessment_uuid"+"}", "$assessmentUuid").replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Calculate TWRR Performance for client
    * @param clientUuid  
    * @return ClientPerformance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTWRRPerformance(clientUuid: java.util.UUID) : ClientPerformance {
        val localVariableConfig = clientTWRRPerformanceRequestConfig(clientUuid = clientUuid)

        val localVarResponse = request<Unit, ClientPerformance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientPerformance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTWRRPerformance
    *
    * @param clientUuid  
    * @return RequestConfig
    */
    fun clientTWRRPerformanceRequestConfig(clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/performance/twrr/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a tax inforation for a client
    * @param clientUuid  
    * @param taxInformationCreateUpdate  
    * @return TaxInformationCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationCreate(clientUuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : TaxInformationCreateUpdate {
        val localVariableConfig = clientTaxInformationCreateRequestConfig(clientUuid = clientUuid, taxInformationCreateUpdate = taxInformationCreateUpdate)

        val localVarResponse = request<TaxInformationCreateUpdate, TaxInformationCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationCreate
    *
    * @param clientUuid  
    * @param taxInformationCreateUpdate  
    * @return RequestConfig
    */
    fun clientTaxInformationCreateRequestConfig(clientUuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : RequestConfig<TaxInformationCreateUpdate> {
        val localVariableBody = taxInformationCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/tax-informations/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client tax inforation
    * @param clientUuid  
    * @param taxInformationUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationDelete(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID) : Unit {
        val localVariableConfig = clientTaxInformationDeleteRequestConfig(clientUuid = clientUuid, taxInformationUuid = taxInformationUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationDelete
    *
    * @param clientUuid  
    * @param taxInformationUuid  
    * @return RequestConfig
    */
    fun clientTaxInformationDeleteRequestConfig(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{tax_information_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"tax_information_uuid"+"}", "$taxInformationUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List tax information for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTaxInformationListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTaxInformationListList {
        val localVariableConfig = clientTaxInformationListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTaxInformationListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTaxInformationListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientTaxInformationListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/tax-informations/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client tax inforation
    * @param clientUuid  
    * @param taxInformationUuid  
    * @param patchedTaxInformationCreateUpdate  (optional)
    * @return TaxInformationCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationPartialUpdate(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID, patchedTaxInformationCreateUpdate: PatchedTaxInformationCreateUpdate?) : TaxInformationCreateUpdate {
        val localVariableConfig = clientTaxInformationPartialUpdateRequestConfig(clientUuid = clientUuid, taxInformationUuid = taxInformationUuid, patchedTaxInformationCreateUpdate = patchedTaxInformationCreateUpdate)

        val localVarResponse = request<PatchedTaxInformationCreateUpdate, TaxInformationCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationPartialUpdate
    *
    * @param clientUuid  
    * @param taxInformationUuid  
    * @param patchedTaxInformationCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientTaxInformationPartialUpdateRequestConfig(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID, patchedTaxInformationCreateUpdate: PatchedTaxInformationCreateUpdate?) : RequestConfig<PatchedTaxInformationCreateUpdate> {
        val localVariableBody = patchedTaxInformationCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{tax_information_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"tax_information_uuid"+"}", "$taxInformationUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client tax inforation
    * @param clientUuid  
    * @param taxInformationUuid  
    * @return TaxInformationList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationRetrieve(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID) : TaxInformationList {
        val localVariableConfig = clientTaxInformationRetrieveRequestConfig(clientUuid = clientUuid, taxInformationUuid = taxInformationUuid)

        val localVarResponse = request<Unit, TaxInformationList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationRetrieve
    *
    * @param clientUuid  
    * @param taxInformationUuid  
    * @return RequestConfig
    */
    fun clientTaxInformationRetrieveRequestConfig(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{tax_information_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"tax_information_uuid"+"}", "$taxInformationUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client tax inforation
    * @param clientUuid  
    * @param taxInformationUuid  
    * @param taxInformationCreateUpdate  
    * @return TaxInformationCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationUpdate(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : TaxInformationCreateUpdate {
        val localVariableConfig = clientTaxInformationUpdateRequestConfig(clientUuid = clientUuid, taxInformationUuid = taxInformationUuid, taxInformationCreateUpdate = taxInformationCreateUpdate)

        val localVarResponse = request<TaxInformationCreateUpdate, TaxInformationCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationUpdate
    *
    * @param clientUuid  
    * @param taxInformationUuid  
    * @param taxInformationCreateUpdate  
    * @return RequestConfig
    */
    fun clientTaxInformationUpdateRequestConfig(clientUuid: java.util.UUID, taxInformationUuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : RequestConfig<TaxInformationCreateUpdate> {
        val localVariableBody = taxInformationCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{tax_information_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"tax_information_uuid"+"}", "$taxInformationUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client
    * @param clientUuid  
    * @param applicationClientUpdate  
    * @return ApplicationClientUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientUpdate(clientUuid: java.util.UUID, applicationClientUpdate: ApplicationClientUpdate) : ApplicationClientUpdate {
        val localVariableConfig = clientUpdateRequestConfig(clientUuid = clientUuid, applicationClientUpdate = applicationClientUpdate)

        val localVarResponse = request<ApplicationClientUpdate, ApplicationClientUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplicationClientUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientUpdate
    *
    * @param clientUuid  
    * @param applicationClientUpdate  
    * @return RequestConfig
    */
    fun clientUpdateRequestConfig(clientUuid: java.util.UUID, applicationClientUpdate: ApplicationClientUpdate) : RequestConfig<ApplicationClientUpdate> {
        val localVariableBody = applicationClientUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a verification for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param verificationCreate  
    * @return VerificationCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationCreate(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, verificationCreate: VerificationCreate) : VerificationCreate {
        val localVariableConfig = clientVerificationCreateRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, verificationCreate = verificationCreate)

        val localVarResponse = request<VerificationCreate, VerificationCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationCreate
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param verificationCreate  
    * @return RequestConfig
    */
    fun clientVerificationCreateRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, verificationCreate: VerificationCreate) : RequestConfig<VerificationCreate> {
        val localVariableBody = verificationCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a verification Document for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param uuid  
    * @param verifyType  
    * @param created  
    * @param updated  
    * @param verificationDocuments  
    * @param status  (optional)
    * @param result  (optional)
    * @return VerificationWithType
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentCreate(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID, verifyType: VerifyTypeEnum, created: java.time.OffsetDateTime, updated: java.time.OffsetDateTime, verificationDocuments: kotlin.collections.List<VerificationDocumentCreate>, status: StatusBd7Enum?, result: ResultEnum?) : VerificationWithType {
        val localVariableConfig = clientVerificationDocumentCreateRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, uuid = uuid, verifyType = verifyType, created = created, updated = updated, verificationDocuments = verificationDocuments, status = status, result = result)

        val localVarResponse = request<Map<String, Any?>, VerificationWithType>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationWithType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentCreate
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param uuid  
    * @param verifyType  
    * @param created  
    * @param updated  
    * @param verificationDocuments  
    * @param status  (optional)
    * @param result  (optional)
    * @return RequestConfig
    */
    fun clientVerificationDocumentCreateRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID, verifyType: VerifyTypeEnum, created: java.time.OffsetDateTime, updated: java.time.OffsetDateTime, verificationDocuments: kotlin.collections.List<VerificationDocumentCreate>, status: StatusBd7Enum?, result: ResultEnum?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "verify_type" to verifyType, "status" to status, "result" to result, "created" to created, "updated" to updated, "verification_documents" to verificationDocuments)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client verificatoin document
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentDelete(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String) : Unit {
        val localVariableConfig = clientVerificationDocumentDeleteRequestConfig(clientUuid = clientUuid, verificationDocumentUuid = verificationDocumentUuid, verifyTypeCode = verifyTypeCode)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentDelete
    *
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @return RequestConfig
    */
    fun clientVerificationDocumentDeleteRequestConfig(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{verification_document_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verification_document_uuid"+"}", "$verificationDocumentUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Verification Document for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedVerificationDocumentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentList(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedVerificationDocumentList {
        val localVariableConfig = clientVerificationDocumentListRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedVerificationDocumentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedVerificationDocumentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentList
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientVerificationDocumentListRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client verification document
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @param uuid  (optional)
    * @param documentType  (optional)
    * @param documentFront  (optional)
    * @param documentBack  (optional)
    * @return VerificationDocument
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentPartialUpdate(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID?, documentType: DocumentTypeEnum?, documentFront: kotlin.String?, documentBack: kotlin.String?) : VerificationDocument {
        val localVariableConfig = clientVerificationDocumentPartialUpdateRequestConfig(clientUuid = clientUuid, verificationDocumentUuid = verificationDocumentUuid, verifyTypeCode = verifyTypeCode, uuid = uuid, documentType = documentType, documentFront = documentFront, documentBack = documentBack)

        val localVarResponse = request<Map<String, Any?>, VerificationDocument>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentPartialUpdate
    *
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @param uuid  (optional)
    * @param documentType  (optional)
    * @param documentFront  (optional)
    * @param documentBack  (optional)
    * @return RequestConfig
    */
    fun clientVerificationDocumentPartialUpdateRequestConfig(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID?, documentType: DocumentTypeEnum?, documentFront: kotlin.String?, documentBack: kotlin.String?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "document_type" to documentType, "document_front" to documentFront, "document_back" to documentBack)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{verification_document_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verification_document_uuid"+"}", "$verificationDocumentUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client verification document
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @return VerificationDocument
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentRetrieve(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String) : VerificationDocument {
        val localVariableConfig = clientVerificationDocumentRetrieveRequestConfig(clientUuid = clientUuid, verificationDocumentUuid = verificationDocumentUuid, verifyTypeCode = verifyTypeCode)

        val localVarResponse = request<Unit, VerificationDocument>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentRetrieve
    *
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @return RequestConfig
    */
    fun clientVerificationDocumentRetrieveRequestConfig(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{verification_document_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verification_document_uuid"+"}", "$verificationDocumentUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client verification document
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @param uuid  
    * @param documentType  
    * @param documentFront  
    * @param documentBack  
    * @return VerificationDocument
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentUpdate(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID, documentType: DocumentTypeEnum, documentFront: kotlin.String, documentBack: kotlin.String) : VerificationDocument {
        val localVariableConfig = clientVerificationDocumentUpdateRequestConfig(clientUuid = clientUuid, verificationDocumentUuid = verificationDocumentUuid, verifyTypeCode = verifyTypeCode, uuid = uuid, documentType = documentType, documentFront = documentFront, documentBack = documentBack)

        val localVarResponse = request<Map<String, Any?>, VerificationDocument>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentUpdate
    *
    * @param clientUuid  
    * @param verificationDocumentUuid  
    * @param verifyTypeCode  
    * @param uuid  
    * @param documentType  
    * @param documentFront  
    * @param documentBack  
    * @return RequestConfig
    */
    fun clientVerificationDocumentUpdateRequestConfig(clientUuid: java.util.UUID, verificationDocumentUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID, documentType: DocumentTypeEnum, documentFront: kotlin.String, documentBack: kotlin.String) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "document_type" to documentType, "document_front" to documentFront, "document_back" to documentBack)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{verification_document_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verification_document_uuid"+"}", "$verificationDocumentUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Verification for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedVerificationListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationList(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedVerificationListList {
        val localVariableConfig = clientVerificationListRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedVerificationListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedVerificationListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationList
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientVerificationListRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client verification 
    * @param clientUuid  
    * @param verificationUuid  
    * @param verifyTypeCode  
    * @return VerificationList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationRetrieve(clientUuid: java.util.UUID, verificationUuid: java.util.UUID, verifyTypeCode: kotlin.String) : VerificationList {
        val localVariableConfig = clientVerificationRetrieveRequestConfig(clientUuid = clientUuid, verificationUuid = verificationUuid, verifyTypeCode = verifyTypeCode)

        val localVarResponse = request<Unit, VerificationList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationRetrieve
    *
    * @param clientUuid  
    * @param verificationUuid  
    * @param verifyTypeCode  
    * @return RequestConfig
    */
    fun clientVerificationRetrieveRequestConfig(clientUuid: java.util.UUID, verificationUuid: java.util.UUID, verifyTypeCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/{verification_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verification_uuid"+"}", "$verificationUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
