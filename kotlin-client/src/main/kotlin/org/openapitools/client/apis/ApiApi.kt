/**
 * Nucoro API v2
 *
 * No description
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.AUMEvoluation
import org.openapitools.client.models.AUMPortfolioRisk
import org.openapitools.client.models.AllocationByAsset
import org.openapitools.client.models.AllocationDetail
import org.openapitools.client.models.AllocationList
import org.openapitools.client.models.AssetConcentrationRisk
import org.openapitools.client.models.AssetDetail
import org.openapitools.client.models.Attachment
import org.openapitools.client.models.AuthenticationResponse
import org.openapitools.client.models.ClientRanking
import org.openapitools.client.models.ClientReferral
import org.openapitools.client.models.ConversationCreate
import org.openapitools.client.models.CreateOrder
import org.openapitools.client.models.CurrentAllocation
import org.openapitools.client.models.DepositCreate
import org.openapitools.client.models.DepositDetail
import org.openapitools.client.models.DocTypeEnum
import org.openapitools.client.models.Document
import org.openapitools.client.models.ETSForecastRequest
import org.openapitools.client.models.EmailVerifyRequest
import org.openapitools.client.models.EmailVerifyView
import org.openapitools.client.models.FeedActivityList
import org.openapitools.client.models.ForecastDecumulationRequest
import org.openapitools.client.models.ForecastRequest
import org.openapitools.client.models.Goal
import org.openapitools.client.models.IntradayPrice
import org.openapitools.client.models.InvestorFee
import org.openapitools.client.models.InvestorModelPortfolio
import org.openapitools.client.models.InvestorWithdrawalCreate
import org.openapitools.client.models.InvoiceDetails
import org.openapitools.client.models.InvoiceList
import org.openapitools.client.models.Message
import org.openapitools.client.models.MinimumAppVersion
import org.openapitools.client.models.ModelPortfolioForecastRequest
import org.openapitools.client.models.NucoroSetting
import org.openapitools.client.models.OrderList
import org.openapitools.client.models.PaginatedAccessLogList
import org.openapitools.client.models.PaginatedAllocationListList
import org.openapitools.client.models.PaginatedAssetCategoryList
import org.openapitools.client.models.PaginatedAssetGrowthList
import org.openapitools.client.models.PaginatedAssetListList
import org.openapitools.client.models.PaginatedBasePortfolioTypeRestrictionsList
import org.openapitools.client.models.PaginatedCategoryList
import org.openapitools.client.models.PaginatedConversationListList
import org.openapitools.client.models.PaginatedCoreCategoryGroupList
import org.openapitools.client.models.PaginatedCountryListList
import org.openapitools.client.models.PaginatedDepositListList
import org.openapitools.client.models.PaginatedDocumentList
import org.openapitools.client.models.PaginatedFeedActivityListList
import org.openapitools.client.models.PaginatedGoalList
import org.openapitools.client.models.PaginatedIntradayPriceList
import org.openapitools.client.models.PaginatedInvestorFeeList
import org.openapitools.client.models.PaginatedInvestorModelPortfolioList
import org.openapitools.client.models.PaginatedInvestorWithdrawalListList
import org.openapitools.client.models.PaginatedInvoiceListList
import org.openapitools.client.models.PaginatedMessageList
import org.openapitools.client.models.PaginatedNationalDocumentList
import org.openapitools.client.models.PaginatedOrderListList
import org.openapitools.client.models.PaginatedPortfolioListList
import org.openapitools.client.models.PaginatedPortfolioPerformanceList
import org.openapitools.client.models.PaginatedPortfolioPerformancePositionsList
import org.openapitools.client.models.PaginatedPortfolioTypeList
import org.openapitools.client.models.PaginatedPresetCategoryGroupList
import org.openapitools.client.models.PaginatedPriceList
import org.openapitools.client.models.PaginatedQuestionList
import org.openapitools.client.models.PaginatedRebalanceList
import org.openapitools.client.models.PaginatedStatementList
import org.openapitools.client.models.PaginatedTaxReportList
import org.openapitools.client.models.PaginatedTosList
import org.openapitools.client.models.PaginatedWatchlistList
import org.openapitools.client.models.PatchedGoal
import org.openapitools.client.models.PatchedInvestorFee
import org.openapitools.client.models.PatchedPortfolioUpdate
import org.openapitools.client.models.PortalSettingValueList
import org.openapitools.client.models.PortfolioCreate
import org.openapitools.client.models.PortfolioDetail
import org.openapitools.client.models.PortfolioTypeRestrictions
import org.openapitools.client.models.PortfolioUpdate
import org.openapitools.client.models.Price
import org.openapitools.client.models.Rebalance
import org.openapitools.client.models.RelationshipManager
import org.openapitools.client.models.Response
import org.openapitools.client.models.Statement
import org.openapitools.client.models.Subscribe
import org.openapitools.client.models.TaxReport
import org.openapitools.client.models.Tos
import org.openapitools.client.models.Unsubscribe
import org.openapitools.client.models.Watchlist
import org.openapitools.client.models.WebsocketAuthentication
import org.openapitools.client.models.WithdrawalDetail

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ApiApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
    * @param format  (optional)
    * @param lang  (optional)
    * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiSchemaRetrieve(format: kotlin.String?, lang: kotlin.String?) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVariableConfig = apiSchemaRetrieveRequestConfig(format = format, lang = lang)

        val localVarResponse = request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiSchemaRetrieve
    *
    * @param format  (optional)
    * @param lang  (optional)
    * @return RequestConfig
    */
    fun apiSchemaRetrieveRequestConfig(format: kotlin.String?, lang: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (lang != null) {
                    put("lang", listOf(lang.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/schema/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedCategoryList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesEtsCategoriesList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedCategoryList {
        val localVariableConfig = apiV2AdviceEnginesEtsCategoriesListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedCategoryList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCategoryList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesEtsCategoriesList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesEtsCategoriesListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/advice-engines/ets/categories/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedCoreCategoryGroupList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesEtsCoreCategoryGroupsList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedCoreCategoryGroupList {
        val localVariableConfig = apiV2AdviceEnginesEtsCoreCategoryGroupsListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedCoreCategoryGroupList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCoreCategoryGroupList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesEtsCoreCategoryGroupsList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesEtsCoreCategoryGroupsListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/advice-engines/ets/core-category-groups/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * The forecast positions and amounts for the time_horizon and  risk_level chosen. Taking into account the initial_auto_deposit and the initial_amount jointly with the selected filters.
    * @param etSForecastRequest  
    * @return ETSForecastRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesEtsForecastCreate(etSForecastRequest: ETSForecastRequest) : ETSForecastRequest {
        val localVariableConfig = apiV2AdviceEnginesEtsForecastCreateRequestConfig(etSForecastRequest = etSForecastRequest)

        val localVarResponse = request<ETSForecastRequest, ETSForecastRequest>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ETSForecastRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesEtsForecastCreate
    *
    * @param etSForecastRequest  
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesEtsForecastCreateRequestConfig(etSForecastRequest: ETSForecastRequest) : RequestConfig<ETSForecastRequest> {
        val localVariableBody = etSForecastRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/advice-engines/ets/forecast/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedPresetCategoryGroupList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesEtsPresetCategoryGroupsList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedPresetCategoryGroupList {
        val localVariableConfig = apiV2AdviceEnginesEtsPresetCategoryGroupsListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedPresetCategoryGroupList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPresetCategoryGroupList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesEtsPresetCategoryGroupsList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesEtsPresetCategoryGroupsListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/advice-engines/ets/preset-category-groups/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * The forecast positions and amounts for the time_horizon chosen. Taking into account the initial_auto_deposit and the initial_amount jointly with the selected filters.
    * @param modelPortfolioForecastRequest  
    * @return ModelPortfolioForecastRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesModelPortfolioForecastCreate(modelPortfolioForecastRequest: ModelPortfolioForecastRequest) : ModelPortfolioForecastRequest {
        val localVariableConfig = apiV2AdviceEnginesModelPortfolioForecastCreateRequestConfig(modelPortfolioForecastRequest = modelPortfolioForecastRequest)

        val localVarResponse = request<ModelPortfolioForecastRequest, ModelPortfolioForecastRequest>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelPortfolioForecastRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesModelPortfolioForecastCreate
    *
    * @param modelPortfolioForecastRequest  
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesModelPortfolioForecastCreateRequestConfig(modelPortfolioForecastRequest: ModelPortfolioForecastRequest) : RequestConfig<ModelPortfolioForecastRequest> {
        val localVariableBody = modelPortfolioForecastRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/advice-engines/model-portfolio/forecast/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param extraData Additional ModelPortfolio attributes (optional)
    * @param limit Number of results to return per page. (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param riskHigher  (optional)
    * @param riskLevel  (optional)
    * @param riskLower  (optional)
    * @return PaginatedInvestorModelPortfolioList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesModelPortfolioModelPortfoliosList(extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?, riskHigher: kotlin.Int?, riskLevel: kotlin.Int?, riskLower: kotlin.Int?) : PaginatedInvestorModelPortfolioList {
        val localVariableConfig = apiV2AdviceEnginesModelPortfolioModelPortfoliosListRequestConfig(extraData = extraData, limit = limit, name = name, offset = offset, riskHigher = riskHigher, riskLevel = riskLevel, riskLower = riskLower)

        val localVarResponse = request<Unit, PaginatedInvestorModelPortfolioList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvestorModelPortfolioList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesModelPortfolioModelPortfoliosList
    *
    * @param extraData Additional ModelPortfolio attributes (optional)
    * @param limit Number of results to return per page. (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param riskHigher  (optional)
    * @param riskLevel  (optional)
    * @param riskLower  (optional)
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesModelPortfolioModelPortfoliosListRequestConfig(extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?, riskHigher: kotlin.Int?, riskLevel: kotlin.Int?, riskLower: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (riskHigher != null) {
                    put("risk_higher", listOf(riskHigher.toString()))
                }
                if (riskLevel != null) {
                    put("risk_level", listOf(riskLevel.toString()))
                }
                if (riskLower != null) {
                    put("risk_lower", listOf(riskLower.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/advice-engines/model-portfolio/model-portfolios/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return InvestorModelPortfolio
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve(uuid: java.util.UUID) : InvestorModelPortfolio {
        val localVariableConfig = apiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, InvestorModelPortfolio>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorModelPortfolio
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/advice-engines/model-portfolio/model-portfolios/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve all asset categories
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param type  (optional)
    * @return PaginatedAssetCategoryList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsCategoriesList(limit: kotlin.Int?, offset: kotlin.Int?, type: kotlin.String?) : PaginatedAssetCategoryList {
        val localVariableConfig = apiV2AssetsCategoriesListRequestConfig(limit = limit, offset = offset, type = type)

        val localVarResponse = request<Unit, PaginatedAssetCategoryList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAssetCategoryList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsCategoriesList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param type  (optional)
    * @return RequestConfig
    */
    fun apiV2AssetsCategoriesListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?, type: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/categories/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
    * @param assetIdentifier  
    * @return IntradayPrice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsIntradayPricesLatestRetrieve(assetIdentifier: java.util.UUID) : IntradayPrice {
        val localVariableConfig = apiV2AssetsIntradayPricesLatestRetrieveRequestConfig(assetIdentifier = assetIdentifier)

        val localVarResponse = request<Unit, IntradayPrice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IntradayPrice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsIntradayPricesLatestRetrieve
    *
    * @param assetIdentifier  
    * @return RequestConfig
    */
    fun apiV2AssetsIntradayPricesLatestRetrieveRequestConfig(assetIdentifier: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/{asset_identifier}/intraday-prices/latest/".replace("{"+"asset_identifier"+"}", "$assetIdentifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
    * @param assetIdentifier  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param datetimeAfter  (optional)
    * @param datetimeBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedIntradayPriceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsIntradayPricesList(assetIdentifier: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, datetimeAfter: java.time.OffsetDateTime?, datetimeBefore: java.time.OffsetDateTime?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedIntradayPriceList {
        val localVariableConfig = apiV2AssetsIntradayPricesListRequestConfig(assetIdentifier = assetIdentifier, dateAfter = dateAfter, dateBefore = dateBefore, datetimeAfter = datetimeAfter, datetimeBefore = datetimeBefore, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedIntradayPriceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedIntradayPriceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsIntradayPricesList
    *
    * @param assetIdentifier  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param datetimeAfter  (optional)
    * @param datetimeBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2AssetsIntradayPricesListRequestConfig(assetIdentifier: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, datetimeAfter: java.time.OffsetDateTime?, datetimeBefore: java.time.OffsetDateTime?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (dateAfter != null) {
                    put("date_after", listOf(parseDateToQueryString(dateAfter)))
                }
                if (dateBefore != null) {
                    put("date_before", listOf(parseDateToQueryString(dateBefore)))
                }
                if (datetimeAfter != null) {
                    put("datetime_after", listOf(parseDateToQueryString(datetimeAfter)))
                }
                if (datetimeBefore != null) {
                    put("datetime_before", listOf(parseDateToQueryString(datetimeBefore)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/{asset_identifier}/intraday-prices/".replace("{"+"asset_identifier"+"}", "$assetIdentifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * A list of Assets filtered by category codes. Default is an empty dict which returns the whole universe.
    * @param assetType  (optional)
    * @param categoryCode  (optional)
    * @param categoryType  (optional)
    * @param currency  (optional)
    * @param isin  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param market  (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @param ticker  (optional)
    * @return PaginatedAssetListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsList(assetType: kotlin.String?, categoryCode: kotlin.collections.List<kotlin.String>?, categoryType: kotlin.collections.List<kotlin.String>?, currency: kotlin.Int?, isin: kotlin.String?, limit: kotlin.Int?, market: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?, status: kotlin.String?, ticker: kotlin.String?) : PaginatedAssetListList {
        val localVariableConfig = apiV2AssetsListRequestConfig(assetType = assetType, categoryCode = categoryCode, categoryType = categoryType, currency = currency, isin = isin, limit = limit, market = market, name = name, offset = offset, status = status, ticker = ticker)

        val localVarResponse = request<Unit, PaginatedAssetListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAssetListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsList
    *
    * @param assetType  (optional)
    * @param categoryCode  (optional)
    * @param categoryType  (optional)
    * @param currency  (optional)
    * @param isin  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param market  (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @param ticker  (optional)
    * @return RequestConfig
    */
    fun apiV2AssetsListRequestConfig(assetType: kotlin.String?, categoryCode: kotlin.collections.List<kotlin.String>?, categoryType: kotlin.collections.List<kotlin.String>?, currency: kotlin.Int?, isin: kotlin.String?, limit: kotlin.Int?, market: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?, status: kotlin.String?, ticker: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (assetType != null) {
                    put("asset_type", listOf(assetType.toString()))
                }
                if (categoryCode != null) {
                    put("category_code", toMultiValue(categoryCode.toList(), "multi"))
                }
                if (categoryType != null) {
                    put("category_type", toMultiValue(categoryType.toList(), "multi"))
                }
                if (currency != null) {
                    put("currency", listOf(currency.toString()))
                }
                if (isin != null) {
                    put("isin", listOf(isin.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (market != null) {
                    put("market", listOf(market.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve asset&#39;s yearly performance.  This View overwrites ListAPIView&#39;s &#39;list&#39; method because it doesn&#39;t have any hook that allows us to call &#39;get_asset_price_year_graph after the filtering is applied.
    * @param assetIdentifier  
    * @param dateYearAfter  (optional)
    * @param dateYearBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedAssetGrowthList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsPerformanceList(assetIdentifier: java.util.UUID, dateYearAfter: java.math.BigDecimal?, dateYearBefore: java.math.BigDecimal?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedAssetGrowthList {
        val localVariableConfig = apiV2AssetsPerformanceListRequestConfig(assetIdentifier = assetIdentifier, dateYearAfter = dateYearAfter, dateYearBefore = dateYearBefore, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedAssetGrowthList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAssetGrowthList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsPerformanceList
    *
    * @param assetIdentifier  
    * @param dateYearAfter  (optional)
    * @param dateYearBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2AssetsPerformanceListRequestConfig(assetIdentifier: java.util.UUID, dateYearAfter: java.math.BigDecimal?, dateYearBefore: java.math.BigDecimal?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (dateYearAfter != null) {
                    put("date_year_after", listOf(dateYearAfter.toString()))
                }
                if (dateYearBefore != null) {
                    put("date_year_before", listOf(dateYearBefore.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/{asset_identifier}/performance/".replace("{"+"asset_identifier"+"}", "$assetIdentifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
    * @param assetIdentifier  
    * @return Price
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsPricesLatestRetrieve(assetIdentifier: java.util.UUID) : Price {
        val localVariableConfig = apiV2AssetsPricesLatestRetrieveRequestConfig(assetIdentifier = assetIdentifier)

        val localVarResponse = request<Unit, Price>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Price
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsPricesLatestRetrieve
    *
    * @param assetIdentifier  
    * @return RequestConfig
    */
    fun apiV2AssetsPricesLatestRetrieveRequestConfig(assetIdentifier: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/{asset_identifier}/prices/latest/".replace("{"+"asset_identifier"+"}", "$assetIdentifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
    * @param assetIdentifier  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param datetimeAfter  (optional)
    * @param datetimeBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedPriceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsPricesList(assetIdentifier: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, datetimeAfter: java.time.OffsetDateTime?, datetimeBefore: java.time.OffsetDateTime?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedPriceList {
        val localVariableConfig = apiV2AssetsPricesListRequestConfig(assetIdentifier = assetIdentifier, dateAfter = dateAfter, dateBefore = dateBefore, datetimeAfter = datetimeAfter, datetimeBefore = datetimeBefore, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedPriceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPriceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsPricesList
    *
    * @param assetIdentifier  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param datetimeAfter  (optional)
    * @param datetimeBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2AssetsPricesListRequestConfig(assetIdentifier: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, datetimeAfter: java.time.OffsetDateTime?, datetimeBefore: java.time.OffsetDateTime?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (dateAfter != null) {
                    put("date_after", listOf(parseDateToQueryString(dateAfter)))
                }
                if (dateBefore != null) {
                    put("date_before", listOf(parseDateToQueryString(dateBefore)))
                }
                if (datetimeAfter != null) {
                    put("datetime_after", listOf(parseDateToQueryString(datetimeAfter)))
                }
                if (datetimeBefore != null) {
                    put("datetime_before", listOf(parseDateToQueryString(datetimeBefore)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/{asset_identifier}/prices/".replace("{"+"asset_identifier"+"}", "$assetIdentifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allows get an asset instance by * UUID * ISIN * ISIN &amp; MARKET_CODE * ISIN &amp; MARKET_CODE &amp; CURRENCY_CODE  Examples:     * assets/a66633d7-4418-4c85-9582-01c80df531d4/     * assets/IE00B579F325/     * assets/IE00B579F325_XETR_GBP/     * assets/IE00B579F325_XETR/
    * @param assetIdentifier  
    * @return AssetDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2AssetsRetrieve(assetIdentifier: java.util.UUID) : AssetDetail {
        val localVariableConfig = apiV2AssetsRetrieveRequestConfig(assetIdentifier = assetIdentifier)

        val localVarResponse = request<Unit, AssetDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2AssetsRetrieve
    *
    * @param assetIdentifier  
    * @return RequestConfig
    */
    fun apiV2AssetsRetrieveRequestConfig(assetIdentifier: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/assets/{asset_identifier}/".replace("{"+"asset_identifier"+"}", "$assetIdentifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param dateFrom  (optional)
    * @param dateTo  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return PaginatedInvoiceListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2BillingInvoicesList(dateFrom: java.time.LocalDate?, dateTo: java.time.LocalDate?, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.String?) : PaginatedInvoiceListList {
        val localVariableConfig = apiV2BillingInvoicesListRequestConfig(dateFrom = dateFrom, dateTo = dateTo, limit = limit, offset = offset, status = status)

        val localVarResponse = request<Unit, PaginatedInvoiceListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvoiceListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2BillingInvoicesList
    *
    * @param dateFrom  (optional)
    * @param dateTo  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun apiV2BillingInvoicesListRequestConfig(dateFrom: java.time.LocalDate?, dateTo: java.time.LocalDate?, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (dateFrom != null) {
                    put("date_from", listOf(parseDateToQueryString(dateFrom)))
                }
                if (dateTo != null) {
                    put("date_to", listOf(parseDateToQueryString(dateTo)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/billing/invoices/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param uuid  
    * @param format  (optional)
    * @return InvoiceDetails
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2BillingInvoicesRetrieve(uuid: java.util.UUID, format: kotlin.String?) : InvoiceDetails {
        val localVariableConfig = apiV2BillingInvoicesRetrieveRequestConfig(uuid = uuid, format = format)

        val localVarResponse = request<Unit, InvoiceDetails>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceDetails
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2BillingInvoicesRetrieve
    *
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2BillingInvoicesRetrieveRequestConfig(uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/billing/invoices/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param createOrder  
    * @return CreateOrder
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2BrokerOrdersCreate(portfolioUuid: java.util.UUID, createOrder: CreateOrder) : CreateOrder {
        val localVariableConfig = apiV2BrokerOrdersCreateRequestConfig(portfolioUuid = portfolioUuid, createOrder = createOrder)

        val localVarResponse = request<CreateOrder, CreateOrder>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateOrder
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2BrokerOrdersCreate
    *
    * @param portfolioUuid  
    * @param createOrder  
    * @return RequestConfig
    */
    fun apiV2BrokerOrdersCreateRequestConfig(portfolioUuid: java.util.UUID, createOrder: CreateOrder) : RequestConfig<CreateOrder> {
        val localVariableBody = createOrder
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/broker/orders/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Cancel or request cancellation to the broker
    * @param portfolioUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2BrokerOrdersDestroy(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2BrokerOrdersDestroyRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2BrokerOrdersDestroy
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2BrokerOrdersDestroyRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/broker/orders/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param adviceExternalId  (optional)
    * @param asset  (optional)
    * @param completedAfter  (optional)
    * @param completedBefore  (optional)
    * @param extraData Additional order attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param portfolio  (optional)
    * @param status  (optional)
    * @return PaginatedOrderListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2BrokerOrdersList(portfolioUuid: java.util.UUID, adviceExternalId: kotlin.String?, asset: kotlin.String?, completedAfter: java.time.LocalDate?, completedBefore: java.time.LocalDate?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, portfolio: kotlin.String?, status: kotlin.String?) : PaginatedOrderListList {
        val localVariableConfig = apiV2BrokerOrdersListRequestConfig(portfolioUuid = portfolioUuid, adviceExternalId = adviceExternalId, asset = asset, completedAfter = completedAfter, completedBefore = completedBefore, extraData = extraData, limit = limit, offset = offset, portfolio = portfolio, status = status)

        val localVarResponse = request<Unit, PaginatedOrderListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedOrderListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2BrokerOrdersList
    *
    * @param portfolioUuid  
    * @param adviceExternalId  (optional)
    * @param asset  (optional)
    * @param completedAfter  (optional)
    * @param completedBefore  (optional)
    * @param extraData Additional order attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param portfolio  (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun apiV2BrokerOrdersListRequestConfig(portfolioUuid: java.util.UUID, adviceExternalId: kotlin.String?, asset: kotlin.String?, completedAfter: java.time.LocalDate?, completedBefore: java.time.LocalDate?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, portfolio: kotlin.String?, status: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (adviceExternalId != null) {
                    put("advice_external_id", listOf(adviceExternalId.toString()))
                }
                if (asset != null) {
                    put("asset", listOf(asset.toString()))
                }
                if (completedAfter != null) {
                    put("completed_after", listOf(parseDateToQueryString(completedAfter)))
                }
                if (completedBefore != null) {
                    put("completed_before", listOf(parseDateToQueryString(completedBefore)))
                }
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (portfolio != null) {
                    put("portfolio", listOf(portfolio.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/broker/orders/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return OrderList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2BrokerOrdersRetrieve(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : OrderList {
        val localVariableConfig = apiV2BrokerOrdersRetrieveRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, OrderList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2BrokerOrdersRetrieve
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2BrokerOrdersRetrieveRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/broker/orders/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return PaginatedFeedActivityListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsActivitiesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : PaginatedFeedActivityListList {
        val localVariableConfig = apiV2ClientsActivitiesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset, target = target)

        val localVarResponse = request<Unit, PaginatedFeedActivityListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedFeedActivityListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsActivitiesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsActivitiesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (target != null) {
                    put("target", toMultiValue(target.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/activities/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return FeedActivityList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsActivitiesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : FeedActivityList {
        val localVariableConfig = apiV2ClientsActivitiesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, FeedActivityList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeedActivityList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsActivitiesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsActivitiesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/activities/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsAdviceEnginesList(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsAdviceEnginesListRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsAdviceEnginesList
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsAdviceEnginesListRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/advice-engines/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsAdviceEnginesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsAdviceEnginesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsAdviceEnginesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsAdviceEnginesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/advice-engines/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param investorFee  
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesCreate(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, investorFee: InvestorFee) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesCreateRequestConfig(clientUuid = clientUuid, investorFeeUuid = investorFeeUuid, investorFee = investorFee)

        val localVarResponse = request<InvestorFee, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesCreate
    *
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param investorFee  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesCreateRequestConfig(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, investorFee: InvestorFee) : RequestConfig<InvestorFee> {
        val localVariableBody = investorFee
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/billing/fees/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"investor_fee_uuid"+"}", "$investorFeeUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFeeUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesDestroy(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsBillingFeesDestroyRequestConfig(clientUuid = clientUuid, investorFeeUuid = investorFeeUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesDestroy
    *
    * @param clientUuid  
    * @param investorFeeUuid  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesDestroyRequestConfig(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{investor_fee_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"investor_fee_uuid"+"}", "$investorFeeUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedInvestorFeeList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesList(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedInvestorFeeList {
        val localVariableConfig = apiV2ClientsBillingFeesListRequestConfig(clientUuid = clientUuid, investorFeeUuid = investorFeeUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedInvestorFeeList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvestorFeeList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesList
    *
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesListRequestConfig(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/fees/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"investor_fee_uuid"+"}", "$investorFeeUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param patchedInvestorFee  (optional)
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesPartialUpdate(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, patchedInvestorFee: PatchedInvestorFee?) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesPartialUpdateRequestConfig(clientUuid = clientUuid, investorFeeUuid = investorFeeUuid, patchedInvestorFee = patchedInvestorFee)

        val localVarResponse = request<PatchedInvestorFee, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesPartialUpdate
    *
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param patchedInvestorFee  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesPartialUpdateRequestConfig(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, patchedInvestorFee: PatchedInvestorFee?) : RequestConfig<PatchedInvestorFee> {
        val localVariableBody = patchedInvestorFee
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{investor_fee_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"investor_fee_uuid"+"}", "$investorFeeUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFeeUuid  
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesRetrieve(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesRetrieveRequestConfig(clientUuid = clientUuid, investorFeeUuid = investorFeeUuid)

        val localVarResponse = request<Unit, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesRetrieve
    *
    * @param clientUuid  
    * @param investorFeeUuid  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesRetrieveRequestConfig(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{investor_fee_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"investor_fee_uuid"+"}", "$investorFeeUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param investorFee  
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesUpdate(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, investorFee: InvestorFee) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesUpdateRequestConfig(clientUuid = clientUuid, investorFeeUuid = investorFeeUuid, investorFee = investorFee)

        val localVarResponse = request<InvestorFee, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesUpdate
    *
    * @param clientUuid  
    * @param investorFeeUuid  
    * @param investorFee  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesUpdateRequestConfig(clientUuid: java.util.UUID, investorFeeUuid: java.util.UUID, investorFee: InvestorFee) : RequestConfig<InvestorFee> {
        val localVariableBody = investorFee
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{investor_fee_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"investor_fee_uuid"+"}", "$investorFeeUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedInvoiceListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingInvoicesList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedInvoiceListList {
        val localVariableConfig = apiV2ClientsBillingInvoicesListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedInvoiceListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvoiceListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingInvoicesList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingInvoicesListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/invoices/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return InvoiceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingInvoicesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : InvoiceList {
        val localVariableConfig = apiV2ClientsBillingInvoicesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, InvoiceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingInvoicesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingInvoicesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/invoices/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Uploads a document for a certain user.  This call expects the files and parameters being sent as form/multipart encoding.
    * @param clientUuid  
    * @param uuid  
    * @param name  
    * @param docType  
    * @param path  
    * @param description  (optional)
    * @return Document
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsDocumentsCreate(clientUuid: java.util.UUID, uuid: java.util.UUID, name: kotlin.String, docType: DocTypeEnum, path: java.net.URI, description: kotlin.String?) : Document {
        val localVariableConfig = apiV2ClientsDocumentsCreateRequestConfig(clientUuid = clientUuid, uuid = uuid, name = name, docType = docType, path = path, description = description)

        val localVarResponse = request<Map<String, Any?>, Document>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Document
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsDocumentsCreate
    *
    * @param clientUuid  
    * @param uuid  
    * @param name  
    * @param docType  
    * @param path  
    * @param description  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsDocumentsCreateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, name: kotlin.String, docType: DocTypeEnum, path: java.net.URI, description: kotlin.String?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "name" to name, "doc_type" to docType, "description" to description, "path" to path)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsDocumentsDestroy(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsDocumentsDestroyRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsDocumentsDestroy
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsDocumentsDestroyRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param client  (optional)
    * @param description  (optional)
    * @param docType  (optional)
    * @param extraData Additional document attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedDocumentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsDocumentsList(clientUuid: java.util.UUID, client: kotlin.Int?, description: kotlin.String?, docType: kotlin.collections.List<kotlin.String>?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?) : PaginatedDocumentList {
        val localVariableConfig = apiV2ClientsDocumentsListRequestConfig(clientUuid = clientUuid, client = client, description = description, docType = docType, extraData = extraData, limit = limit, name = name, offset = offset)

        val localVarResponse = request<Unit, PaginatedDocumentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDocumentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsDocumentsList
    *
    * @param clientUuid  
    * @param client  (optional)
    * @param description  (optional)
    * @param docType  (optional)
    * @param extraData Additional document attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsDocumentsListRequestConfig(clientUuid: java.util.UUID, client: kotlin.Int?, description: kotlin.String?, docType: kotlin.collections.List<kotlin.String>?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (client != null) {
                    put("client", listOf(client.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (docType != null) {
                    put("doc_type", toMultiValue(docType.toList(), "multi"))
                }
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return Document
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsDocumentsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : Document {
        val localVariableConfig = apiV2ClientsDocumentsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Document>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Document
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsDocumentsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsDocumentsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Request e-mail account verification notification.
    * @param emailVerifyRequest  (optional)
    * @return EmailVerifyRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsMeVerifyEmailCreate(emailVerifyRequest: EmailVerifyRequest?) : EmailVerifyRequest {
        val localVariableConfig = apiV2ClientsMeVerifyEmailCreateRequestConfig(emailVerifyRequest = emailVerifyRequest)

        val localVarResponse = request<EmailVerifyRequest, EmailVerifyRequest>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmailVerifyRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsMeVerifyEmailCreate
    *
    * @param emailVerifyRequest  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsMeVerifyEmailCreateRequestConfig(emailVerifyRequest: EmailVerifyRequest?) : RequestConfig<EmailVerifyRequest> {
        val localVariableBody = emailVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/me/verify/email/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedNationalDocumentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsNationalDocumentsList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedNationalDocumentList {
        val localVariableConfig = apiV2ClientsNationalDocumentsListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedNationalDocumentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNationalDocumentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsNationalDocumentsList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsNationalDocumentsListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/national_documents/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieves the currently logged in client referral code
    * @param referralCode  
    * @return ClientReferral
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReferralRetrieve(referralCode: kotlin.String) : ClientReferral {
        val localVariableConfig = apiV2ClientsReferralRetrieveRequestConfig(referralCode = referralCode)

        val localVarResponse = request<Unit, ClientReferral>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientReferral
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReferralRetrieve
    *
    * @param referralCode  
    * @return RequestConfig
    */
    fun apiV2ClientsReferralRetrieveRequestConfig(referralCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/referral/{referral_code}/".replace("{"+"referral_code"+"}", "$referralCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedStatementList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportStatementsList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedStatementList {
        val localVariableConfig = apiV2ClientsReportStatementsListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedStatementList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStatementList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportStatementsList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportStatementsListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/statements/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return Statement
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportStatementsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : Statement {
        val localVariableConfig = apiV2ClientsReportStatementsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, Statement>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Statement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportStatementsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportStatementsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/statements/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTaxReportList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportTaxReportsList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTaxReportList {
        val localVariableConfig = apiV2ClientsReportTaxReportsListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTaxReportList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTaxReportList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportTaxReportsList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportTaxReportsListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/tax-reports/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return TaxReport
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportTaxReportsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : TaxReport {
        val localVariableConfig = apiV2ClientsReportTaxReportsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, TaxReport>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxReport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportTaxReportsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportTaxReportsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/tax-reports/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Verify e-mail account with the given email token.
    * @param uuid  
    * @param emailVerifyView  
    * @return EmailVerifyView
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsVerifyEmailUpdate(uuid: java.util.UUID, emailVerifyView: EmailVerifyView) : EmailVerifyView {
        val localVariableConfig = apiV2ClientsVerifyEmailUpdateRequestConfig(uuid = uuid, emailVerifyView = emailVerifyView)

        val localVarResponse = request<EmailVerifyView, EmailVerifyView>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmailVerifyView
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsVerifyEmailUpdate
    *
    * @param uuid  
    * @param emailVerifyView  
    * @return RequestConfig
    */
    fun apiV2ClientsVerifyEmailUpdateRequestConfig(uuid: java.util.UUID, emailVerifyView: EmailVerifyView) : RequestConfig<EmailVerifyView> {
        val localVariableBody = emailVerifyView
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{uuid}/verify/email/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param watchlistUuid  
    * @param watchlist  
    * @return Watchlist
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsCreate(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID, watchlist: Watchlist) : Watchlist {
        val localVariableConfig = apiV2ClientsWatchlistsCreateRequestConfig(clientUuid = clientUuid, watchlistUuid = watchlistUuid, watchlist = watchlist)

        val localVarResponse = request<Watchlist, Watchlist>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Watchlist
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsCreate
    *
    * @param clientUuid  
    * @param watchlistUuid  
    * @param watchlist  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsCreateRequestConfig(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID, watchlist: Watchlist) : RequestConfig<Watchlist> {
        val localVariableBody = watchlist
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/watchlists/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"watchlist_uuid"+"}", "$watchlistUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param watchlistUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsDestroy(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsWatchlistsDestroyRequestConfig(clientUuid = clientUuid, watchlistUuid = watchlistUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsDestroy
    *
    * @param clientUuid  
    * @param watchlistUuid  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsDestroyRequestConfig(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/watchlists/{watchlist_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"watchlist_uuid"+"}", "$watchlistUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param watchlistUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedWatchlistList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsList(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedWatchlistList {
        val localVariableConfig = apiV2ClientsWatchlistsListRequestConfig(clientUuid = clientUuid, watchlistUuid = watchlistUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedWatchlistList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedWatchlistList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsList
    *
    * @param clientUuid  
    * @param watchlistUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsListRequestConfig(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/watchlists/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"watchlist_uuid"+"}", "$watchlistUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param watchlistUuid  
    * @return Watchlist
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsRetrieve(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID) : Watchlist {
        val localVariableConfig = apiV2ClientsWatchlistsRetrieveRequestConfig(clientUuid = clientUuid, watchlistUuid = watchlistUuid)

        val localVarResponse = request<Unit, Watchlist>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Watchlist
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsRetrieve
    *
    * @param clientUuid  
    * @param watchlistUuid  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsRetrieveRequestConfig(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/watchlists/{watchlist_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"watchlist_uuid"+"}", "$watchlistUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param watchlistUuid  
    * @param watchlist  
    * @return Watchlist
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsUpdate(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID, watchlist: Watchlist) : Watchlist {
        val localVariableConfig = apiV2ClientsWatchlistsUpdateRequestConfig(clientUuid = clientUuid, watchlistUuid = watchlistUuid, watchlist = watchlist)

        val localVarResponse = request<Watchlist, Watchlist>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Watchlist
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsUpdate
    *
    * @param clientUuid  
    * @param watchlistUuid  
    * @param watchlist  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsUpdateRequestConfig(clientUuid: java.util.UUID, watchlistUuid: java.util.UUID, watchlist: Watchlist) : RequestConfig<Watchlist> {
        val localVariableBody = watchlist
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/watchlists/{watchlist_uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"watchlist_uuid"+"}", "$watchlistUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieves the latest access to the client&#39;s account
    * @param browser  (optional)
    * @param browserVersion  (optional)
    * @param channel  (optional)
    * @param city  (optional)
    * @param country  (optional)
    * @param deviceBrand  (optional)
    * @param deviceModel  (optional)
    * @param ipAddress  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param os  (optional)
    * @param osVersion  (optional)
    * @param userAgent  (optional)
    * @return PaginatedAccessLogList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2FeedsAccessLogsList(browser: kotlin.String?, browserVersion: kotlin.String?, channel: kotlin.String?, city: kotlin.String?, country: kotlin.Int?, deviceBrand: kotlin.String?, deviceModel: kotlin.String?, ipAddress: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, os: kotlin.String?, osVersion: kotlin.String?, userAgent: kotlin.String?) : PaginatedAccessLogList {
        val localVariableConfig = apiV2FeedsAccessLogsListRequestConfig(browser = browser, browserVersion = browserVersion, channel = channel, city = city, country = country, deviceBrand = deviceBrand, deviceModel = deviceModel, ipAddress = ipAddress, limit = limit, offset = offset, os = os, osVersion = osVersion, userAgent = userAgent)

        val localVarResponse = request<Unit, PaginatedAccessLogList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAccessLogList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2FeedsAccessLogsList
    *
    * @param browser  (optional)
    * @param browserVersion  (optional)
    * @param channel  (optional)
    * @param city  (optional)
    * @param country  (optional)
    * @param deviceBrand  (optional)
    * @param deviceModel  (optional)
    * @param ipAddress  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param os  (optional)
    * @param osVersion  (optional)
    * @param userAgent  (optional)
    * @return RequestConfig
    */
    fun apiV2FeedsAccessLogsListRequestConfig(browser: kotlin.String?, browserVersion: kotlin.String?, channel: kotlin.String?, city: kotlin.String?, country: kotlin.Int?, deviceBrand: kotlin.String?, deviceModel: kotlin.String?, ipAddress: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, os: kotlin.String?, osVersion: kotlin.String?, userAgent: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (browser != null) {
                    put("browser", listOf(browser.toString()))
                }
                if (browserVersion != null) {
                    put("browser_version", listOf(browserVersion.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (deviceBrand != null) {
                    put("device_brand", listOf(deviceBrand.toString()))
                }
                if (deviceModel != null) {
                    put("device_model", listOf(deviceModel.toString()))
                }
                if (ipAddress != null) {
                    put("ip_address", listOf(ipAddress.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (os != null) {
                    put("os", listOf(os.toString()))
                }
                if (osVersion != null) {
                    put("os_version", listOf(osVersion.toString()))
                }
                if (userAgent != null) {
                    put("user_agent", listOf(userAgent.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/feeds/access-logs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return PaginatedFeedActivityListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2FeedsActivitiesList(limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : PaginatedFeedActivityListList {
        val localVariableConfig = apiV2FeedsActivitiesListRequestConfig(limit = limit, offset = offset, target = target)

        val localVarResponse = request<Unit, PaginatedFeedActivityListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedFeedActivityListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2FeedsActivitiesList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return RequestConfig
    */
    fun apiV2FeedsActivitiesListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (target != null) {
                    put("target", toMultiValue(target.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/feeds/activities/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param goalUuid  
    * @param goal  
    * @return Goal
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsCreate(goalUuid: java.util.UUID, goal: Goal) : Goal {
        val localVariableConfig = apiV2GoalsCreateRequestConfig(goalUuid = goalUuid, goal = goal)

        val localVarResponse = request<Goal, Goal>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Goal
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsCreate
    *
    * @param goalUuid  
    * @param goal  
    * @return RequestConfig
    */
    fun apiV2GoalsCreateRequestConfig(goalUuid: java.util.UUID, goal: Goal) : RequestConfig<Goal> {
        val localVariableBody = goal
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/goals/".replace("{"+"goal_uuid"+"}", "$goalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Return a Goal Forecast Decumulation
    * @param forecastDecumulationRequest  
    * @return ForecastDecumulationRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsDecumulationCreate(forecastDecumulationRequest: ForecastDecumulationRequest) : ForecastDecumulationRequest {
        val localVariableConfig = apiV2GoalsDecumulationCreateRequestConfig(forecastDecumulationRequest = forecastDecumulationRequest)

        val localVarResponse = request<ForecastDecumulationRequest, ForecastDecumulationRequest>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ForecastDecumulationRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsDecumulationCreate
    *
    * @param forecastDecumulationRequest  
    * @return RequestConfig
    */
    fun apiV2GoalsDecumulationCreateRequestConfig(forecastDecumulationRequest: ForecastDecumulationRequest) : RequestConfig<ForecastDecumulationRequest> {
        val localVariableBody = forecastDecumulationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/goals/decumulation/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param goalUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsDestroy(goalUuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2GoalsDestroyRequestConfig(goalUuid = goalUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsDestroy
    *
    * @param goalUuid  
    * @return RequestConfig
    */
    fun apiV2GoalsDestroyRequestConfig(goalUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/goals/{goal_uuid}/".replace("{"+"goal_uuid"+"}", "$goalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Return a Goal Forecast
    * @param forecastRequest  
    * @return ForecastRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsForecastCreate(forecastRequest: ForecastRequest) : ForecastRequest {
        val localVariableConfig = apiV2GoalsForecastCreateRequestConfig(forecastRequest = forecastRequest)

        val localVarResponse = request<ForecastRequest, ForecastRequest>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ForecastRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsForecastCreate
    *
    * @param forecastRequest  
    * @return RequestConfig
    */
    fun apiV2GoalsForecastCreateRequestConfig(forecastRequest: ForecastRequest) : RequestConfig<ForecastRequest> {
        val localVariableBody = forecastRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/goals/forecast/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param goalUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedGoalList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsList(goalUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedGoalList {
        val localVariableConfig = apiV2GoalsListRequestConfig(goalUuid = goalUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedGoalList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedGoalList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsList
    *
    * @param goalUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2GoalsListRequestConfig(goalUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/goals/".replace("{"+"goal_uuid"+"}", "$goalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param goalUuid  
    * @param patchedGoal  (optional)
    * @return Goal
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsPartialUpdate(goalUuid: java.util.UUID, patchedGoal: PatchedGoal?) : Goal {
        val localVariableConfig = apiV2GoalsPartialUpdateRequestConfig(goalUuid = goalUuid, patchedGoal = patchedGoal)

        val localVarResponse = request<PatchedGoal, Goal>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Goal
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsPartialUpdate
    *
    * @param goalUuid  
    * @param patchedGoal  (optional)
    * @return RequestConfig
    */
    fun apiV2GoalsPartialUpdateRequestConfig(goalUuid: java.util.UUID, patchedGoal: PatchedGoal?) : RequestConfig<PatchedGoal> {
        val localVariableBody = patchedGoal
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/goals/{goal_uuid}/".replace("{"+"goal_uuid"+"}", "$goalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param goalUuid  
    * @return Goal
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2GoalsRetrieve(goalUuid: java.util.UUID) : Goal {
        val localVariableConfig = apiV2GoalsRetrieveRequestConfig(goalUuid = goalUuid)

        val localVarResponse = request<Unit, Goal>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Goal
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2GoalsRetrieve
    *
    * @param goalUuid  
    * @return RequestConfig
    */
    fun apiV2GoalsRetrieveRequestConfig(goalUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/goals/{goal_uuid}/".replace("{"+"goal_uuid"+"}", "$goalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * get: List all conversations with last_message of a user  post: Create new conversation with N messages (without attachments)
    * @param uuid  
    * @param portal  
    * @param created  
    * @param subject  
    * @param messages  (optional)
    * @return ConversationCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InboxConversationsCreate(uuid: java.util.UUID, portal: kotlin.Int, created: java.time.OffsetDateTime, subject: kotlin.String, messages: Message?) : ConversationCreate {
        val localVariableConfig = apiV2InboxConversationsCreateRequestConfig(uuid = uuid, portal = portal, created = created, subject = subject, messages = messages)

        val localVarResponse = request<Map<String, Any?>, ConversationCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2InboxConversationsCreate
    *
    * @param uuid  
    * @param portal  
    * @param created  
    * @param subject  
    * @param messages  (optional)
    * @return RequestConfig
    */
    fun apiV2InboxConversationsCreateRequestConfig(uuid: java.util.UUID, portal: kotlin.Int, created: java.time.OffsetDateTime, subject: kotlin.String, messages: Message?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "portal" to portal, "created" to created, "subject" to subject, "messages" to messages)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/inbox/conversations/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * get: List all conversations with last_message of a user  post: Create new conversation with N messages (without attachments)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedConversationListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InboxConversationsList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedConversationListList {
        val localVariableConfig = apiV2InboxConversationsListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedConversationListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedConversationListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2InboxConversationsList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2InboxConversationsListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/inbox/conversations/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List all messages from a conversation uuid
    * @param conversation  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedMessageList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InboxConversationsList2(conversation: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedMessageList {
        val localVariableConfig = apiV2InboxConversationsList2RequestConfig(conversation = conversation, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedMessageList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedMessageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2InboxConversationsList2
    *
    * @param conversation  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2InboxConversationsList2RequestConfig(conversation: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/inbox/conversations/{conversation}/".replace("{"+"conversation"+"}", "$conversation"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * View to access to an attachment
    * @param conversation  
    * @param message  
    * @param uuid  
    * @param format  (optional)
    * @return Attachment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InboxConversationsMessagesAttachmentsRetrieve(conversation: java.util.UUID, message: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : Attachment {
        val localVariableConfig = apiV2InboxConversationsMessagesAttachmentsRetrieveRequestConfig(conversation = conversation, message = message, uuid = uuid, format = format)

        val localVarResponse = request<Unit, Attachment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Attachment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2InboxConversationsMessagesAttachmentsRetrieve
    *
    * @param conversation  
    * @param message  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2InboxConversationsMessagesAttachmentsRetrieveRequestConfig(conversation: java.util.UUID, message: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/inbox/conversations/{conversation}/messages/{message}/attachments/{uuid}/".replace("{"+"conversation"+"}", "$conversation").replace("{"+"message"+"}", "$message").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * View for creating message on a specific conversation
    * @param conversation  
    * @param user  
    * @param readDate  
    * @param created  
    * @param attachments  
    * @param uuid  
    * @param content  (optional)
    * @return Message
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InboxConversationsMessagesCreate(conversation: java.util.UUID, user: kotlin.String, readDate: java.time.OffsetDateTime, created: java.time.OffsetDateTime, attachments: kotlin.collections.List<Attachment>, uuid: java.util.UUID, content: kotlin.String?) : Message {
        val localVariableConfig = apiV2InboxConversationsMessagesCreateRequestConfig(conversation = conversation, user = user, readDate = readDate, created = created, attachments = attachments, uuid = uuid, content = content)

        val localVarResponse = request<Map<String, Any?>, Message>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Message
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2InboxConversationsMessagesCreate
    *
    * @param conversation  
    * @param user  
    * @param readDate  
    * @param created  
    * @param attachments  
    * @param uuid  
    * @param content  (optional)
    * @return RequestConfig
    */
    fun apiV2InboxConversationsMessagesCreateRequestConfig(conversation: java.util.UUID, user: kotlin.String, readDate: java.time.OffsetDateTime, created: java.time.OffsetDateTime, attachments: kotlin.collections.List<Attachment>, uuid: java.util.UUID, content: kotlin.String?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("user" to user, "read_date" to readDate, "content" to content, "created" to created, "attachments" to attachments, "uuid" to uuid)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/inbox/conversations/{conversation}/messages/".replace("{"+"conversation"+"}", "$conversation"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Returns the number of the last required APP Version for a platform.
    * @param platform  
    * @return MinimumAppVersion
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2MobileVersionRetrieve(platform: kotlin.String) : MinimumAppVersion {
        val localVariableConfig = apiV2MobileVersionRetrieveRequestConfig(platform = platform)

        val localVarResponse = request<Unit, MinimumAppVersion>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MinimumAppVersion
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2MobileVersionRetrieve
    *
    * @param platform  
    * @return RequestConfig
    */
    fun apiV2MobileVersionRetrieveRequestConfig(platform: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/mobile/{platform}/version/".replace("{"+"platform"+"}", "$platform"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return kotlin.collections.List<NucoroSetting>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PlatformSettingsList() : kotlin.collections.List<NucoroSetting> {
        val localVariableConfig = apiV2PlatformSettingsListRequestConfig()

        val localVarResponse = request<Unit, kotlin.collections.List<NucoroSetting>>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<NucoroSetting>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PlatformSettingsList
    *
    * @return RequestConfig
    */
    fun apiV2PlatformSettingsListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/platform/settings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieves the list of countries
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedCountryListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortalCountriesList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedCountryListList {
        val localVariableConfig = apiV2PortalCountriesListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedCountryListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCountryListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortalCountriesList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortalCountriesListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portal/countries/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return PortalSettingValueList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortalSettingsRetrieve() : PortalSettingValueList {
        val localVariableConfig = apiV2PortalSettingsRetrieveRequestConfig()

        val localVarResponse = request<Unit, PortalSettingValueList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortalSettingValueList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortalSettingsRetrieve
    *
    * @return RequestConfig
    */
    fun apiV2PortalSettingsRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portal/settings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieves the current ToS for the Portal
    * @return Tos
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortalTosCurrentRetrieve() : Tos {
        val localVariableConfig = apiV2PortalTosCurrentRetrieveRequestConfig()

        val localVarResponse = request<Unit, Tos>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tos
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortalTosCurrentRetrieve
    *
    * @return RequestConfig
    */
    fun apiV2PortalTosCurrentRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portal/tos/current/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List all ToS for the current Portal
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTosList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortalTosList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTosList {
        val localVariableConfig = apiV2PortalTosListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTosList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTosList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortalTosList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortalTosListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portal/tos/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieves a specific ToS
    * @param uuid  
    * @return Tos
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortalTosRetrieve(uuid: java.util.UUID) : Tos {
        val localVariableConfig = apiV2PortalTosRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, Tos>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tos
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortalTosRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortalTosRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portal/tos/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return PaginatedFeedActivityListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosActivitiesList(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : PaginatedFeedActivityListList {
        val localVariableConfig = apiV2PortfoliosActivitiesListRequestConfig(portfolioUuid = portfolioUuid, limit = limit, offset = offset, target = target)

        val localVarResponse = request<Unit, PaginatedFeedActivityListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedFeedActivityListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosActivitiesList
    *
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosActivitiesListRequestConfig(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (target != null) {
                    put("target", toMultiValue(target.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/activities/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return FeedActivityList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosActivitiesRetrieve(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : FeedActivityList {
        val localVariableConfig = apiV2PortfoliosActivitiesRetrieveRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, FeedActivityList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeedActivityList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosActivitiesRetrieve
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosActivitiesRetrieveRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/activities/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @return AllocationList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsEndDay(portfolioUuid: java.util.UUID) : AllocationList {
        val localVariableConfig = apiV2PortfoliosAllocationsEndDayRequestConfig(portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, AllocationList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AllocationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsEndDay
    *
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsEndDayRequestConfig(portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param allocationDate  
    * @param portfolioUuid  
    * @return AllocationDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsEndDayByDateRetrieve(allocationDate: kotlin.String, portfolioUuid: java.util.UUID) : AllocationDetail {
        val localVariableConfig = apiV2PortfoliosAllocationsEndDayByDateRetrieveRequestConfig(allocationDate = allocationDate, portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, AllocationDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AllocationDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsEndDayByDateRetrieve
    *
    * @param allocationDate  
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsEndDayByDateRetrieveRequestConfig(allocationDate: kotlin.String, portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/{allocation_date}/".replace("{"+"allocation_date"+"}", "$allocationDate").replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @return AllocationDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsEndDayLatestRetrieve(portfolioUuid: java.util.UUID) : AllocationDetail {
        val localVariableConfig = apiV2PortfoliosAllocationsEndDayLatestRetrieveRequestConfig(portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, AllocationDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AllocationDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsEndDayLatestRetrieve
    *
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsEndDayLatestRetrieveRequestConfig(portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/latest/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allocations History for a given portfolio  It accepts two optional parameters, &#x60;date_to&#x60; and &#x60;date_from&#x60; to limit the daily allocations to a certain data range. If they are not given, all the allocations are returned.  ---  ## Parameters:   * **name**: &#x60;date_from&#x60;  * **description**: The initial date.  * **parameter type**: query param   * **name**: &#x60;date_from&#x60;  * **description**: The final date.  * **parameter type**: query param
    * @param portfolio  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsHistoryRetrieve(portfolio: java.util.UUID) : Unit {
        val localVariableConfig = apiV2PortfoliosAllocationsHistoryRetrieveRequestConfig(portfolio = portfolio)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsHistoryRetrieve
    *
    * @param portfolio  
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsHistoryRetrieveRequestConfig(portfolio: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio}/allocations/history/".replace("{"+"portfolio"+"}", "$portfolio"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @return CurrentAllocation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsIntradayLatestRetrieve(portfolioUuid: java.util.UUID) : CurrentAllocation {
        val localVariableConfig = apiV2PortfoliosAllocationsIntradayLatestRetrieveRequestConfig(portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, CurrentAllocation>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentAllocation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsIntradayLatestRetrieve
    *
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsIntradayLatestRetrieveRequestConfig(portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/allocations/intraday/latest/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param valuationDateAfter  (optional)
    * @param valuationDateBefore  (optional)
    * @return PaginatedAllocationListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsList(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, valuationDateAfter: java.time.LocalDate?, valuationDateBefore: java.time.LocalDate?) : PaginatedAllocationListList {
        val localVariableConfig = apiV2PortfoliosAllocationsListRequestConfig(portfolioUuid = portfolioUuid, limit = limit, offset = offset, valuationDateAfter = valuationDateAfter, valuationDateBefore = valuationDateBefore)

        val localVarResponse = request<Unit, PaginatedAllocationListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAllocationListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsList
    *
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param valuationDateAfter  (optional)
    * @param valuationDateBefore  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsListRequestConfig(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, valuationDateAfter: java.time.LocalDate?, valuationDateBefore: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (valuationDateAfter != null) {
                    put("valuation_date_after", listOf(parseDateToQueryString(valuationDateAfter)))
                }
                if (valuationDateBefore != null) {
                    put("valuation_date_before", listOf(parseDateToQueryString(valuationDateBefore)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/allocations/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param id A unique integer value identifying this allocation. 
    * @param portfolioUuid  
    * @return AllocationList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosAllocationsRetrieve(id: kotlin.Int, portfolioUuid: java.util.UUID) : AllocationList {
        val localVariableConfig = apiV2PortfoliosAllocationsRetrieveRequestConfig(id = id, portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, AllocationList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AllocationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosAllocationsRetrieve
    *
    * @param id A unique integer value identifying this allocation. 
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosAllocationsRetrieveRequestConfig(id: kotlin.Int, portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/allocations/{id}/".replace("{"+"id"+"}", "$id").replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @param portfolioCreate  
    * @return PortfolioCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosCreate(portfolioUuid: java.util.UUID, portfolioCreate: PortfolioCreate) : PortfolioCreate {
        val localVariableConfig = apiV2PortfoliosCreateRequestConfig(portfolioUuid = portfolioUuid, portfolioCreate = portfolioCreate)

        val localVarResponse = request<PortfolioCreate, PortfolioCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortfolioCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosCreate
    *
    * @param portfolioUuid  
    * @param portfolioCreate  
    * @return RequestConfig
    */
    fun apiV2PortfoliosCreateRequestConfig(portfolioUuid: java.util.UUID, portfolioCreate: PortfolioCreate) : RequestConfig<PortfolioCreate> {
        val localVariableBody = portfolioCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/portfolios/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param depositCreate  
    * @return DepositCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosDepositsCreate(portfolioUuid: java.util.UUID, depositCreate: DepositCreate) : DepositCreate {
        val localVariableConfig = apiV2PortfoliosDepositsCreateRequestConfig(portfolioUuid = portfolioUuid, depositCreate = depositCreate)

        val localVarResponse = request<DepositCreate, DepositCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DepositCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosDepositsCreate
    *
    * @param portfolioUuid  
    * @param depositCreate  
    * @return RequestConfig
    */
    fun apiV2PortfoliosDepositsCreateRequestConfig(portfolioUuid: java.util.UUID, depositCreate: DepositCreate) : RequestConfig<DepositCreate> {
        val localVariableBody = depositCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/portfolios/{portfolio_uuid}/deposits/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosDepositsDestroy(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2PortfoliosDepositsDestroyRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosDepositsDestroy
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosDepositsDestroyRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/portfolios/{portfolio_uuid}/deposits/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return PaginatedDepositListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosDepositsList(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : PaginatedDepositListList {
        val localVariableConfig = apiV2PortfoliosDepositsListRequestConfig(portfolioUuid = portfolioUuid, limit = limit, offset = offset, status = status)

        val localVarResponse = request<Unit, PaginatedDepositListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDepositListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosDepositsList
    *
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosDepositsListRequestConfig(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", toMultiValue(status.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/deposits/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return DepositDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosDepositsRetrieve(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : DepositDetail {
        val localVariableConfig = apiV2PortfoliosDepositsRetrieveRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, DepositDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DepositDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosDepositsRetrieve
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosDepositsRetrieveRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/deposits/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosDestroy(portfolioUuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2PortfoliosDestroyRequestConfig(portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosDestroy
    *
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosDestroyRequestConfig(portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/portfolios/{portfolio_uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @param externalCustodianId  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @param valuationDateAfter  (optional)
    * @param valuationDateBefore  (optional)
    * @return PaginatedPortfolioListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosList(portfolioUuid: java.util.UUID, externalCustodianId: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?, valuationDateAfter: java.time.LocalDate?, valuationDateBefore: java.time.LocalDate?) : PaginatedPortfolioListList {
        val localVariableConfig = apiV2PortfoliosListRequestConfig(portfolioUuid = portfolioUuid, externalCustodianId = externalCustodianId, limit = limit, offset = offset, status = status, valuationDateAfter = valuationDateAfter, valuationDateBefore = valuationDateBefore)

        val localVarResponse = request<Unit, PaginatedPortfolioListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPortfolioListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosList
    *
    * @param portfolioUuid  
    * @param externalCustodianId  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @param valuationDateAfter  (optional)
    * @param valuationDateBefore  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosListRequestConfig(portfolioUuid: java.util.UUID, externalCustodianId: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?, valuationDateAfter: java.time.LocalDate?, valuationDateBefore: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (externalCustodianId != null) {
                    put("external_custodian_id", listOf(externalCustodianId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", toMultiValue(status.toList(), "multi"))
                }
                if (valuationDateAfter != null) {
                    put("valuation_date_after", listOf(parseDateToQueryString(valuationDateAfter)))
                }
                if (valuationDateBefore != null) {
                    put("valuation_date_before", listOf(parseDateToQueryString(valuationDateBefore)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param createOrder  
    * @return CreateOrder
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosOrdersCreate(portfolioUuid: java.util.UUID, createOrder: CreateOrder) : CreateOrder {
        val localVariableConfig = apiV2PortfoliosOrdersCreateRequestConfig(portfolioUuid = portfolioUuid, createOrder = createOrder)

        val localVarResponse = request<CreateOrder, CreateOrder>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateOrder
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosOrdersCreate
    *
    * @param portfolioUuid  
    * @param createOrder  
    * @return RequestConfig
    */
    fun apiV2PortfoliosOrdersCreateRequestConfig(portfolioUuid: java.util.UUID, createOrder: CreateOrder) : RequestConfig<CreateOrder> {
        val localVariableBody = createOrder
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/portfolios/{portfolio_uuid}/orders/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Cancel or request cancellation to the broker
    * @param portfolioUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosOrdersDestroy(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2PortfoliosOrdersDestroyRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosOrdersDestroy
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosOrdersDestroyRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/portfolios/{portfolio_uuid}/orders/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param adviceExternalId  (optional)
    * @param asset  (optional)
    * @param completedAfter  (optional)
    * @param completedBefore  (optional)
    * @param extraData Additional order attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param portfolio  (optional)
    * @param status  (optional)
    * @return PaginatedOrderListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosOrdersList(portfolioUuid: java.util.UUID, adviceExternalId: kotlin.String?, asset: kotlin.String?, completedAfter: java.time.LocalDate?, completedBefore: java.time.LocalDate?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, portfolio: kotlin.String?, status: kotlin.String?) : PaginatedOrderListList {
        val localVariableConfig = apiV2PortfoliosOrdersListRequestConfig(portfolioUuid = portfolioUuid, adviceExternalId = adviceExternalId, asset = asset, completedAfter = completedAfter, completedBefore = completedBefore, extraData = extraData, limit = limit, offset = offset, portfolio = portfolio, status = status)

        val localVarResponse = request<Unit, PaginatedOrderListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedOrderListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosOrdersList
    *
    * @param portfolioUuid  
    * @param adviceExternalId  (optional)
    * @param asset  (optional)
    * @param completedAfter  (optional)
    * @param completedBefore  (optional)
    * @param extraData Additional order attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param portfolio  (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosOrdersListRequestConfig(portfolioUuid: java.util.UUID, adviceExternalId: kotlin.String?, asset: kotlin.String?, completedAfter: java.time.LocalDate?, completedBefore: java.time.LocalDate?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, portfolio: kotlin.String?, status: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (adviceExternalId != null) {
                    put("advice_external_id", listOf(adviceExternalId.toString()))
                }
                if (asset != null) {
                    put("asset", listOf(asset.toString()))
                }
                if (completedAfter != null) {
                    put("completed_after", listOf(parseDateToQueryString(completedAfter)))
                }
                if (completedBefore != null) {
                    put("completed_before", listOf(parseDateToQueryString(completedBefore)))
                }
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (portfolio != null) {
                    put("portfolio", listOf(portfolio.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/orders/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return OrderList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosOrdersRetrieve(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : OrderList {
        val localVariableConfig = apiV2PortfoliosOrdersRetrieveRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, OrderList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosOrdersRetrieve
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosOrdersRetrieveRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/orders/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @param patchedPortfolioUpdate  (optional)
    * @return PortfolioUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosPartialUpdate(portfolioUuid: java.util.UUID, patchedPortfolioUpdate: PatchedPortfolioUpdate?) : PortfolioUpdate {
        val localVariableConfig = apiV2PortfoliosPartialUpdateRequestConfig(portfolioUuid = portfolioUuid, patchedPortfolioUpdate = patchedPortfolioUpdate)

        val localVarResponse = request<PatchedPortfolioUpdate, PortfolioUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortfolioUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosPartialUpdate
    *
    * @param portfolioUuid  
    * @param patchedPortfolioUpdate  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosPartialUpdateRequestConfig(portfolioUuid: java.util.UUID, patchedPortfolioUpdate: PatchedPortfolioUpdate?) : RequestConfig<PatchedPortfolioUpdate> {
        val localVariableBody = patchedPortfolioUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/portfolios/{portfolio_uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedPortfolioPerformanceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosPerformanceMwrrList(portfolioUuid: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedPortfolioPerformanceList {
        val localVariableConfig = apiV2PortfoliosPerformanceMwrrListRequestConfig(portfolioUuid = portfolioUuid, dateAfter = dateAfter, dateBefore = dateBefore, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedPortfolioPerformanceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPortfolioPerformanceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosPerformanceMwrrList
    *
    * @param portfolioUuid  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosPerformanceMwrrListRequestConfig(portfolioUuid: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (dateAfter != null) {
                    put("date_after", listOf(parseDateToQueryString(dateAfter)))
                }
                if (dateBefore != null) {
                    put("date_before", listOf(parseDateToQueryString(dateBefore)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/performance/mwrr/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedPortfolioPerformancePositionsList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosPerformancePositionsList(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedPortfolioPerformancePositionsList {
        val localVariableConfig = apiV2PortfoliosPerformancePositionsListRequestConfig(portfolioUuid = portfolioUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedPortfolioPerformancePositionsList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPortfolioPerformancePositionsList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosPerformancePositionsList
    *
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosPerformancePositionsListRequestConfig(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/performance/positions/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedPortfolioPerformanceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosPerformanceTwrrList(portfolioUuid: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedPortfolioPerformanceList {
        val localVariableConfig = apiV2PortfoliosPerformanceTwrrListRequestConfig(portfolioUuid = portfolioUuid, dateAfter = dateAfter, dateBefore = dateBefore, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedPortfolioPerformanceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPortfolioPerformanceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosPerformanceTwrrList
    *
    * @param portfolioUuid  
    * @param dateAfter  (optional)
    * @param dateBefore  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosPerformanceTwrrListRequestConfig(portfolioUuid: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (dateAfter != null) {
                    put("date_after", listOf(parseDateToQueryString(dateAfter)))
                }
                if (dateBefore != null) {
                    put("date_before", listOf(parseDateToQueryString(dateBefore)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/performance/twrr/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedPortfolioTypeList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosPortfoliotypesList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedPortfolioTypeList {
        val localVariableConfig = apiV2PortfoliosPortfoliotypesListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedPortfolioTypeList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPortfolioTypeList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosPortfoliotypesList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosPortfoliotypesListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/portfoliotypes/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param code  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedBasePortfolioTypeRestrictionsList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosPortfoliotypesRestrictionsList(code: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedBasePortfolioTypeRestrictionsList {
        val localVariableConfig = apiV2PortfoliosPortfoliotypesRestrictionsListRequestConfig(code = code, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedBasePortfolioTypeRestrictionsList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedBasePortfolioTypeRestrictionsList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosPortfoliotypesRestrictionsList
    *
    * @param code  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosPortfoliotypesRestrictionsListRequestConfig(code: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/portfoliotypes/{code}/restrictions/".replace("{"+"code"+"}", "$code"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedRebalanceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosRebalancesList(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedRebalanceList {
        val localVariableConfig = apiV2PortfoliosRebalancesListRequestConfig(portfolioUuid = portfolioUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedRebalanceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedRebalanceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosRebalancesList
    *
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosRebalancesListRequestConfig(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/rebalances/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return Rebalance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosRebalancesRetrieve(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : Rebalance {
        val localVariableConfig = apiV2PortfoliosRebalancesRetrieveRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, Rebalance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Rebalance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosRebalancesRetrieve
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosRebalancesRetrieveRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/rebalances/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @return PortfolioTypeRestrictions
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosRestrictionsRetrieve(portfolioUuid: java.util.UUID) : PortfolioTypeRestrictions {
        val localVariableConfig = apiV2PortfoliosRestrictionsRetrieveRequestConfig(portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, PortfolioTypeRestrictions>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortfolioTypeRestrictions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosRestrictionsRetrieve
    *
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosRestrictionsRetrieveRequestConfig(portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/restrictions/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @return PortfolioDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosRetrieve(portfolioUuid: java.util.UUID) : PortfolioDetail {
        val localVariableConfig = apiV2PortfoliosRetrieveRequestConfig(portfolioUuid = portfolioUuid)

        val localVarResponse = request<Unit, PortfolioDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortfolioDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosRetrieve
    *
    * @param portfolioUuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosRetrieveRequestConfig(portfolioUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \&quot;__\&quot; notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields &#x3D; {                 &#39;allocations__balance&#39;: [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \&quot;__\&quot; notation).         Example:             groupable_fields &#x3D; [&#39;portfolio__portfolio_type&#39;]  Query Param Examples:     &gt;&gt;&gt; ?group_by&#x3D;portfolio.portfolio_type     &gt;&gt;&gt; ?aggregate[Sum]&#x3D;portfolio.allocations.balance     &gt;&gt;&gt; ?group_by&#x3D;valuation_date&amp;aggregate[Sum]&#x3D;portfolio.allocations.balance
    * @param portfolioUuid  
    * @param portfolioUpdate  
    * @return PortfolioUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosUpdate(portfolioUuid: java.util.UUID, portfolioUpdate: PortfolioUpdate) : PortfolioUpdate {
        val localVariableConfig = apiV2PortfoliosUpdateRequestConfig(portfolioUuid = portfolioUuid, portfolioUpdate = portfolioUpdate)

        val localVarResponse = request<PortfolioUpdate, PortfolioUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortfolioUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosUpdate
    *
    * @param portfolioUuid  
    * @param portfolioUpdate  
    * @return RequestConfig
    */
    fun apiV2PortfoliosUpdateRequestConfig(portfolioUuid: java.util.UUID, portfolioUpdate: PortfolioUpdate) : RequestConfig<PortfolioUpdate> {
        val localVariableBody = portfolioUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/portfolios/{portfolio_uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param investorWithdrawalCreate  
    * @return InvestorWithdrawalCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosWithdrawalsCreate(portfolioUuid: java.util.UUID, investorWithdrawalCreate: InvestorWithdrawalCreate) : InvestorWithdrawalCreate {
        val localVariableConfig = apiV2PortfoliosWithdrawalsCreateRequestConfig(portfolioUuid = portfolioUuid, investorWithdrawalCreate = investorWithdrawalCreate)

        val localVarResponse = request<InvestorWithdrawalCreate, InvestorWithdrawalCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorWithdrawalCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosWithdrawalsCreate
    *
    * @param portfolioUuid  
    * @param investorWithdrawalCreate  
    * @return RequestConfig
    */
    fun apiV2PortfoliosWithdrawalsCreateRequestConfig(portfolioUuid: java.util.UUID, investorWithdrawalCreate: InvestorWithdrawalCreate) : RequestConfig<InvestorWithdrawalCreate> {
        val localVariableBody = investorWithdrawalCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/portfolios/{portfolio_uuid}/withdrawals/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosWithdrawalsDestroy(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2PortfoliosWithdrawalsDestroyRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosWithdrawalsDestroy
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosWithdrawalsDestroyRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/portfolios/{portfolio_uuid}/withdrawals/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return PaginatedInvestorWithdrawalListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosWithdrawalsList(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : PaginatedInvestorWithdrawalListList {
        val localVariableConfig = apiV2PortfoliosWithdrawalsListRequestConfig(portfolioUuid = portfolioUuid, limit = limit, offset = offset, status = status)

        val localVarResponse = request<Unit, PaginatedInvestorWithdrawalListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvestorWithdrawalListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosWithdrawalsList
    *
    * @param portfolioUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun apiV2PortfoliosWithdrawalsListRequestConfig(portfolioUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", toMultiValue(status.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/withdrawals/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param portfolioUuid  
    * @param uuid  
    * @return WithdrawalDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2PortfoliosWithdrawalsRetrieve(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : WithdrawalDetail {
        val localVariableConfig = apiV2PortfoliosWithdrawalsRetrieveRequestConfig(portfolioUuid = portfolioUuid, uuid = uuid)

        val localVarResponse = request<Unit, WithdrawalDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WithdrawalDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2PortfoliosWithdrawalsRetrieve
    *
    * @param portfolioUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2PortfoliosWithdrawalsRetrieveRequestConfig(portfolioUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/portfolios/{portfolio_uuid}/withdrawals/{uuid}/".replace("{"+"portfolio_uuid"+"}", "$portfolioUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return AllocationByAsset
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieve(uuid: java.util.UUID) : AllocationByAsset {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, AllocationByAsset>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AllocationByAsset
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/allocations-by-asset/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return AssetConcentrationRisk
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieve(uuid: java.util.UUID) : AssetConcentrationRisk {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, AssetConcentrationRisk>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetConcentrationRisk
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/asset-concentration-risk/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return AUMEvoluation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAumEvolutionRetrieve(uuid: java.util.UUID) : AUMEvoluation {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAumEvolutionRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, AUMEvoluation>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AUMEvoluation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAumEvolutionRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAumEvolutionRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/aum-evolution/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return AUMPortfolioRisk
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieve(uuid: java.util.UUID) : AUMPortfolioRisk {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, AUMPortfolioRisk>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AUMPortfolioRisk
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/aum-portfolio-risk/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAumRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAumRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAumRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAumRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/aum/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsClientByRiskRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsClientByRiskRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsClientByRiskRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsClientByRiskRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/client-by-risk/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsClientByStatusRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsClientByStatusRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsClientByStatusRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsClientByStatusRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/client-by-status/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return ClientRanking
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsClientRankingRetrieve(uuid: java.util.UUID) : ClientRanking {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsClientRankingRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, ClientRanking>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientRanking
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsClientRankingRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsClientRankingRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/client-ranking/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/inflows-outflows/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/portfolio-risk-performance/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/analytics/total-active-clients/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerMeRetrieve() : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerMeRetrieveRequestConfig()

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerMeRetrieve
    *
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerMeRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/me/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedStatementList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportStatementsList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedStatementList {
        val localVariableConfig = apiV2ReportStatementsListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedStatementList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStatementList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportStatementsList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ReportStatementsListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/statements/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return Statement
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportStatementsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : Statement {
        val localVariableConfig = apiV2ReportStatementsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, Statement>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Statement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportStatementsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ReportStatementsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/statements/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTaxReportList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportTaxReportList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTaxReportList {
        val localVariableConfig = apiV2ReportTaxReportListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTaxReportList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTaxReportList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportTaxReportList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ReportTaxReportListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/tax-report/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return TaxReport
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportTaxReportRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : TaxReport {
        val localVariableConfig = apiV2ReportTaxReportRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, TaxReport>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxReport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportTaxReportRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ReportTaxReportRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/tax-report/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedQuestionList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RiskQuestionsList(limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedQuestionList {
        val localVariableConfig = apiV2RiskQuestionsListRequestConfig(limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedQuestionList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedQuestionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RiskQuestionsList
    *
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2RiskQuestionsListRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/risk/questions/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param action  
    * @param verifier  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2VerificationsVerifierWebhookCreate(action: kotlin.String, verifier: kotlin.String) : Unit {
        val localVariableConfig = apiV2VerificationsVerifierWebhookCreateRequestConfig(action = action, verifier = verifier)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2VerificationsVerifierWebhookCreate
    *
    * @param action  
    * @param verifier  
    * @return RequestConfig
    */
    fun apiV2VerificationsVerifierWebhookCreateRequestConfig(action: kotlin.String, verifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/verifications/verifier_webhook/{verifier}/{action}/".replace("{"+"action"+"}", "$action").replace("{"+"verifier"+"}", "$verifier"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param websocketAuthentication  
    * @return AuthenticationResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WebsocketAuthenticationTicketCreate(websocketAuthentication: WebsocketAuthentication) : AuthenticationResponse {
        val localVariableConfig = apiV2WebsocketAuthenticationTicketCreateRequestConfig(websocketAuthentication = websocketAuthentication)

        val localVarResponse = request<WebsocketAuthentication, AuthenticationResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2WebsocketAuthenticationTicketCreate
    *
    * @param websocketAuthentication  
    * @return RequestConfig
    */
    fun apiV2WebsocketAuthenticationTicketCreateRequestConfig(websocketAuthentication: WebsocketAuthentication) : RequestConfig<WebsocketAuthentication> {
        val localVariableBody = websocketAuthentication
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/websocket/authentication/ticket/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param websocketAuthentication  
    * @return Response
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WebsocketAuthorizeAssetCreate(websocketAuthentication: WebsocketAuthentication) : Response {
        val localVariableConfig = apiV2WebsocketAuthorizeAssetCreateRequestConfig(websocketAuthentication = websocketAuthentication)

        val localVarResponse = request<WebsocketAuthentication, Response>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2WebsocketAuthorizeAssetCreate
    *
    * @param websocketAuthentication  
    * @return RequestConfig
    */
    fun apiV2WebsocketAuthorizeAssetCreateRequestConfig(websocketAuthentication: WebsocketAuthentication) : RequestConfig<WebsocketAuthentication> {
        val localVariableBody = websocketAuthentication
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/websocket/authorize/asset/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param websocketAuthentication  
    * @return Response
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WebsocketAuthorizeCreate(websocketAuthentication: WebsocketAuthentication) : Response {
        val localVariableConfig = apiV2WebsocketAuthorizeCreateRequestConfig(websocketAuthentication = websocketAuthentication)

        val localVarResponse = request<WebsocketAuthentication, Response>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2WebsocketAuthorizeCreate
    *
    * @param websocketAuthentication  
    * @return RequestConfig
    */
    fun apiV2WebsocketAuthorizeCreateRequestConfig(websocketAuthentication: WebsocketAuthentication) : RequestConfig<WebsocketAuthentication> {
        val localVariableBody = websocketAuthentication
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/websocket/authorize/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param websocketAuthentication  
    * @return Response
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WebsocketAuthorizePortfolioCreate(websocketAuthentication: WebsocketAuthentication) : Response {
        val localVariableConfig = apiV2WebsocketAuthorizePortfolioCreateRequestConfig(websocketAuthentication = websocketAuthentication)

        val localVarResponse = request<WebsocketAuthentication, Response>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2WebsocketAuthorizePortfolioCreate
    *
    * @param websocketAuthentication  
    * @return RequestConfig
    */
    fun apiV2WebsocketAuthorizePortfolioCreateRequestConfig(websocketAuthentication: WebsocketAuthentication) : RequestConfig<WebsocketAuthentication> {
        val localVariableBody = websocketAuthentication
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/websocket/authorize/portfolio/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param subscribe  
    * @return Subscribe
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WebsocketOnSubscribeCreate(subscribe: Subscribe) : Subscribe {
        val localVariableConfig = apiV2WebsocketOnSubscribeCreateRequestConfig(subscribe = subscribe)

        val localVarResponse = request<Subscribe, Subscribe>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subscribe
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2WebsocketOnSubscribeCreate
    *
    * @param subscribe  
    * @return RequestConfig
    */
    fun apiV2WebsocketOnSubscribeCreateRequestConfig(subscribe: Subscribe) : RequestConfig<Subscribe> {
        val localVariableBody = subscribe
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/websocket/on_subscribe/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param unsubscribe  
    * @return Unsubscribe
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WebsocketOnUnsubscribeCreate(unsubscribe: Unsubscribe) : Unsubscribe {
        val localVariableConfig = apiV2WebsocketOnUnsubscribeCreateRequestConfig(unsubscribe = unsubscribe)

        val localVarResponse = request<Unsubscribe, Unsubscribe>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Unsubscribe
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2WebsocketOnUnsubscribeCreate
    *
    * @param unsubscribe  
    * @return RequestConfig
    */
    fun apiV2WebsocketOnUnsubscribeCreateRequestConfig(unsubscribe: Unsubscribe) : RequestConfig<Unsubscribe> {
        val localVariableBody = unsubscribe
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/websocket/on_unsubscribe/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
