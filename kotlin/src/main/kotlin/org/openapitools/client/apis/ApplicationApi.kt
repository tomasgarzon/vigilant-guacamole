/**
 * Nucoro API
 *
 * No description
 *
 * The version of the OpenAPI document: 4.175.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.AUMEvoluation
import org.openapitools.client.models.AUMPortfolioRisk
import org.openapitools.client.models.AddressCreate
import org.openapitools.client.models.AddressList
import org.openapitools.client.models.AddressUpdate
import org.openapitools.client.models.AllocationByAsset
import org.openapitools.client.models.ApplicationClientUpdate
import org.openapitools.client.models.Assessment
import org.openapitools.client.models.AssetConcentrationRisk
import org.openapitools.client.models.BankAccountCreateUpdate
import org.openapitools.client.models.BankAccountList
import org.openapitools.client.models.ClientCreate
import org.openapitools.client.models.ClientDetail
import org.openapitools.client.models.ClientPerformance
import org.openapitools.client.models.ClientRanking
import org.openapitools.client.models.DocTypeEnum
import org.openapitools.client.models.Document
import org.openapitools.client.models.DocumentTypeEnum
import org.openapitools.client.models.FeedActivityList
import org.openapitools.client.models.InvestorFee
import org.openapitools.client.models.InvoiceList
import org.openapitools.client.models.NationalityCreate
import org.openapitools.client.models.NationalityList
import org.openapitools.client.models.NationalityUpdate
import org.openapitools.client.models.OneOfLessThanResultEnumCommaBlankEnumGreaterThan
import org.openapitools.client.models.PaginatedAddressListList
import org.openapitools.client.models.PaginatedAssessmentList
import org.openapitools.client.models.PaginatedBankAccountListList
import org.openapitools.client.models.PaginatedClientDetailList
import org.openapitools.client.models.PaginatedDocumentList
import org.openapitools.client.models.PaginatedFeedActivityListList
import org.openapitools.client.models.PaginatedInvestorFeeList
import org.openapitools.client.models.PaginatedInvoiceListList
import org.openapitools.client.models.PaginatedNationalityListList
import org.openapitools.client.models.PaginatedStatementList
import org.openapitools.client.models.PaginatedTaxInformationListList
import org.openapitools.client.models.PaginatedTaxReportList
import org.openapitools.client.models.PaginatedVerificationDocumentList
import org.openapitools.client.models.PaginatedVerificationListList
import org.openapitools.client.models.PaginatedWatchlistList
import org.openapitools.client.models.PatchedAddressUpdate
import org.openapitools.client.models.PatchedApplicationClientUpdate
import org.openapitools.client.models.PatchedAssessment
import org.openapitools.client.models.PatchedBankAccountCreateUpdate
import org.openapitools.client.models.PatchedInvestorFee
import org.openapitools.client.models.PatchedNationalityUpdate
import org.openapitools.client.models.PatchedTaxInformationCreateUpdate
import org.openapitools.client.models.RelationshipManager
import org.openapitools.client.models.Statement
import org.openapitools.client.models.StatusBd7Enum
import org.openapitools.client.models.TaxInformationCreateUpdate
import org.openapitools.client.models.TaxInformationList
import org.openapitools.client.models.TaxReport
import org.openapitools.client.models.VerificationCreate
import org.openapitools.client.models.VerificationDocument
import org.openapitools.client.models.VerificationDocumentCreate
import org.openapitools.client.models.VerificationList
import org.openapitools.client.models.VerificationWithType
import org.openapitools.client.models.VerifyTypeEnum
import org.openapitools.client.models.Watchlist

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ApplicationApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return PaginatedFeedActivityListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsActivitiesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : PaginatedFeedActivityListList {
        val localVariableConfig = apiV2ClientsActivitiesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset, target = target)

        val localVarResponse = request<Unit, PaginatedFeedActivityListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedFeedActivityListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsActivitiesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param target  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsActivitiesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, target: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (target != null) {
                    put("target", toMultiValue(target.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/activities/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return FeedActivityList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsActivitiesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : FeedActivityList {
        val localVariableConfig = apiV2ClientsActivitiesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, FeedActivityList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeedActivityList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsActivitiesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsActivitiesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/activities/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsAdviceEnginesList(clientUuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsAdviceEnginesListRequestConfig(clientUuid = clientUuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsAdviceEnginesList
    *
    * @param clientUuid  
    * @return RequestConfig
    */
    fun apiV2ClientsAdviceEnginesListRequestConfig(clientUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/advice-engines/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsAdviceEnginesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsAdviceEnginesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsAdviceEnginesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsAdviceEnginesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/advice-engines/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param investorFee  
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesCreate(clientUuid: java.util.UUID, investorFee: InvestorFee) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesCreateRequestConfig(clientUuid = clientUuid, investorFee = investorFee)

        val localVarResponse = request<InvestorFee, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesCreate
    *
    * @param clientUuid  
    * @param investorFee  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesCreateRequestConfig(clientUuid: java.util.UUID, investorFee: InvestorFee) : RequestConfig<InvestorFee> {
        val localVariableBody = investorFee
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/billing/fees/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesDestroy(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsBillingFeesDestroyRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesDestroy
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesDestroyRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedInvestorFeeList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedInvestorFeeList {
        val localVariableConfig = apiV2ClientsBillingFeesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedInvestorFeeList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvestorFeeList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/fees/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @param patchedInvestorFee  (optional)
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedInvestorFee: PatchedInvestorFee?) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, patchedInvestorFee = patchedInvestorFee)

        val localVarResponse = request<PatchedInvestorFee, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param patchedInvestorFee  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedInvestorFee: PatchedInvestorFee?) : RequestConfig<PatchedInvestorFee> {
        val localVariableBody = patchedInvestorFee
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param clientUuid  
    * @param uuid  
    * @param investorFee  
    * @return InvestorFee
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingFeesUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, investorFee: InvestorFee) : InvestorFee {
        val localVariableConfig = apiV2ClientsBillingFeesUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, investorFee = investorFee)

        val localVarResponse = request<InvestorFee, InvestorFee>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvestorFee
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingFeesUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param investorFee  
    * @return RequestConfig
    */
    fun apiV2ClientsBillingFeesUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, investorFee: InvestorFee) : RequestConfig<InvestorFee> {
        val localVariableBody = investorFee
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/billing/fees/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedInvoiceListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingInvoicesList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedInvoiceListList {
        val localVariableConfig = apiV2ClientsBillingInvoicesListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedInvoiceListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvoiceListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingInvoicesList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingInvoicesListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/invoices/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return InvoiceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsBillingInvoicesRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : InvoiceList {
        val localVariableConfig = apiV2ClientsBillingInvoicesRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, InvoiceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsBillingInvoicesRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsBillingInvoicesRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/billing/invoices/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedStatementList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportStatementsList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedStatementList {
        val localVariableConfig = apiV2ClientsReportStatementsListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedStatementList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStatementList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportStatementsList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportStatementsListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/statements/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return Statement
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportStatementsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : Statement {
        val localVariableConfig = apiV2ClientsReportStatementsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, Statement>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Statement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportStatementsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportStatementsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/statements/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTaxReportList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportTaxReportsList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTaxReportList {
        val localVariableConfig = apiV2ClientsReportTaxReportsListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTaxReportList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTaxReportList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportTaxReportsList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportTaxReportsListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/tax-reports/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return TaxReport
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsReportTaxReportsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : TaxReport {
        val localVariableConfig = apiV2ClientsReportTaxReportsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, TaxReport>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxReport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsReportTaxReportsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsReportTaxReportsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/report/tax-reports/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param watchlist  
    * @return Watchlist
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsCreate(clientUuid: java.util.UUID, watchlist: Watchlist) : Watchlist {
        val localVariableConfig = apiV2ClientsWatchlistsCreateRequestConfig(clientUuid = clientUuid, watchlist = watchlist)

        val localVarResponse = request<Watchlist, Watchlist>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Watchlist
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsCreate
    *
    * @param clientUuid  
    * @param watchlist  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsCreateRequestConfig(clientUuid: java.util.UUID, watchlist: Watchlist) : RequestConfig<Watchlist> {
        val localVariableBody = watchlist
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/watchlists/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsDestroy(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = apiV2ClientsWatchlistsDestroyRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsDestroy
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsDestroyRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/watchlists/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedWatchlistList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedWatchlistList {
        val localVariableConfig = apiV2ClientsWatchlistsListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedWatchlistList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedWatchlistList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/watchlists/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param uuid  
    * @return Watchlist
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : Watchlist {
        val localVariableConfig = apiV2ClientsWatchlistsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Watchlist>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Watchlist
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/watchlists/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Applies filters without declaring them explicitly. How? Creating those filters on the fly.  # How it works. - Declare &#39;filterable_fields&#39; in the view.     E.g. filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]     __all__ is allowed. It applies filters for all model attributes.  - COMMON_FILTERS: common filters configuration.     - key: field name. E.g. status.     - filter_class. filter class for the field.     - args. Args for the filter_class __init__.  These args are taken from the queryset model         E.g. &#39;args&#39;: {&#39;choices&#39;: &#39;STATUS_CHOICES&#39;} means Filter(choices&#x3D;queryset.model.STATUS_CHOICES)   # How to use it: class PortfolioListCreateView(CommonFilterMixin, InvestorAPIViewMixin, ListCreateAPIView):     filterable_fields &#x3D; [&#39;status&#39;, &#39;name&#39;]  # Filters priority. 1- Explicit filter declared in the filterset_class 2- Filters declared in COMMON_FILTERS 3- Filterset.FILTER_DEFAULTS
    * @param clientUuid  
    * @param uuid  
    * @param watchlist  
    * @return Watchlist
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ClientsWatchlistsUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, watchlist: Watchlist) : Watchlist {
        val localVariableConfig = apiV2ClientsWatchlistsUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, watchlist = watchlist)

        val localVarResponse = request<Watchlist, Watchlist>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Watchlist
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ClientsWatchlistsUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param watchlist  
    * @return RequestConfig
    */
    fun apiV2ClientsWatchlistsUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, watchlist: Watchlist) : RequestConfig<Watchlist> {
        val localVariableBody = watchlist
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/watchlists/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return AllocationByAsset
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieve(relationshipManagerUuid: java.util.UUID) : AllocationByAsset {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, AllocationByAsset>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AllocationByAsset
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAllocationsByAssetRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/allocations-by-asset/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return AssetConcentrationRisk
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieve(relationshipManagerUuid: java.util.UUID) : AssetConcentrationRisk {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, AssetConcentrationRisk>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetConcentrationRisk
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAssetConcentrationRiskRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/asset-concentration-risk/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return AUMEvoluation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAumEvolutionRetrieve(relationshipManagerUuid: java.util.UUID) : AUMEvoluation {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAumEvolutionRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, AUMEvoluation>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AUMEvoluation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAumEvolutionRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAumEvolutionRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/aum-evolution/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return AUMPortfolioRisk
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieve(relationshipManagerUuid: java.util.UUID) : AUMPortfolioRisk {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, AUMPortfolioRisk>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AUMPortfolioRisk
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAumPortfolioRiskRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/aum-portfolio-risk/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsAumRetrieve(relationshipManagerUuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsAumRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsAumRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsAumRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/aum/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsClientByRiskRetrieve(relationshipManagerUuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsClientByRiskRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsClientByRiskRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsClientByRiskRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/client-by-risk/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsClientByStatusRetrieve(relationshipManagerUuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsClientByStatusRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsClientByStatusRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsClientByStatusRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/client-by-status/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return ClientRanking
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsClientRankingRetrieve(relationshipManagerUuid: java.util.UUID) : ClientRanking {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsClientRankingRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, ClientRanking>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientRanking
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsClientRankingRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsClientRankingRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/client-ranking/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieve(relationshipManagerUuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsInflowsOutflowsRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/inflows-outflows/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieve(relationshipManagerUuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsPortfolioRiskPerformanceRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/portfolio-risk-performance/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param relationshipManagerUuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieve(relationshipManagerUuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieveRequestConfig(relationshipManagerUuid = relationshipManagerUuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieve
    *
    * @param relationshipManagerUuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerAnalyticsTotalActiveClientsRetrieveRequestConfig(relationshipManagerUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{relationship_manager_uuid}/analytics/total-active-clients/".replace("{"+"relationship_manager_uuid"+"}", "$relationshipManagerUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerMeRetrieve() : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerMeRetrieveRequestConfig()

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerMeRetrieve
    *
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerMeRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/me/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uuid  
    * @return RelationshipManager
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2RelationshipManagerRetrieve(uuid: java.util.UUID) : RelationshipManager {
        val localVariableConfig = apiV2RelationshipManagerRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, RelationshipManager>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RelationshipManager
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2RelationshipManagerRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun apiV2RelationshipManagerRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/relationship-manager/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedStatementList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportStatementsList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedStatementList {
        val localVariableConfig = apiV2ReportStatementsListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedStatementList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStatementList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportStatementsList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ReportStatementsListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/statements/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return Statement
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportStatementsRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : Statement {
        val localVariableConfig = apiV2ReportStatementsRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, Statement>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Statement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportStatementsRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ReportStatementsRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/statements/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTaxReportList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportTaxReportList(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTaxReportList {
        val localVariableConfig = apiV2ReportTaxReportListRequestConfig(clientUuid = clientUuid, format = format, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTaxReportList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTaxReportList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportTaxReportList
    *
    * @param clientUuid  
    * @param format  (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun apiV2ReportTaxReportListRequestConfig(clientUuid: java.util.UUID, format: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/tax-report/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return TaxReport
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2ReportTaxReportRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : TaxReport {
        val localVariableConfig = apiV2ReportTaxReportRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, format = format)

        val localVarResponse = request<Unit, TaxReport>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxReport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation apiV2ReportTaxReportRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param format  (optional)
    * @return RequestConfig
    */
    fun apiV2ReportTaxReportRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, format: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/report/tax-report/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create an address for a client
    * @param clientUuid  
    * @param addressCreate  
    * @return AddressCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressCreate(clientUuid: java.util.UUID, addressCreate: AddressCreate) : AddressCreate {
        val localVariableConfig = clientAddressCreateRequestConfig(clientUuid = clientUuid, addressCreate = addressCreate)

        val localVarResponse = request<AddressCreate, AddressCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressCreate
    *
    * @param clientUuid  
    * @param addressCreate  
    * @return RequestConfig
    */
    fun clientAddressCreateRequestConfig(clientUuid: java.util.UUID, addressCreate: AddressCreate) : RequestConfig<AddressCreate> {
        val localVariableBody = addressCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/addresses/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client address
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressDelete(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = clientAddressDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientAddressDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/addresses/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client address
    * @param clientUuid  
    * @param uuid  
    * @param patchedAddressUpdate  (optional)
    * @return AddressUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedAddressUpdate: PatchedAddressUpdate?) : AddressUpdate {
        val localVariableConfig = clientAddressPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, patchedAddressUpdate = patchedAddressUpdate)

        val localVarResponse = request<PatchedAddressUpdate, AddressUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param patchedAddressUpdate  (optional)
    * @return RequestConfig
    */
    fun clientAddressPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedAddressUpdate: PatchedAddressUpdate?) : RequestConfig<PatchedAddressUpdate> {
        val localVariableBody = patchedAddressUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/addresses/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client address
    * @param clientUuid  
    * @param uuid  
    * @return AddressList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : AddressList {
        val localVariableConfig = clientAddressRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, AddressList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientAddressRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/addresses/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client address
    * @param clientUuid  
    * @param uuid  
    * @param addressUpdate  
    * @return AddressUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, addressUpdate: AddressUpdate) : AddressUpdate {
        val localVariableConfig = clientAddressUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, addressUpdate = addressUpdate)

        val localVarResponse = request<AddressUpdate, AddressUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param addressUpdate  
    * @return RequestConfig
    */
    fun clientAddressUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, addressUpdate: AddressUpdate) : RequestConfig<AddressUpdate> {
        val localVariableBody = addressUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/addresses/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List address for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedAddressListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientAddressesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedAddressListList {
        val localVariableConfig = clientAddressesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedAddressListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAddressListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientAddressesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientAddressesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/addresses/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a bank account for a client
    * @param clientUuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return BankAccountCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountCreate(clientUuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : BankAccountCreateUpdate {
        val localVariableConfig = clientBankAccountCreateRequestConfig(clientUuid = clientUuid, bankAccountCreateUpdate = bankAccountCreateUpdate)

        val localVarResponse = request<BankAccountCreateUpdate, BankAccountCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountCreate
    *
    * @param clientUuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientBankAccountCreateRequestConfig(clientUuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : RequestConfig<BankAccountCreateUpdate> {
        val localVariableBody = bankAccountCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client bank account
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountDelete(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = clientBankAccountDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientBankAccountDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client bank account
    * @param clientUuid  
    * @param uuid  
    * @param patchedBankAccountCreateUpdate  (optional)
    * @return BankAccountCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedBankAccountCreateUpdate: PatchedBankAccountCreateUpdate?) : BankAccountCreateUpdate {
        val localVariableConfig = clientBankAccountPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, patchedBankAccountCreateUpdate = patchedBankAccountCreateUpdate)

        val localVarResponse = request<PatchedBankAccountCreateUpdate, BankAccountCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param patchedBankAccountCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientBankAccountPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedBankAccountCreateUpdate: PatchedBankAccountCreateUpdate?) : RequestConfig<PatchedBankAccountCreateUpdate> {
        val localVariableBody = patchedBankAccountCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client bank account
    * @param clientUuid  
    * @param uuid  
    * @return BankAccountList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : BankAccountList {
        val localVariableConfig = clientBankAccountRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, BankAccountList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientBankAccountRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client bank account
    * @param clientUuid  
    * @param uuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return BankAccountCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : BankAccountCreateUpdate {
        val localVariableConfig = clientBankAccountUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, bankAccountCreateUpdate = bankAccountCreateUpdate)

        val localVarResponse = request<BankAccountCreateUpdate, BankAccountCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankAccountCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param bankAccountCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientBankAccountUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, bankAccountCreateUpdate: BankAccountCreateUpdate?) : RequestConfig<BankAccountCreateUpdate> {
        val localVariableBody = bankAccountCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Bank Account for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedBankAccountListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientBankAccountsList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedBankAccountListList {
        val localVariableConfig = clientBankAccountsListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedBankAccountListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedBankAccountListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientBankAccountsList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientBankAccountsListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/bank-accounts/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Complete onboarding for a client
    * @param clientUuid  
    * @param uuid  
    * @param clientDetail  
    * @return ClientDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientCompleteOnboarding(clientUuid: java.util.UUID, uuid: java.util.UUID, clientDetail: ClientDetail) : ClientDetail {
        val localVariableConfig = clientCompleteOnboardingRequestConfig(clientUuid = clientUuid, uuid = uuid, clientDetail = clientDetail)

        val localVarResponse = request<ClientDetail, ClientDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientCompleteOnboarding
    *
    * @param clientUuid  
    * @param uuid  
    * @param clientDetail  
    * @return RequestConfig
    */
    fun clientCompleteOnboardingRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, clientDetail: ClientDetail) : RequestConfig<ClientDetail> {
        val localVariableBody = clientDetail
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{uuid}/onboarding/complete/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a client
    * @param clientCreate  
    * @return ClientCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientCreate(clientCreate: ClientCreate) : ClientCreate {
        val localVariableConfig = clientCreateRequestConfig(clientCreate = clientCreate)

        val localVarResponse = request<ClientCreate, ClientCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientCreate
    *
    * @param clientCreate  
    * @return RequestConfig
    */
    fun clientCreateRequestConfig(clientCreate: ClientCreate) : RequestConfig<ClientCreate> {
        val localVariableBody = clientCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a document for a client
    * @param clientUuid  
    * @param uuid  
    * @param name  
    * @param docType  
    * @param path  
    * @param description  (optional)
    * @return Document
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientDocumentCreate(clientUuid: java.util.UUID, uuid: java.util.UUID, name: kotlin.String, docType: DocTypeEnum, path: java.net.URI, description: kotlin.String?) : Document {
        val localVariableConfig = clientDocumentCreateRequestConfig(clientUuid = clientUuid, uuid = uuid, name = name, docType = docType, path = path, description = description)

        val localVarResponse = request<Map<String, Any?>, Document>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Document
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientDocumentCreate
    *
    * @param clientUuid  
    * @param uuid  
    * @param name  
    * @param docType  
    * @param path  
    * @param description  (optional)
    * @return RequestConfig
    */
    fun clientDocumentCreateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, name: kotlin.String, docType: DocTypeEnum, path: java.net.URI, description: kotlin.String?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "name" to name, "doc_type" to docType, "description" to description, "path" to path)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client document
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientDocumentDelete(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = clientDocumentDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientDocumentDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientDocumentDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Document for a client
    * @param clientUuid  
    * @param client  (optional)
    * @param description  (optional)
    * @param docType  (optional)
    * @param extraData Additional document attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedDocumentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientDocumentList(clientUuid: java.util.UUID, client: kotlin.Int?, description: kotlin.String?, docType: kotlin.collections.List<kotlin.String>?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?) : PaginatedDocumentList {
        val localVariableConfig = clientDocumentListRequestConfig(clientUuid = clientUuid, client = client, description = description, docType = docType, extraData = extraData, limit = limit, name = name, offset = offset)

        val localVarResponse = request<Unit, PaginatedDocumentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDocumentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientDocumentList
    *
    * @param clientUuid  
    * @param client  (optional)
    * @param description  (optional)
    * @param docType  (optional)
    * @param extraData Additional document attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param name  (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientDocumentListRequestConfig(clientUuid: java.util.UUID, client: kotlin.Int?, description: kotlin.String?, docType: kotlin.collections.List<kotlin.String>?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, name: kotlin.String?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (client != null) {
                    put("client", listOf(client.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (docType != null) {
                    put("doc_type", toMultiValue(docType.toList(), "multi"))
                }
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client document
    * @param clientUuid  
    * @param uuid  
    * @return Document
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientDocumentRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : Document {
        val localVariableConfig = clientDocumentRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Document>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Document
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientDocumentRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientDocumentRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List client for a Relationship manager
    * @param externalCustodianId  (optional)
    * @param extraData Additional client attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param ordering Ordering (optional)
    * @param search A search term. (optional)
    * @param status  (optional)
    * @return PaginatedClientDetailList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientList(externalCustodianId: kotlin.String?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, ordering: kotlin.collections.List<kotlin.String>?, search: kotlin.String?, status: kotlin.String?) : PaginatedClientDetailList {
        val localVariableConfig = clientListRequestConfig(externalCustodianId = externalCustodianId, extraData = extraData, limit = limit, offset = offset, ordering = ordering, search = search, status = status)

        val localVarResponse = request<Unit, PaginatedClientDetailList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedClientDetailList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientList
    *
    * @param externalCustodianId  (optional)
    * @param extraData Additional client attributes for the specific portal (optional)
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param ordering Ordering (optional)
    * @param search A search term. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun clientListRequestConfig(externalCustodianId: kotlin.String?, extraData: kotlin.collections.Map<kotlin.String, kotlin.Any>?, limit: kotlin.Int?, offset: kotlin.Int?, ordering: kotlin.collections.List<kotlin.String>?, search: kotlin.String?, status: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (externalCustodianId != null) {
                    put("external_custodian_id", listOf(externalCustodianId.toString()))
                }
                if (extraData != null) {
                    put("extra_data", toMultiValue(extraData.toList(), ""))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (ordering != null) {
                    put("ordering", toMultiValue(ordering.toList(), "csv"))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create nationality for a client
    * @param clientUuid  
    * @param nationalityCreate  
    * @return NationalityCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationalityCreate(clientUuid: java.util.UUID, nationalityCreate: NationalityCreate) : NationalityCreate {
        val localVariableConfig = clientNationalityCreateRequestConfig(clientUuid = clientUuid, nationalityCreate = nationalityCreate)

        val localVarResponse = request<NationalityCreate, NationalityCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationalityCreate
    *
    * @param clientUuid  
    * @param nationalityCreate  
    * @return RequestConfig
    */
    fun clientNationalityCreateRequestConfig(clientUuid: java.util.UUID, nationalityCreate: NationalityCreate) : RequestConfig<NationalityCreate> {
        val localVariableBody = nationalityCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/nationalities/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List nationlities for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedNationalityListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlitiesList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedNationalityListList {
        val localVariableConfig = clientNationlitiesListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedNationalityListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNationalityListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlitiesList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientNationlitiesListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/nationalities/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client nationality
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityDelete(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = clientNationlityDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientNationlityDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/nationalities/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client nationality
    * @param clientUuid  
    * @param uuid  
    * @param patchedNationalityUpdate  (optional)
    * @return NationalityUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedNationalityUpdate: PatchedNationalityUpdate?) : NationalityUpdate {
        val localVariableConfig = clientNationlityPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, patchedNationalityUpdate = patchedNationalityUpdate)

        val localVarResponse = request<PatchedNationalityUpdate, NationalityUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param patchedNationalityUpdate  (optional)
    * @return RequestConfig
    */
    fun clientNationlityPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedNationalityUpdate: PatchedNationalityUpdate?) : RequestConfig<PatchedNationalityUpdate> {
        val localVariableBody = patchedNationalityUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/nationalities/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client nationality
    * @param clientUuid  
    * @param uuid  
    * @return NationalityList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : NationalityList {
        val localVariableConfig = clientNationlityRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, NationalityList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientNationlityRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/nationalities/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client nationality
    * @param clientUuid  
    * @param uuid  
    * @param nationalityUpdate  
    * @return NationalityUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientNationlityUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, nationalityUpdate: NationalityUpdate) : NationalityUpdate {
        val localVariableConfig = clientNationlityUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, nationalityUpdate = nationalityUpdate)

        val localVarResponse = request<NationalityUpdate, NationalityUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NationalityUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientNationlityUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param nationalityUpdate  
    * @return RequestConfig
    */
    fun clientNationlityUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, nationalityUpdate: NationalityUpdate) : RequestConfig<NationalityUpdate> {
        val localVariableBody = nationalityUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/nationalities/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client
    * @param uuid  
    * @param patchedApplicationClientUpdate  (optional)
    * @return ApplicationClientUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientPartialUpdate(uuid: java.util.UUID, patchedApplicationClientUpdate: PatchedApplicationClientUpdate?) : ApplicationClientUpdate {
        val localVariableConfig = clientPartialUpdateRequestConfig(uuid = uuid, patchedApplicationClientUpdate = patchedApplicationClientUpdate)

        val localVarResponse = request<PatchedApplicationClientUpdate, ApplicationClientUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplicationClientUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientPartialUpdate
    *
    * @param uuid  
    * @param patchedApplicationClientUpdate  (optional)
    * @return RequestConfig
    */
    fun clientPartialUpdateRequestConfig(uuid: java.util.UUID, patchedApplicationClientUpdate: PatchedApplicationClientUpdate?) : RequestConfig<PatchedApplicationClientUpdate> {
        val localVariableBody = patchedApplicationClientUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client
    * @param uuid  
    * @return ClientDetail
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRetrieve(uuid: java.util.UUID) : ClientDetail {
        val localVariableConfig = clientRetrieveRequestConfig(uuid = uuid)

        val localVarResponse = request<Unit, ClientDetail>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRetrieve
    *
    * @param uuid  
    * @return RequestConfig
    */
    fun clientRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a risk assessment for a client
    * @param clientUuid  
    * @param assessment  
    * @return Assessment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentCreate(clientUuid: java.util.UUID, assessment: Assessment) : Assessment {
        val localVariableConfig = clientRiskAssessmentCreateRequestConfig(clientUuid = clientUuid, assessment = assessment)

        val localVarResponse = request<Assessment, Assessment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Assessment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentCreate
    *
    * @param clientUuid  
    * @param assessment  
    * @return RequestConfig
    */
    fun clientRiskAssessmentCreateRequestConfig(clientUuid: java.util.UUID, assessment: Assessment) : RequestConfig<Assessment> {
        val localVariableBody = assessment
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client risk assessment
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentDelete(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = clientRiskAssessmentDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientRiskAssessmentDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Risk Assessment for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return PaginatedAssessmentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : PaginatedAssessmentList {
        val localVariableConfig = clientRiskAssessmentListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset, status = status)

        val localVarResponse = request<Unit, PaginatedAssessmentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAssessmentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @param status  (optional)
    * @return RequestConfig
    */
    fun clientRiskAssessmentListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?, status: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (status != null) {
                    put("status", toMultiValue(status.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client risk assessment
    * @param clientUuid  
    * @param uuid  
    * @param patchedAssessment  (optional)
    * @return Assessment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedAssessment: PatchedAssessment?) : Assessment {
        val localVariableConfig = clientRiskAssessmentPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, patchedAssessment = patchedAssessment)

        val localVarResponse = request<PatchedAssessment, Assessment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Assessment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param patchedAssessment  (optional)
    * @return RequestConfig
    */
    fun clientRiskAssessmentPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedAssessment: PatchedAssessment?) : RequestConfig<PatchedAssessment> {
        val localVariableBody = patchedAssessment
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client risk assessment
    * @param clientUuid  
    * @param uuid  
    * @return Assessment
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRiskAssessmentRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : Assessment {
        val localVariableConfig = clientRiskAssessmentRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Assessment>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Assessment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRiskAssessmentRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientRiskAssessmentRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/risk-assessments/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Calculate TWRR Performance for client
    * @param clientUuid  
    * @param uuid  
    * @return ClientPerformance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTWRRPerformance(clientUuid: java.util.UUID, uuid: java.util.UUID) : ClientPerformance {
        val localVariableConfig = clientTWRRPerformanceRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, ClientPerformance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientPerformance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTWRRPerformance
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientTWRRPerformanceRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{uuid}/performance/twrr/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a tax inforation for a client
    * @param clientUuid  
    * @param taxInformationCreateUpdate  
    * @return TaxInformationCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationCreate(clientUuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : TaxInformationCreateUpdate {
        val localVariableConfig = clientTaxInformationCreateRequestConfig(clientUuid = clientUuid, taxInformationCreateUpdate = taxInformationCreateUpdate)

        val localVarResponse = request<TaxInformationCreateUpdate, TaxInformationCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationCreate
    *
    * @param clientUuid  
    * @param taxInformationCreateUpdate  
    * @return RequestConfig
    */
    fun clientTaxInformationCreateRequestConfig(clientUuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : RequestConfig<TaxInformationCreateUpdate> {
        val localVariableBody = taxInformationCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/tax-informations/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client tax inforation
    * @param clientUuid  
    * @param uuid  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationDelete(clientUuid: java.util.UUID, uuid: java.util.UUID) : Unit {
        val localVariableConfig = clientTaxInformationDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientTaxInformationDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List tax information for a client
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedTaxInformationListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationList(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedTaxInformationListList {
        val localVariableConfig = clientTaxInformationListRequestConfig(clientUuid = clientUuid, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedTaxInformationListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTaxInformationListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationList
    *
    * @param clientUuid  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientTaxInformationListRequestConfig(clientUuid: java.util.UUID, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/tax-informations/".replace("{"+"client_uuid"+"}", "$clientUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client tax inforation
    * @param clientUuid  
    * @param uuid  
    * @param patchedTaxInformationCreateUpdate  (optional)
    * @return TaxInformationCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedTaxInformationCreateUpdate: PatchedTaxInformationCreateUpdate?) : TaxInformationCreateUpdate {
        val localVariableConfig = clientTaxInformationPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, patchedTaxInformationCreateUpdate = patchedTaxInformationCreateUpdate)

        val localVarResponse = request<PatchedTaxInformationCreateUpdate, TaxInformationCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param patchedTaxInformationCreateUpdate  (optional)
    * @return RequestConfig
    */
    fun clientTaxInformationPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, patchedTaxInformationCreateUpdate: PatchedTaxInformationCreateUpdate?) : RequestConfig<PatchedTaxInformationCreateUpdate> {
        val localVariableBody = patchedTaxInformationCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client tax inforation
    * @param clientUuid  
    * @param uuid  
    * @return TaxInformationList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID) : TaxInformationList {
        val localVariableConfig = clientTaxInformationRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid)

        val localVarResponse = request<Unit, TaxInformationList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @return RequestConfig
    */
    fun clientTaxInformationRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client tax inforation
    * @param clientUuid  
    * @param uuid  
    * @param taxInformationCreateUpdate  
    * @return TaxInformationCreateUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientTaxInformationUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : TaxInformationCreateUpdate {
        val localVariableConfig = clientTaxInformationUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, taxInformationCreateUpdate = taxInformationCreateUpdate)

        val localVarResponse = request<TaxInformationCreateUpdate, TaxInformationCreateUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaxInformationCreateUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientTaxInformationUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param taxInformationCreateUpdate  
    * @return RequestConfig
    */
    fun clientTaxInformationUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, taxInformationCreateUpdate: TaxInformationCreateUpdate) : RequestConfig<TaxInformationCreateUpdate> {
        val localVariableBody = taxInformationCreateUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/tax-informations/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client
    * @param uuid  
    * @param applicationClientUpdate  
    * @return ApplicationClientUpdate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientUpdate(uuid: java.util.UUID, applicationClientUpdate: ApplicationClientUpdate) : ApplicationClientUpdate {
        val localVariableConfig = clientUpdateRequestConfig(uuid = uuid, applicationClientUpdate = applicationClientUpdate)

        val localVarResponse = request<ApplicationClientUpdate, ApplicationClientUpdate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplicationClientUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientUpdate
    *
    * @param uuid  
    * @param applicationClientUpdate  
    * @return RequestConfig
    */
    fun clientUpdateRequestConfig(uuid: java.util.UUID, applicationClientUpdate: ApplicationClientUpdate) : RequestConfig<ApplicationClientUpdate> {
        val localVariableBody = applicationClientUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{uuid}/".replace("{"+"uuid"+"}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a verification for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param verificationCreate  
    * @return VerificationCreate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationCreate(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, verificationCreate: VerificationCreate) : VerificationCreate {
        val localVariableConfig = clientVerificationCreateRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, verificationCreate = verificationCreate)

        val localVarResponse = request<VerificationCreate, VerificationCreate>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationCreate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationCreate
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param verificationCreate  
    * @return RequestConfig
    */
    fun clientVerificationCreateRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, verificationCreate: VerificationCreate) : RequestConfig<VerificationCreate> {
        val localVariableBody = verificationCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Create a verification Document for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param uuid  
    * @param verifyType  
    * @param created  
    * @param updated  
    * @param verificationDocuments  
    * @param status  (optional)
    * @param result  (optional)
    * @return VerificationWithType
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentCreate(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID, verifyType: VerifyTypeEnum, created: java.time.OffsetDateTime, updated: java.time.OffsetDateTime, verificationDocuments: kotlin.collections.List<VerificationDocumentCreate>, status: StatusBd7Enum?, result: OneOfLessThanResultEnumCommaBlankEnumGreaterThan?) : VerificationWithType {
        val localVariableConfig = clientVerificationDocumentCreateRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, uuid = uuid, verifyType = verifyType, created = created, updated = updated, verificationDocuments = verificationDocuments, status = status, result = result)

        val localVarResponse = request<Map<String, Any?>, VerificationWithType>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationWithType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentCreate
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param uuid  
    * @param verifyType  
    * @param created  
    * @param updated  
    * @param verificationDocuments  
    * @param status  (optional)
    * @param result  (optional)
    * @return RequestConfig
    */
    fun clientVerificationDocumentCreateRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid: java.util.UUID, verifyType: VerifyTypeEnum, created: java.time.OffsetDateTime, updated: java.time.OffsetDateTime, verificationDocuments: kotlin.collections.List<VerificationDocumentCreate>, status: StatusBd7Enum?, result: OneOfLessThanResultEnumCommaBlankEnumGreaterThan?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid, "verify_type" to verifyType, "status" to status, "result" to result, "created" to created, "updated" to updated, "verification_documents" to verificationDocuments)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Delete a client verificatoin document
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentDelete(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String) : Unit {
        val localVariableConfig = clientVerificationDocumentDeleteRequestConfig(clientUuid = clientUuid, uuid = uuid, verifyTypeCode = verifyTypeCode)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentDelete
    *
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @return RequestConfig
    */
    fun clientVerificationDocumentDeleteRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Verification Document for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedVerificationDocumentList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentList(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedVerificationDocumentList {
        val localVariableConfig = clientVerificationDocumentListRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedVerificationDocumentList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedVerificationDocumentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentList
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientVerificationDocumentListRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Partial Update a client verification document
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @param uuid2  (optional)
    * @param documentType  (optional)
    * @param documentFront  (optional)
    * @param documentBack  (optional)
    * @return VerificationDocument
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentPartialUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid2: java.util.UUID?, documentType: DocumentTypeEnum?, documentFront: kotlin.String?, documentBack: kotlin.String?) : VerificationDocument {
        val localVariableConfig = clientVerificationDocumentPartialUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, verifyTypeCode = verifyTypeCode, uuid2 = uuid2, documentType = documentType, documentFront = documentFront, documentBack = documentBack)

        val localVarResponse = request<Map<String, Any?>, VerificationDocument>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentPartialUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @param uuid2  (optional)
    * @param documentType  (optional)
    * @param documentFront  (optional)
    * @param documentBack  (optional)
    * @return RequestConfig
    */
    fun clientVerificationDocumentPartialUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid2: java.util.UUID?, documentType: DocumentTypeEnum?, documentFront: kotlin.String?, documentBack: kotlin.String?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid2, "document_type" to documentType, "document_front" to documentFront, "document_back" to documentBack)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client verification document
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @return VerificationDocument
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String) : VerificationDocument {
        val localVariableConfig = clientVerificationDocumentRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, verifyTypeCode = verifyTypeCode)

        val localVarResponse = request<Unit, VerificationDocument>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @return RequestConfig
    */
    fun clientVerificationDocumentRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Update a client verification document
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @param uuid2  
    * @param documentType  
    * @param documentFront  
    * @param documentBack  
    * @return VerificationDocument
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationDocumentUpdate(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid2: java.util.UUID, documentType: DocumentTypeEnum, documentFront: kotlin.String, documentBack: kotlin.String) : VerificationDocument {
        val localVariableConfig = clientVerificationDocumentUpdateRequestConfig(clientUuid = clientUuid, uuid = uuid, verifyTypeCode = verifyTypeCode, uuid2 = uuid2, documentType = documentType, documentFront = documentFront, documentBack = documentBack)

        val localVarResponse = request<Map<String, Any?>, VerificationDocument>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationDocumentUpdate
    *
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @param uuid2  
    * @param documentType  
    * @param documentFront  
    * @param documentBack  
    * @return RequestConfig
    */
    fun clientVerificationDocumentUpdateRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String, uuid2: java.util.UUID, documentType: DocumentTypeEnum, documentFront: kotlin.String, documentBack: kotlin.String) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("uuid" to uuid2, "document_type" to documentType, "document_front" to documentFront, "document_back" to documentBack)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/documents/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * List Verification for a client
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return PaginatedVerificationListList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationList(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : PaginatedVerificationListList {
        val localVariableConfig = clientVerificationListRequestConfig(clientUuid = clientUuid, verifyTypeCode = verifyTypeCode, limit = limit, offset = offset)

        val localVarResponse = request<Unit, PaginatedVerificationListList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedVerificationListList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationList
    *
    * @param clientUuid  
    * @param verifyTypeCode  
    * @param limit Number of results to return per page. (optional)
    * @param offset The initial index from which to return the results. (optional)
    * @return RequestConfig
    */
    fun clientVerificationListRequestConfig(clientUuid: java.util.UUID, verifyTypeCode: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Retrieve a client verification 
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @return VerificationList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientVerificationRetrieve(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String) : VerificationList {
        val localVariableConfig = clientVerificationRetrieveRequestConfig(clientUuid = clientUuid, uuid = uuid, verifyTypeCode = verifyTypeCode)

        val localVarResponse = request<Unit, VerificationList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientVerificationRetrieve
    *
    * @param clientUuid  
    * @param uuid  
    * @param verifyTypeCode  
    * @return RequestConfig
    */
    fun clientVerificationRetrieveRequestConfig(clientUuid: java.util.UUID, uuid: java.util.UUID, verifyTypeCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/clients/{client_uuid}/verifications/{verify_type_code}/{uuid}/".replace("{"+"client_uuid"+"}", "$clientUuid").replace("{"+"uuid"+"}", "$uuid").replace("{"+"verify_type_code"+"}", "$verifyTypeCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
