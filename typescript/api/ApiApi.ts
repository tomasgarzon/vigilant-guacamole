/**
 * Nucoro API
 * No description
 *
 * The version of the OpenAPI document: 4.175.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class ApiApi {
    protected basePath = 'http://localhost';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param format 
     * @param lang 
     */
    public apiSchemaRetrieve(format?: 'json' | 'yaml', lang?: 'de-ch' | 'en-ch' | 'en-gb' | 'es-es' | 'fr-ch' | 'it-ch', extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: { [key: string]: any; };  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/schema/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (format !== null && format !== undefined) {
            queryParameters['format'] = <string><any>format;
        }
        if (lang !== null && lang !== undefined) {
            queryParameters['lang'] = <string><any>lang;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/vnd.oai.openapi', 
            'application/yaml', 
            'application/vnd.oai.openapi+json', 
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: { [key: string]: any; };  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: { [key: string]: any; }, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2AdviceEnginesEtsCategoriesList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedCategoryList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/ets/categories/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedCategoryList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedCategoryList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2AdviceEnginesEtsCoreCategoryGroupsList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedCoreCategoryGroupList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/ets/core-category-groups/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedCoreCategoryGroupList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedCoreCategoryGroupList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * The forecast positions and amounts for the time_horizon and  risk_level chosen. Taking into account the initial_auto_deposit and the initial_amount jointly with the selected filters.
     * @param eTSForecastRequest 
     */
    public apiV2AdviceEnginesEtsForecastCreate(eTSForecastRequest: models.ETSForecastRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ETSForecastRequest;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/ets/forecast/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'eTSForecastRequest' is not null or undefined
        if (eTSForecastRequest === null || eTSForecastRequest === undefined) {
            throw new Error('Required parameter eTSForecastRequest was null or undefined when calling apiV2AdviceEnginesEtsForecastCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(eTSForecastRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ETSForecastRequest;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ETSForecastRequest, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2AdviceEnginesEtsPresetCategoryGroupsList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPresetCategoryGroupList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/ets/preset-category-groups/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPresetCategoryGroupList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPresetCategoryGroupList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * The forecast positions and amounts for the time_horizon chosen. Taking into account the initial_auto_deposit and the initial_amount jointly with the selected filters.
     * @param modelPortfolioForecastRequest 
     */
    public apiV2AdviceEnginesModelPortfolioForecastCreate(modelPortfolioForecastRequest: models.ModelPortfolioForecastRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ModelPortfolioForecastRequest;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/model-portfolio/forecast/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'modelPortfolioForecastRequest' is not null or undefined
        if (modelPortfolioForecastRequest === null || modelPortfolioForecastRequest === undefined) {
            throw new Error('Required parameter modelPortfolioForecastRequest was null or undefined when calling apiV2AdviceEnginesModelPortfolioForecastCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(modelPortfolioForecastRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ModelPortfolioForecastRequest;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ModelPortfolioForecastRequest, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param extraData Additional ModelPortfolio attributes
     * @param limit Number of results to return per page.
     * @param name 
     * @param offset The initial index from which to return the results.
     * @param riskHigher 
     * @param riskLevel 
     * @param riskLower 
     */
    public apiV2AdviceEnginesModelPortfolioModelPortfoliosList(extraData?: { [key: string]: any; }, limit?: number, name?: string, offset?: number, riskHigher?: number, riskLevel?: number, riskLower?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedInvestorModelPortfolioList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/model-portfolio/model-portfolios/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (extraData !== null && extraData !== undefined) {
            queryParameters['extra_data'] = <string><any>extraData;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (name !== null && name !== undefined) {
            queryParameters['name'] = <string><any>name;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (riskHigher !== null && riskHigher !== undefined) {
            queryParameters['risk_higher'] = <string><any>riskHigher;
        }
        if (riskLevel !== null && riskLevel !== undefined) {
            queryParameters['risk_level'] = <string><any>riskLevel;
        }
        if (riskLower !== null && riskLower !== undefined) {
            queryParameters['risk_lower'] = <string><any>riskLower;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedInvestorModelPortfolioList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedInvestorModelPortfolioList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param uuid 
     */
    public apiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve(uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.InvestorModelPortfolio;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/advice-engines/model-portfolio/model-portfolios/{uuid}/'.replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2AdviceEnginesModelPortfolioModelPortfoliosRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.InvestorModelPortfolio;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.InvestorModelPortfolio, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieve all asset categories
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param type 
     */
    public apiV2AssetsCategoriesList(limit?: number, offset?: number, type?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedAssetCategoryList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/categories/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (type !== null && type !== undefined) {
            queryParameters['type'] = <string><any>type;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedAssetCategoryList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedAssetCategoryList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
     * @param assetIdentifier 
     */
    public apiV2AssetsIntradayPricesLatestRetrieve(assetIdentifier: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.IntradayPrice;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/{asset_identifier}/intraday-prices/latest/'.replace('{' + 'asset_identifier' + '}', encodeURIComponent(String(assetIdentifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetIdentifier' is not null or undefined
        if (assetIdentifier === null || assetIdentifier === undefined) {
            throw new Error('Required parameter assetIdentifier was null or undefined when calling apiV2AssetsIntradayPricesLatestRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.IntradayPrice;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.IntradayPrice, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
     * @param assetIdentifier 
     * @param dateAfter 
     * @param dateBefore 
     * @param datetimeAfter 
     * @param datetimeBefore 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2AssetsIntradayPricesList(assetIdentifier: string, dateAfter?: string, dateBefore?: string, datetimeAfter?: string, datetimeBefore?: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedIntradayPriceList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/{asset_identifier}/intraday-prices/'.replace('{' + 'asset_identifier' + '}', encodeURIComponent(String(assetIdentifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetIdentifier' is not null or undefined
        if (assetIdentifier === null || assetIdentifier === undefined) {
            throw new Error('Required parameter assetIdentifier was null or undefined when calling apiV2AssetsIntradayPricesList.');
        }

        if (dateAfter !== null && dateAfter !== undefined) {
            queryParameters['date_after'] = dateAfter.toISOString();
        }
        if (dateBefore !== null && dateBefore !== undefined) {
            queryParameters['date_before'] = dateBefore.toISOString();
        }
        if (datetimeAfter !== null && datetimeAfter !== undefined) {
            queryParameters['datetime_after'] = datetimeAfter.toISOString();
        }
        if (datetimeBefore !== null && datetimeBefore !== undefined) {
            queryParameters['datetime_before'] = datetimeBefore.toISOString();
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedIntradayPriceList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedIntradayPriceList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * A list of Assets filtered by category codes. Default is an empty dict which returns the whole universe.
     * @param assetType 
     * @param categoryCode 
     * @param categoryType 
     * @param currency 
     * @param isin 
     * @param limit Number of results to return per page.
     * @param market 
     * @param name 
     * @param offset The initial index from which to return the results.
     * @param status 
     * @param ticker 
     */
    public apiV2AssetsList(assetType?: 'ETF' | 'MUTUAL_FUND' | 'STOCK', categoryCode?: Array<string>, categoryType?: Array<string>, currency?: number, isin?: string, limit?: number, market?: number, name?: string, offset?: number, status?: 'ACTIVE' | 'DELETED' | 'INACTIVE', ticker?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedAssetListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (assetType !== null && assetType !== undefined) {
            queryParameters['asset_type'] = <string><any>assetType;
        }
        if (categoryCode) {
            queryParameters['category_code'] = [];
            categoryCode.forEach((element: any) => {
                queryParameters['category_code'].push(element);
            });
        }
        if (categoryType) {
            queryParameters['category_type'] = [];
            categoryType.forEach((element: any) => {
                queryParameters['category_type'].push(element);
            });
        }
        if (currency !== null && currency !== undefined) {
            queryParameters['currency'] = <string><any>currency;
        }
        if (isin !== null && isin !== undefined) {
            queryParameters['isin'] = <string><any>isin;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (market !== null && market !== undefined) {
            queryParameters['market'] = <string><any>market;
        }
        if (name !== null && name !== undefined) {
            queryParameters['name'] = <string><any>name;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (status !== null && status !== undefined) {
            queryParameters['status'] = <string><any>status;
        }
        if (ticker !== null && ticker !== undefined) {
            queryParameters['ticker'] = <string><any>ticker;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedAssetListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedAssetListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieve asset\'s yearly performance.  This View overwrites ListAPIView\'s \'list\' method because it doesn\'t have any hook that allows us to call \'get_asset_price_year_graph after the filtering is applied.
     * @param assetIdentifier 
     * @param dateYearAfter 
     * @param dateYearBefore 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2AssetsPerformanceList(assetIdentifier: string, dateYearAfter?: number, dateYearBefore?: number, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedAssetGrowthList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/{asset_identifier}/performance/'.replace('{' + 'asset_identifier' + '}', encodeURIComponent(String(assetIdentifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetIdentifier' is not null or undefined
        if (assetIdentifier === null || assetIdentifier === undefined) {
            throw new Error('Required parameter assetIdentifier was null or undefined when calling apiV2AssetsPerformanceList.');
        }

        if (dateYearAfter !== null && dateYearAfter !== undefined) {
            queryParameters['date_year_after'] = <string><any>dateYearAfter;
        }
        if (dateYearBefore !== null && dateYearBefore !== undefined) {
            queryParameters['date_year_before'] = <string><any>dateYearBefore;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedAssetGrowthList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedAssetGrowthList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
     * @param assetIdentifier 
     */
    public apiV2AssetsPricesLatestRetrieve(assetIdentifier: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Price;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/{asset_identifier}/prices/latest/'.replace('{' + 'asset_identifier' + '}', encodeURIComponent(String(assetIdentifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetIdentifier' is not null or undefined
        if (assetIdentifier === null || assetIdentifier === undefined) {
            throw new Error('Required parameter assetIdentifier was null or undefined when calling apiV2AssetsPricesLatestRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Price;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Price, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Prices (from an Asset) list view endpoints.  GET: Prices retrieve (rest framework builtin overriding get_object)
     * @param assetIdentifier 
     * @param dateAfter 
     * @param dateBefore 
     * @param datetimeAfter 
     * @param datetimeBefore 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2AssetsPricesList(assetIdentifier: string, dateAfter?: string, dateBefore?: string, datetimeAfter?: string, datetimeBefore?: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPriceList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/{asset_identifier}/prices/'.replace('{' + 'asset_identifier' + '}', encodeURIComponent(String(assetIdentifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetIdentifier' is not null or undefined
        if (assetIdentifier === null || assetIdentifier === undefined) {
            throw new Error('Required parameter assetIdentifier was null or undefined when calling apiV2AssetsPricesList.');
        }

        if (dateAfter !== null && dateAfter !== undefined) {
            queryParameters['date_after'] = dateAfter.toISOString();
        }
        if (dateBefore !== null && dateBefore !== undefined) {
            queryParameters['date_before'] = dateBefore.toISOString();
        }
        if (datetimeAfter !== null && datetimeAfter !== undefined) {
            queryParameters['datetime_after'] = datetimeAfter.toISOString();
        }
        if (datetimeBefore !== null && datetimeBefore !== undefined) {
            queryParameters['datetime_before'] = datetimeBefore.toISOString();
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPriceList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPriceList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allows get an asset instance by * UUID * ISIN * ISIN & MARKET_CODE * ISIN & MARKET_CODE & CURRENCY_CODE  Examples:     * assets/a66633d7-4418-4c85-9582-01c80df531d4/     * assets/IE00B579F325/     * assets/IE00B579F325_XETR_GBP/     * assets/IE00B579F325_XETR/
     * @param assetIdentifier 
     */
    public apiV2AssetsRetrieve(assetIdentifier: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.AssetDetail;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/assets/{asset_identifier}/'.replace('{' + 'asset_identifier' + '}', encodeURIComponent(String(assetIdentifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetIdentifier' is not null or undefined
        if (assetIdentifier === null || assetIdentifier === undefined) {
            throw new Error('Required parameter assetIdentifier was null or undefined when calling apiV2AssetsRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.AssetDetail;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.AssetDetail, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param dateFrom 
     * @param dateTo 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param status 
     */
    public apiV2BillingInvoicesList(dateFrom?: string, dateTo?: string, limit?: number, offset?: number, status?: 'CHARGED' | 'PENDING', extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedInvoiceListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/billing/invoices/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (dateFrom !== null && dateFrom !== undefined) {
            queryParameters['date_from'] = dateFrom.toISOString();
        }
        if (dateTo !== null && dateTo !== undefined) {
            queryParameters['date_to'] = dateTo.toISOString();
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (status !== null && status !== undefined) {
            queryParameters['status'] = <string><any>status;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedInvoiceListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedInvoiceListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * This mixin implements binary responses. It supports PDF and Base64. It can be adapted to any django View that implements the retrieve method
     * @param uuid 
     * @param format 
     */
    public apiV2BillingInvoicesRetrieve(uuid: string, format?: 'base64' | 'json' | 'pdf', extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.InvoiceDetails;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/billing/invoices/{uuid}/'.replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2BillingInvoicesRetrieve.');
        }

        if (format !== null && format !== undefined) {
            queryParameters['format'] = <string><any>format;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'application/pdf', 
            'text/plain'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.InvoiceDetails;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.InvoiceDetails, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param createOrder 
     */
    public apiV2BrokerOrdersCreate(portfolioUuid: string, createOrder: models.CreateOrder, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.CreateOrder;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/broker/orders/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2BrokerOrdersCreate.');
        }

        // verify required parameter 'createOrder' is not null or undefined
        if (createOrder === null || createOrder === undefined) {
            throw new Error('Required parameter createOrder was null or undefined when calling apiV2BrokerOrdersCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(createOrder);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.CreateOrder;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.CreateOrder, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Cancel or request cancellation to the broker
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2BrokerOrdersDestroy(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/broker/orders/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2BrokerOrdersDestroy.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2BrokerOrdersDestroy.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param adviceExternalId 
     * @param asset 
     * @param completedAfter 
     * @param completedBefore 
     * @param extraData Additional order attributes for the specific portal
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param portfolio 
     * @param status 
     */
    public apiV2BrokerOrdersList(portfolioUuid: string, adviceExternalId?: string, asset?: string, completedAfter?: string, completedBefore?: string, extraData?: { [key: string]: any; }, limit?: number, offset?: number, portfolio?: string, status?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedOrderListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/broker/orders/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2BrokerOrdersList.');
        }

        if (adviceExternalId !== null && adviceExternalId !== undefined) {
            queryParameters['advice_external_id'] = <string><any>adviceExternalId;
        }
        if (asset !== null && asset !== undefined) {
            queryParameters['asset'] = <string><any>asset;
        }
        if (completedAfter !== null && completedAfter !== undefined) {
            queryParameters['completed_after'] = completedAfter.toISOString();
        }
        if (completedBefore !== null && completedBefore !== undefined) {
            queryParameters['completed_before'] = completedBefore.toISOString();
        }
        if (extraData !== null && extraData !== undefined) {
            queryParameters['extra_data'] = <string><any>extraData;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (portfolio !== null && portfolio !== undefined) {
            queryParameters['portfolio'] = <string><any>portfolio;
        }
        if (status !== null && status !== undefined) {
            queryParameters['status'] = <string><any>status;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedOrderListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedOrderListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2BrokerOrdersRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.OrderList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/broker/orders/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2BrokerOrdersRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2BrokerOrdersRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.OrderList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.OrderList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Request e-mail account verification notification.
     * @param emailVerifyRequest 
     */
    public apiV2ClientsMeVerifyEmailCreate(emailVerifyRequest?: models.EmailVerifyRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.EmailVerifyRequest;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/clients/me/verify/email/';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(emailVerifyRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.EmailVerifyRequest;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.EmailVerifyRequest, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2ClientsNationalDocumentsList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedNationalDocumentList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/clients/national_documents/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedNationalDocumentList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedNationalDocumentList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieves the currently logged in client referral code
     * @param referralCode 
     */
    public apiV2ClientsReferralRetrieve(referralCode: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ClientReferral;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/clients/referral/{referral_code}/'.replace('{' + 'referral_code' + '}', encodeURIComponent(String(referralCode)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'referralCode' is not null or undefined
        if (referralCode === null || referralCode === undefined) {
            throw new Error('Required parameter referralCode was null or undefined when calling apiV2ClientsReferralRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ClientReferral;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ClientReferral, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Verify e-mail account with the given email token.
     * @param uuid 
     * @param emailVerifyView 
     */
    public apiV2ClientsVerifyEmailUpdate(uuid: string, emailVerifyView: models.EmailVerifyView, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.EmailVerifyView;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/clients/{uuid}/verify/email/'.replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2ClientsVerifyEmailUpdate.');
        }

        // verify required parameter 'emailVerifyView' is not null or undefined
        if (emailVerifyView === null || emailVerifyView === undefined) {
            throw new Error('Required parameter emailVerifyView was null or undefined when calling apiV2ClientsVerifyEmailUpdate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'PUT',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(emailVerifyView);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.EmailVerifyView;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.EmailVerifyView, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieves the latest access to the client\'s account
     * @param browser 
     * @param browserVersion 
     * @param channel 
     * @param city 
     * @param country 
     * @param deviceBrand 
     * @param deviceModel 
     * @param ipAddress 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param os 
     * @param osVersion 
     * @param userAgent 
     */
    public apiV2FeedsAccessLogsList(browser?: string, browserVersion?: string, channel?: 'ANDROID' | 'BROWSER' | 'IOS', city?: string, country?: number, deviceBrand?: string, deviceModel?: string, ipAddress?: string, limit?: number, offset?: number, os?: string, osVersion?: string, userAgent?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedAccessLogList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/feeds/access-logs/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (browser !== null && browser !== undefined) {
            queryParameters['browser'] = <string><any>browser;
        }
        if (browserVersion !== null && browserVersion !== undefined) {
            queryParameters['browser_version'] = <string><any>browserVersion;
        }
        if (channel !== null && channel !== undefined) {
            queryParameters['channel'] = <string><any>channel;
        }
        if (city !== null && city !== undefined) {
            queryParameters['city'] = <string><any>city;
        }
        if (country !== null && country !== undefined) {
            queryParameters['country'] = <string><any>country;
        }
        if (deviceBrand !== null && deviceBrand !== undefined) {
            queryParameters['device_brand'] = <string><any>deviceBrand;
        }
        if (deviceModel !== null && deviceModel !== undefined) {
            queryParameters['device_model'] = <string><any>deviceModel;
        }
        if (ipAddress !== null && ipAddress !== undefined) {
            queryParameters['ip_address'] = <string><any>ipAddress;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (os !== null && os !== undefined) {
            queryParameters['os'] = <string><any>os;
        }
        if (osVersion !== null && osVersion !== undefined) {
            queryParameters['os_version'] = <string><any>osVersion;
        }
        if (userAgent !== null && userAgent !== undefined) {
            queryParameters['user_agent'] = <string><any>userAgent;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedAccessLogList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedAccessLogList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param target 
     */
    public apiV2FeedsActivitiesList(limit?: number, offset?: number, target?: Array<'' | 'cashcorporateaction' | 'charge' | 'deposit' | 'portfolio' | 'rebalance' | 'sharescorporateaction' | 'withdrawal'>, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedFeedActivityListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/feeds/activities/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (target) {
            queryParameters['target'] = [];
            target.forEach((element: any) => {
                queryParameters['target'].push(element);
            });
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedFeedActivityListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedFeedActivityListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param goalUuid 
     * @param goal 
     */
    public apiV2GoalsCreate(goalUuid: string, goal: models.Goal, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Goal;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/'.replace('{' + 'goal_uuid' + '}', encodeURIComponent(String(goalUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'goalUuid' is not null or undefined
        if (goalUuid === null || goalUuid === undefined) {
            throw new Error('Required parameter goalUuid was null or undefined when calling apiV2GoalsCreate.');
        }

        // verify required parameter 'goal' is not null or undefined
        if (goal === null || goal === undefined) {
            throw new Error('Required parameter goal was null or undefined when calling apiV2GoalsCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(goal);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Goal;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Goal, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Return a Goal Forecast Decumulation
     * @param forecastDecumulationRequest 
     */
    public apiV2GoalsDecumulationCreate(forecastDecumulationRequest: models.ForecastDecumulationRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ForecastDecumulationRequest;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/decumulation/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'forecastDecumulationRequest' is not null or undefined
        if (forecastDecumulationRequest === null || forecastDecumulationRequest === undefined) {
            throw new Error('Required parameter forecastDecumulationRequest was null or undefined when calling apiV2GoalsDecumulationCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(forecastDecumulationRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ForecastDecumulationRequest;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ForecastDecumulationRequest, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param goalUuid 
     * @param uuid 
     */
    public apiV2GoalsDestroy(goalUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/{uuid}/'.replace('{' + 'goal_uuid' + '}', encodeURIComponent(String(goalUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'goalUuid' is not null or undefined
        if (goalUuid === null || goalUuid === undefined) {
            throw new Error('Required parameter goalUuid was null or undefined when calling apiV2GoalsDestroy.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2GoalsDestroy.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Return a Goal Forecast
     * @param forecastRequest 
     */
    public apiV2GoalsForecastCreate(forecastRequest: models.ForecastRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ForecastRequest;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/forecast/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'forecastRequest' is not null or undefined
        if (forecastRequest === null || forecastRequest === undefined) {
            throw new Error('Required parameter forecastRequest was null or undefined when calling apiV2GoalsForecastCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(forecastRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ForecastRequest;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ForecastRequest, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param goalUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2GoalsList(goalUuid: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedGoalList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/'.replace('{' + 'goal_uuid' + '}', encodeURIComponent(String(goalUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'goalUuid' is not null or undefined
        if (goalUuid === null || goalUuid === undefined) {
            throw new Error('Required parameter goalUuid was null or undefined when calling apiV2GoalsList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedGoalList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedGoalList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param goalUuid 
     * @param uuid 
     * @param patchedGoal 
     */
    public apiV2GoalsPartialUpdate(goalUuid: string, uuid: string, patchedGoal?: models.PatchedGoal, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Goal;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/{uuid}/'.replace('{' + 'goal_uuid' + '}', encodeURIComponent(String(goalUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'goalUuid' is not null or undefined
        if (goalUuid === null || goalUuid === undefined) {
            throw new Error('Required parameter goalUuid was null or undefined when calling apiV2GoalsPartialUpdate.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2GoalsPartialUpdate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'PATCH',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(patchedGoal);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Goal;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Goal, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param goalUuid 
     * @param uuid 
     */
    public apiV2GoalsRetrieve(goalUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Goal;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/goals/{uuid}/'.replace('{' + 'goal_uuid' + '}', encodeURIComponent(String(goalUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'goalUuid' is not null or undefined
        if (goalUuid === null || goalUuid === undefined) {
            throw new Error('Required parameter goalUuid was null or undefined when calling apiV2GoalsRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2GoalsRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Goal;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Goal, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * List all messages from a conversation uuid
     * @param conversation 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2InboxConversationDetailMessagesList(conversation: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedMessageList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/inbox/conversations/{conversation}/'.replace('{' + 'conversation' + '}', encodeURIComponent(String(conversation)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'conversation' is not null or undefined
        if (conversation === null || conversation === undefined) {
            throw new Error('Required parameter conversation was null or undefined when calling apiV2InboxConversationDetailMessagesList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedMessageList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedMessageList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * get: List all conversations with last_message of a user  post: Create new conversation with N messages (without attachments)
     * @param uuid 
     * @param portal 
     * @param created 
     * @param subject 
     * @param messages 
     */
    public apiV2InboxConversationsCreate(uuid: string, portal: number, created: string, subject: string, messages?: models.models.Message, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ConversationCreate;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/inbox/conversations/';

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2InboxConversationsCreate.');
        }

        // verify required parameter 'portal' is not null or undefined
        if (portal === null || portal === undefined) {
            throw new Error('Required parameter portal was null or undefined when calling apiV2InboxConversationsCreate.');
        }

        // verify required parameter 'created' is not null or undefined
        if (created === null || created === undefined) {
            throw new Error('Required parameter created was null or undefined when calling apiV2InboxConversationsCreate.');
        }

        // verify required parameter 'subject' is not null or undefined
        if (subject === null || subject === undefined) {
            throw new Error('Required parameter subject was null or undefined when calling apiV2InboxConversationsCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        if (uuid !== null && uuid !== undefined) {
            formParams.append('uuid', <any>uuid);
        }
        if (portal !== null && portal !== undefined) {
            formParams.append('portal', <any>portal);
        }
        if (created !== null && created !== undefined) {
            formParams.append('created', <any>created);
        }
        if (subject !== null && subject !== undefined) {
            formParams.append('subject', <any>subject);
        }
        if (messages !== null && messages !== undefined) {
            formParams.append('messages', <any>messages);
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ConversationCreate;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ConversationCreate, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * get: List all conversations with last_message of a user  post: Create new conversation with N messages (without attachments)
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2InboxConversationsList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedConversationListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/inbox/conversations/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedConversationListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedConversationListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * View to access to an attachment
     * @param conversation 
     * @param message 
     * @param uuid 
     * @param format 
     */
    public apiV2InboxConversationsMessagesAttachmentsRetrieve(conversation: string, message: string, uuid: string, format?: 'base64' | 'json' | 'pdf', extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Attachment;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/inbox/conversations/{conversation}/messages/{message}/attachments/{uuid}/'.replace('{' + 'conversation' + '}', encodeURIComponent(String(conversation))).replace('{' + 'message' + '}', encodeURIComponent(String(message))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'conversation' is not null or undefined
        if (conversation === null || conversation === undefined) {
            throw new Error('Required parameter conversation was null or undefined when calling apiV2InboxConversationsMessagesAttachmentsRetrieve.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling apiV2InboxConversationsMessagesAttachmentsRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2InboxConversationsMessagesAttachmentsRetrieve.');
        }

        if (format !== null && format !== undefined) {
            queryParameters['format'] = <string><any>format;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'application/pdf', 
            'text/plain'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Attachment;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Attachment, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * View for creating message on a specific conversation
     * @param conversation 
     * @param user 
     * @param readDate 
     * @param created 
     * @param attachments 
     * @param uuid 
     * @param content 
     */
    public apiV2InboxConversationsMessagesCreate(conversation: string, user: string, readDate: string, created: string, attachments: Array<models.Attachment>, uuid: string, content?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Message;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/inbox/conversations/{conversation}/messages/'.replace('{' + 'conversation' + '}', encodeURIComponent(String(conversation)));

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        // verify required parameter 'conversation' is not null or undefined
        if (conversation === null || conversation === undefined) {
            throw new Error('Required parameter conversation was null or undefined when calling apiV2InboxConversationsMessagesCreate.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling apiV2InboxConversationsMessagesCreate.');
        }

        // verify required parameter 'readDate' is not null or undefined
        if (readDate === null || readDate === undefined) {
            throw new Error('Required parameter readDate was null or undefined when calling apiV2InboxConversationsMessagesCreate.');
        }

        // verify required parameter 'created' is not null or undefined
        if (created === null || created === undefined) {
            throw new Error('Required parameter created was null or undefined when calling apiV2InboxConversationsMessagesCreate.');
        }

        // verify required parameter 'attachments' is not null or undefined
        if (attachments === null || attachments === undefined) {
            throw new Error('Required parameter attachments was null or undefined when calling apiV2InboxConversationsMessagesCreate.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2InboxConversationsMessagesCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        if (user !== null && user !== undefined) {
            formParams.append('user', <any>user);
        }
        if (readDate !== null && readDate !== undefined) {
            formParams.append('read_date', <any>readDate);
        }
        if (content !== null && content !== undefined) {
            formParams.append('content', <any>content);
        }
        if (created !== null && created !== undefined) {
            formParams.append('created', <any>created);
        }
        if (attachments) {
            formParams.append('attachments', attachments.join(COLLECTION_FORMATS['csv']));
        }
        if (uuid !== null && uuid !== undefined) {
            formParams.append('uuid', <any>uuid);
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Message;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Message, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Returns the number of the last required APP Version for a platform.
     * @param platform 
     */
    public apiV2MobileVersionRetrieve(platform: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.MinimumAppVersion;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/mobile/{platform}/version/'.replace('{' + 'platform' + '}', encodeURIComponent(String(platform)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'platform' is not null or undefined
        if (platform === null || platform === undefined) {
            throw new Error('Required parameter platform was null or undefined when calling apiV2MobileVersionRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.MinimumAppVersion;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.MinimumAppVersion, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     */
    public apiV2PlatformSettingsList(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.NucoroSetting>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/platform/settings/';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.NucoroSetting>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.NucoroSetting>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieves the list of countries
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortalCountriesList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedCountryListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portal/countries/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedCountryListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedCountryListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     */
    public apiV2PortalSettingsRetrieve(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PortalSettingValueList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portal/settings/';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (basicAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PortalSettingValueList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PortalSettingValueList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieves the current ToS for the Portal
     */
    public apiV2PortalTosCurrentRetrieve(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Tos;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portal/tos/current/';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Tos;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Tos, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * List all ToS for the current Portal
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortalTosList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedTosList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portal/tos/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedTosList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedTosList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Retrieves a specific ToS
     * @param uuid 
     */
    public apiV2PortalTosRetrieve(uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Tos;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portal/tos/{uuid}/'.replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortalTosRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Tos;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Tos, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param target 
     */
    public apiV2PortfoliosActivitiesList(portfolioUuid: string, limit?: number, offset?: number, target?: Array<'' | 'cashcorporateaction' | 'charge' | 'deposit' | 'portfolio' | 'rebalance' | 'sharescorporateaction' | 'withdrawal'>, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedFeedActivityListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/activities/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosActivitiesList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (target) {
            queryParameters['target'] = [];
            target.forEach((element: any) => {
                queryParameters['target'].push(element);
            });
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedFeedActivityListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedFeedActivityListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosActivitiesRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.FeedActivityList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/activities/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosActivitiesRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosActivitiesRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.FeedActivityList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.FeedActivityList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     */
    public apiV2PortfoliosAllocationsEndDay(portfolioUuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.AllocationList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosAllocationsEndDay.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.AllocationList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.AllocationList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param allocationDate 
     * @param portfolioUuid 
     */
    public apiV2PortfoliosAllocationsEndDayByDateRetrieve(allocationDate: string, portfolioUuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.AllocationDetail;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/{allocation_date}/'.replace('{' + 'allocation_date' + '}', encodeURIComponent(String(allocationDate))).replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'allocationDate' is not null or undefined
        if (allocationDate === null || allocationDate === undefined) {
            throw new Error('Required parameter allocationDate was null or undefined when calling apiV2PortfoliosAllocationsEndDayByDateRetrieve.');
        }

        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosAllocationsEndDayByDateRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.AllocationDetail;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.AllocationDetail, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     */
    public apiV2PortfoliosAllocationsEndDayLatestRetrieve(portfolioUuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.AllocationDetail;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/allocations/end-day/latest/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosAllocationsEndDayLatestRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.AllocationDetail;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.AllocationDetail, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allocations History for a given portfolio  It accepts two optional parameters, `date_to` and `date_from` to limit the daily allocations to a certain data range. If they are not given, all the allocations are returned.  ---  ## Parameters:   * **name**: `date_from`  * **description**: The initial date.  * **parameter type**: query param   * **name**: `date_from`  * **description**: The final date.  * **parameter type**: query param
     * @param portfolio 
     */
    public apiV2PortfoliosAllocationsHistoryRetrieve(portfolio: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio}/allocations/history/'.replace('{' + 'portfolio' + '}', encodeURIComponent(String(portfolio)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolio' is not null or undefined
        if (portfolio === null || portfolio === undefined) {
            throw new Error('Required parameter portfolio was null or undefined when calling apiV2PortfoliosAllocationsHistoryRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     */
    public apiV2PortfoliosAllocationsIntradayLatestRetrieve(portfolioUuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.CurrentAllocation;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/allocations/intraday/latest/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosAllocationsIntradayLatestRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.CurrentAllocation;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.CurrentAllocation, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param valuationDateAfter 
     * @param valuationDateBefore 
     */
    public apiV2PortfoliosAllocationsList(portfolioUuid: string, limit?: number, offset?: number, valuationDateAfter?: string, valuationDateBefore?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedAllocationListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/allocations/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosAllocationsList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (valuationDateAfter !== null && valuationDateAfter !== undefined) {
            queryParameters['valuation_date_after'] = valuationDateAfter.toISOString();
        }
        if (valuationDateBefore !== null && valuationDateBefore !== undefined) {
            queryParameters['valuation_date_before'] = valuationDateBefore.toISOString();
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedAllocationListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedAllocationListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param id A unique integer value identifying this allocation.
     * @param portfolioUuid 
     */
    public apiV2PortfoliosAllocationsRetrieve(id: number, portfolioUuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.AllocationList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/allocations/{id}/'.replace('{' + 'id' + '}', encodeURIComponent(String(id))).replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiV2PortfoliosAllocationsRetrieve.');
        }

        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosAllocationsRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.AllocationList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.AllocationList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param portfolioCreate 
     */
    public apiV2PortfoliosCreate(portfolioUuid: string, portfolioCreate: models.PortfolioCreate, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PortfolioCreate;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosCreate.');
        }

        // verify required parameter 'portfolioCreate' is not null or undefined
        if (portfolioCreate === null || portfolioCreate === undefined) {
            throw new Error('Required parameter portfolioCreate was null or undefined when calling apiV2PortfoliosCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(portfolioCreate);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PortfolioCreate;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PortfolioCreate, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param depositCreate 
     */
    public apiV2PortfoliosDepositsCreate(portfolioUuid: string, depositCreate: models.DepositCreate, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.DepositCreate;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/deposits/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosDepositsCreate.');
        }

        // verify required parameter 'depositCreate' is not null or undefined
        if (depositCreate === null || depositCreate === undefined) {
            throw new Error('Required parameter depositCreate was null or undefined when calling apiV2PortfoliosDepositsCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(depositCreate);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.DepositCreate;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.DepositCreate, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosDepositsDestroy(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/deposits/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosDepositsDestroy.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosDepositsDestroy.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param status 
     */
    public apiV2PortfoliosDepositsList(portfolioUuid: string, limit?: number, offset?: number, status?: Array<'CANCELLED' | 'COMPLETED' | 'ERROR' | 'PENDING' | 'PROCESSING' | 'REQUESTED'>, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedDepositListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/deposits/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosDepositsList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (status) {
            queryParameters['status'] = [];
            status.forEach((element: any) => {
                queryParameters['status'].push(element);
            });
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedDepositListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedDepositListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosDepositsRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.DepositDetail;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/deposits/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosDepositsRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosDepositsRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.DepositDetail;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.DepositDetail, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosDestroy(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosDestroy.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosDestroy.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param client 
     * @param externalCustodianId 
     * @param limit Number of results to return per page.
     * @param name 
     * @param offset The initial index from which to return the results.
     * @param ordering Ordering
     * @param portfolioType 
     * @param status 
     * @param valuationDateAfter 
     * @param valuationDateBefore 
     */
    public apiV2PortfoliosList(portfolioUuid: string, client?: string, externalCustodianId?: string, limit?: number, name?: string, offset?: number, ordering?: Array<'-name' | '-risk_level' | 'name' | 'risk_level'>, portfolioType?: number, status?: Array<'ACTIVE' | 'DELETED' | 'DELETING' | 'PENDING'>, valuationDateAfter?: string, valuationDateBefore?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPortfolioListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosList.');
        }

        if (client !== null && client !== undefined) {
            queryParameters['client'] = <string><any>client;
        }
        if (externalCustodianId !== null && externalCustodianId !== undefined) {
            queryParameters['external_custodian_id'] = <string><any>externalCustodianId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (name !== null && name !== undefined) {
            queryParameters['name'] = <string><any>name;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (ordering) {
            queryParameters['ordering'] = ordering.join(COLLECTION_FORMATS['csv']);
        }
        if (portfolioType !== null && portfolioType !== undefined) {
            queryParameters['portfolio_type'] = <string><any>portfolioType;
        }
        if (status) {
            queryParameters['status'] = [];
            status.forEach((element: any) => {
                queryParameters['status'].push(element);
            });
        }
        if (valuationDateAfter !== null && valuationDateAfter !== undefined) {
            queryParameters['valuation_date_after'] = valuationDateAfter.toISOString();
        }
        if (valuationDateBefore !== null && valuationDateBefore !== undefined) {
            queryParameters['valuation_date_before'] = valuationDateBefore.toISOString();
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPortfolioListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPortfolioListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param createOrder 
     */
    public apiV2PortfoliosOrdersCreate(portfolioUuid: string, createOrder: models.CreateOrder, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.CreateOrder;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/orders/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosOrdersCreate.');
        }

        // verify required parameter 'createOrder' is not null or undefined
        if (createOrder === null || createOrder === undefined) {
            throw new Error('Required parameter createOrder was null or undefined when calling apiV2PortfoliosOrdersCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(createOrder);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.CreateOrder;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.CreateOrder, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Cancel or request cancellation to the broker
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosOrdersDestroy(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/orders/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosOrdersDestroy.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosOrdersDestroy.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param adviceExternalId 
     * @param asset 
     * @param completedAfter 
     * @param completedBefore 
     * @param extraData Additional order attributes for the specific portal
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param portfolio 
     * @param status 
     */
    public apiV2PortfoliosOrdersList(portfolioUuid: string, adviceExternalId?: string, asset?: string, completedAfter?: string, completedBefore?: string, extraData?: { [key: string]: any; }, limit?: number, offset?: number, portfolio?: string, status?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedOrderListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/orders/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosOrdersList.');
        }

        if (adviceExternalId !== null && adviceExternalId !== undefined) {
            queryParameters['advice_external_id'] = <string><any>adviceExternalId;
        }
        if (asset !== null && asset !== undefined) {
            queryParameters['asset'] = <string><any>asset;
        }
        if (completedAfter !== null && completedAfter !== undefined) {
            queryParameters['completed_after'] = completedAfter.toISOString();
        }
        if (completedBefore !== null && completedBefore !== undefined) {
            queryParameters['completed_before'] = completedBefore.toISOString();
        }
        if (extraData !== null && extraData !== undefined) {
            queryParameters['extra_data'] = <string><any>extraData;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (portfolio !== null && portfolio !== undefined) {
            queryParameters['portfolio'] = <string><any>portfolio;
        }
        if (status !== null && status !== undefined) {
            queryParameters['status'] = <string><any>status;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedOrderListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedOrderListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosOrdersRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.OrderList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/orders/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosOrdersRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosOrdersRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.OrderList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.OrderList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param uuid 
     * @param patchedPortfolioUpdate 
     */
    public apiV2PortfoliosPartialUpdate(portfolioUuid: string, uuid: string, patchedPortfolioUpdate?: models.PatchedPortfolioUpdate, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PortfolioUpdate;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosPartialUpdate.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosPartialUpdate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'PATCH',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(patchedPortfolioUpdate);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PortfolioUpdate;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PortfolioUpdate, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param dateAfter 
     * @param dateBefore 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortfoliosPerformanceMwrrList(portfolioUuid: string, dateAfter?: string, dateBefore?: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPortfolioPerformanceList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/performance/mwrr/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosPerformanceMwrrList.');
        }

        if (dateAfter !== null && dateAfter !== undefined) {
            queryParameters['date_after'] = dateAfter.toISOString();
        }
        if (dateBefore !== null && dateBefore !== undefined) {
            queryParameters['date_before'] = dateBefore.toISOString();
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPortfolioPerformanceList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPortfolioPerformanceList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortfoliosPerformancePositionsList(portfolioUuid: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPortfolioPerformancePositionsList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/performance/positions/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosPerformancePositionsList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPortfolioPerformancePositionsList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPortfolioPerformancePositionsList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param dateAfter 
     * @param dateBefore 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortfoliosPerformanceTwrrList(portfolioUuid: string, dateAfter?: string, dateBefore?: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPortfolioPerformanceList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/performance/twrr/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosPerformanceTwrrList.');
        }

        if (dateAfter !== null && dateAfter !== undefined) {
            queryParameters['date_after'] = dateAfter.toISOString();
        }
        if (dateBefore !== null && dateBefore !== undefined) {
            queryParameters['date_before'] = dateBefore.toISOString();
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPortfolioPerformanceList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPortfolioPerformanceList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortfoliosPortfoliotypesList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedPortfolioTypeList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/portfoliotypes/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedPortfolioTypeList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedPortfolioTypeList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param code 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortfoliosPortfoliotypesRestrictionsList(code: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedBasePortfolioTypeRestrictionsList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/portfoliotypes/{code}/restrictions/'.replace('{' + 'code' + '}', encodeURIComponent(String(code)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling apiV2PortfoliosPortfoliotypesRestrictionsList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedBasePortfolioTypeRestrictionsList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedBasePortfolioTypeRestrictionsList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2PortfoliosRebalancesList(portfolioUuid: string, limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedRebalanceList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/rebalances/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosRebalancesList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedRebalanceList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedRebalanceList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosRebalancesRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Rebalance;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/rebalances/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosRebalancesRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosRebalancesRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Rebalance;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Rebalance, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosRestrictionsRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PortfolioTypeRestrictions;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{uuid}/restrictions/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosRestrictionsRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosRestrictionsRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PortfolioTypeRestrictions;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PortfolioTypeRestrictions, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PortfolioDetail;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PortfolioDetail;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PortfolioDetail, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Allow aggregate/group fields of the ModelView model or its related entities.    Query params should use dot notation.  Requires:     ListModelMixin (ListAPIView, ListCreateApiView)  Args:     * aggregatable_fields (dict): optional.         Keys: fields that allow aggregation (including related entities with \"__\" notation).         Values: django qs functions or aggregate_fns         Example:             aggregatable_fields = {                 \'allocations__balance\': [Sum, Avg],             }      * groupable_fields (list): optional. fields that allow grouping (including related entities with \"__\" notation).         Example:             groupable_fields = [\'portfolio__portfolio_type\']  Query Param Examples:     >>> ?group_by=portfolio.portfolio_type     >>> ?aggregate[Sum]=portfolio.allocations.balance     >>> ?group_by=valuation_date&aggregate[Sum]=portfolio.allocations.balance
     * @param portfolioUuid 
     * @param uuid 
     * @param portfolioUpdate 
     */
    public apiV2PortfoliosUpdate(portfolioUuid: string, uuid: string, portfolioUpdate: models.PortfolioUpdate, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PortfolioUpdate;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosUpdate.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosUpdate.');
        }

        // verify required parameter 'portfolioUpdate' is not null or undefined
        if (portfolioUpdate === null || portfolioUpdate === undefined) {
            throw new Error('Required parameter portfolioUpdate was null or undefined when calling apiV2PortfoliosUpdate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'PUT',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(portfolioUpdate);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PortfolioUpdate;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PortfolioUpdate, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param investorWithdrawalCreate 
     */
    public apiV2PortfoliosWithdrawalsCreate(portfolioUuid: string, investorWithdrawalCreate: models.InvestorWithdrawalCreate, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.InvestorWithdrawalCreate;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/withdrawals/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosWithdrawalsCreate.');
        }

        // verify required parameter 'investorWithdrawalCreate' is not null or undefined
        if (investorWithdrawalCreate === null || investorWithdrawalCreate === undefined) {
            throw new Error('Required parameter investorWithdrawalCreate was null or undefined when calling apiV2PortfoliosWithdrawalsCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(investorWithdrawalCreate);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.InvestorWithdrawalCreate;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.InvestorWithdrawalCreate, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosWithdrawalsDestroy(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/withdrawals/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosWithdrawalsDestroy.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosWithdrawalsDestroy.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param status 
     */
    public apiV2PortfoliosWithdrawalsList(portfolioUuid: string, limit?: number, offset?: number, status?: Array<'CANCELLED' | 'COMPLETED' | 'DRAFT' | 'ERROR' | 'PENDING' | 'POSITIONS_SOLD' | 'PROCESSING' | 'REQUESTED'>, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedInvestorWithdrawalListList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/withdrawals/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosWithdrawalsList.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }
        if (status) {
            queryParameters['status'] = [];
            status.forEach((element: any) => {
                queryParameters['status'].push(element);
            });
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedInvestorWithdrawalListList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedInvestorWithdrawalListList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param portfolioUuid 
     * @param uuid 
     */
    public apiV2PortfoliosWithdrawalsRetrieve(portfolioUuid: string, uuid: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.WithdrawalDetail;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/portfolios/{portfolio_uuid}/withdrawals/{uuid}/'.replace('{' + 'portfolio_uuid' + '}', encodeURIComponent(String(portfolioUuid))).replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'portfolioUuid' is not null or undefined
        if (portfolioUuid === null || portfolioUuid === undefined) {
            throw new Error('Required parameter portfolioUuid was null or undefined when calling apiV2PortfoliosWithdrawalsRetrieve.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling apiV2PortfoliosWithdrawalsRetrieve.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.WithdrawalDetail;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.WithdrawalDetail, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     */
    public apiV2RiskQuestionsList(limit?: number, offset?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.PaginatedQuestionList;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/risk/questions/';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (offset !== null && offset !== undefined) {
            queryParameters['offset'] = <string><any>offset;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.PaginatedQuestionList;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.PaginatedQuestionList, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param action 
     * @param verifier 
     */
    public apiV2VerificationsVerifierWebhookCreate(action: string, verifier: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/verifications/verifier_webhook/{verifier}/{action}/'.replace('{' + 'action' + '}', encodeURIComponent(String(action))).replace('{' + 'verifier' + '}', encodeURIComponent(String(verifier)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'action' is not null or undefined
        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling apiV2VerificationsVerifierWebhookCreate.');
        }

        // verify required parameter 'verifier' is not null or undefined
        if (verifier === null || verifier === undefined) {
            throw new Error('Required parameter verifier was null or undefined when calling apiV2VerificationsVerifierWebhookCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param websocketAuthentication 
     */
    public apiV2WebsocketAuthenticationTicketCreate(websocketAuthentication: models.WebsocketAuthentication, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.AuthenticationResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/websocket/authentication/ticket/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'websocketAuthentication' is not null or undefined
        if (websocketAuthentication === null || websocketAuthentication === undefined) {
            throw new Error('Required parameter websocketAuthentication was null or undefined when calling apiV2WebsocketAuthenticationTicketCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(websocketAuthentication);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.AuthenticationResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.AuthenticationResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param websocketAuthentication 
     */
    public apiV2WebsocketAuthorizeAssetCreate(websocketAuthentication: models.WebsocketAuthentication, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Response;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/websocket/authorize/asset/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'websocketAuthentication' is not null or undefined
        if (websocketAuthentication === null || websocketAuthentication === undefined) {
            throw new Error('Required parameter websocketAuthentication was null or undefined when calling apiV2WebsocketAuthorizeAssetCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(websocketAuthentication);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Response;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Response, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param websocketAuthentication 
     */
    public apiV2WebsocketAuthorizeCreate(websocketAuthentication: models.WebsocketAuthentication, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Response;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/websocket/authorize/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'websocketAuthentication' is not null or undefined
        if (websocketAuthentication === null || websocketAuthentication === undefined) {
            throw new Error('Required parameter websocketAuthentication was null or undefined when calling apiV2WebsocketAuthorizeCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(websocketAuthentication);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Response;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Response, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param websocketAuthentication 
     */
    public apiV2WebsocketAuthorizePortfolioCreate(websocketAuthentication: models.WebsocketAuthentication, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Response;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/websocket/authorize/portfolio/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'websocketAuthentication' is not null or undefined
        if (websocketAuthentication === null || websocketAuthentication === undefined) {
            throw new Error('Required parameter websocketAuthentication was null or undefined when calling apiV2WebsocketAuthorizePortfolioCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(websocketAuthentication);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Response;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Response, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param subscribe 
     */
    public apiV2WebsocketOnSubscribeCreate(subscribe: models.Subscribe, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Subscribe;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/websocket/on_subscribe/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'subscribe' is not null or undefined
        if (subscribe === null || subscribe === undefined) {
            throw new Error('Required parameter subscribe was null or undefined when calling apiV2WebsocketOnSubscribeCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(subscribe);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Subscribe;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Subscribe, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param unsubscribe 
     */
    public apiV2WebsocketOnUnsubscribeCreate(unsubscribe: models.Unsubscribe, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.Unsubscribe;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/api/v2/websocket/on_unsubscribe/';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'unsubscribe' is not null or undefined
        if (unsubscribe === null || unsubscribe === undefined) {
            throw new Error('Required parameter unsubscribe was null or undefined when calling apiV2WebsocketOnUnsubscribeCreate.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (cookieAuth) required
        // authentication (jwtAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (tokenAuth) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(unsubscribe);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.Unsubscribe;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.Unsubscribe, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
